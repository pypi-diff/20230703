# Comparing `tmp/atoti_core-0.8.1-0_ad0cf24-py3-none-any.whl.zip` & `tmp/atoti_core-0.8.2-0_80138c9-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,80 +1,85 @@
-Zip file size: 68495 bytes, number of entries: 78
--rw-r--r--  2.0 unx    23472 b- defN 23-Jun-20 12:53 atoti_core/LICENSE
--rw-r--r--  2.0 unx     2451 b- defN 23-Jun-20 12:46 atoti_core/__init__.py
--rw-r--r--  2.0 unx     1679 b- defN 23-Jun-20 12:46 atoti_core/_get_endpoint_path.py
--rw-r--r--  2.0 unx      150 b- defN 23-Jun-20 12:46 atoti_core/_other_coordinates.py
--rw-r--r--  2.0 unx      398 b- defN 23-Jun-20 12:46 atoti_core/_server_versions.py
--rw-r--r--  2.0 unx     8811 b- defN 23-Jun-20 12:46 atoti_core/activeviam_client.py
--rw-r--r--  2.0 unx      128 b- defN 23-Jun-20 12:46 atoti_core/arithmetic_operator.py
--rw-r--r--  2.0 unx     2437 b- defN 23-Jun-20 12:46 atoti_core/base_cube.py
--rw-r--r--  2.0 unx      561 b- defN 23-Jun-20 12:46 atoti_core/base_cubes.py
--rw-r--r--  2.0 unx     2277 b- defN 23-Jun-20 12:46 atoti_core/base_hierarchies.py
--rw-r--r--  2.0 unx     5690 b- defN 23-Jun-20 12:46 atoti_core/base_hierarchy.py
--rw-r--r--  2.0 unx     4900 b- defN 23-Jun-20 12:46 atoti_core/base_level.py
--rw-r--r--  2.0 unx     3961 b- defN 23-Jun-20 12:46 atoti_core/base_levels.py
--rw-r--r--  2.0 unx     2522 b- defN 23-Jun-20 12:46 atoti_core/base_measure.py
--rw-r--r--  2.0 unx     1365 b- defN 23-Jun-20 12:46 atoti_core/base_measures.py
--rw-r--r--  2.0 unx    10896 b- defN 23-Jun-20 12:46 atoti_core/base_session.py
--rw-r--r--  2.0 unx      221 b- defN 23-Jun-20 12:46 atoti_core/boolean_operator.py
--rw-r--r--  2.0 unx      420 b- defN 23-Jun-20 12:46 atoti_core/column_coordinates.py
--rw-r--r--  2.0 unx     3537 b- defN 23-Jun-20 12:46 atoti_core/combine_conditions.py
--rw-r--r--  2.0 unx      732 b- defN 23-Jun-20 12:46 atoti_core/comparison_operator.py
--rw-r--r--  2.0 unx      773 b- defN 23-Jun-20 12:46 atoti_core/condition_to_dict.py
--rw-r--r--  2.0 unx      913 b- defN 23-Jun-20 12:46 atoti_core/condition_to_pairs.py
--rw-r--r--  2.0 unx     5240 b- defN 23-Jun-20 12:46 atoti_core/constant.py
--rw-r--r--  2.0 unx       88 b- defN 23-Jun-20 12:46 atoti_core/context.py
--rw-r--r--  2.0 unx     3313 b- defN 23-Jun-20 12:46 atoti_core/convert_series.py
--rw-r--r--  2.0 unx      349 b- defN 23-Jun-20 12:46 atoti_core/coordinates.py
--rw-r--r--  2.0 unx      153 b- defN 23-Jun-20 12:46 atoti_core/coordinates_like.py
--rw-r--r--  2.0 unx     1720 b- defN 23-Jun-20 12:46 atoti_core/create_dataframe.py
--rw-r--r--  2.0 unx     3946 b- defN 23-Jun-20 12:46 atoti_core/data_type.py
--rw-r--r--  2.0 unx     9600 b- defN 23-Jun-20 12:46 atoti_core/decombine_condition.py
--rw-r--r--  2.0 unx       78 b- defN 23-Jun-20 12:46 atoti_core/default_query_timeout.py
--rw-r--r--  2.0 unx     3191 b- defN 23-Jun-20 12:46 atoti_core/delegate_mutable_mapping.py
--rw-r--r--  2.0 unx     1325 b- defN 23-Jun-20 12:46 atoti_core/delegate_mutable_set.py
--rw-r--r--  2.0 unx      553 b- defN 23-Jun-20 12:46 atoti_core/deprecated.py
--rw-r--r--  2.0 unx     1903 b- defN 23-Jun-20 12:46 atoti_core/doc.py
--rw-r--r--  2.0 unx      165 b- defN 23-Jun-20 12:46 atoti_core/empty_mapping.py
--rw-r--r--  2.0 unx     3431 b- defN 23-Jun-20 12:46 atoti_core/fetch_json.py
--rw-r--r--  2.0 unx      590 b- defN 23-Jun-20 12:46 atoti_core/find_corresponding_top_level_variable_name.py
--rw-r--r--  2.0 unx      344 b- defN 23-Jun-20 12:46 atoti_core/get_coordinates.py
--rw-r--r--  2.0 unx      326 b- defN 23-Jun-20 12:46 atoti_core/get_env_flag.py
--rw-r--r--  2.0 unx     1613 b- defN 23-Jun-20 12:46 atoti_core/get_installed_plugins.py
--rw-r--r--  2.0 unx     1008 b- defN 23-Jun-20 12:46 atoti_core/get_ipython.py
--rw-r--r--  2.0 unx     2145 b- defN 23-Jun-20 12:46 atoti_core/get_literal_args.py
--rw-r--r--  2.0 unx      358 b- defN 23-Jun-20 12:46 atoti_core/get_package_version.py
--rw-r--r--  2.0 unx      265 b- defN 23-Jun-20 12:46 atoti_core/get_top_level_package_name.py
--rw-r--r--  2.0 unx      379 b- defN 23-Jun-20 12:46 atoti_core/has_coordinates.py
--rw-r--r--  2.0 unx      402 b- defN 23-Jun-20 12:46 atoti_core/hierarchy_coordinates.py
--rw-r--r--  2.0 unx     4282 b- defN 23-Jun-20 12:46 atoti_core/hierarchy_isin_condition.py
--rw-r--r--  2.0 unx       69 b- defN 23-Jun-20 12:46 atoti_core/hierarchy_key.py
--rw-r--r--  2.0 unx      109 b- defN 23-Jun-20 12:46 atoti_core/http_method.py
--rw-r--r--  2.0 unx      886 b- defN 23-Jun-20 12:46 atoti_core/immutable_mapping.py
--rw-r--r--  2.0 unx      404 b- defN 23-Jun-20 12:46 atoti_core/ipython_key_completions.py
--rw-r--r--  2.0 unx     3420 b- defN 23-Jun-20 12:46 atoti_core/isin_condition.py
--rw-r--r--  2.0 unx      109 b- defN 23-Jun-20 12:46 atoti_core/java_max_int.py
--rw-r--r--  2.0 unx     1011 b- defN 23-Jun-20 12:46 atoti_core/keyword_only_dataclass.py
--rw-r--r--  2.0 unx      695 b- defN 23-Jun-20 12:46 atoti_core/level_coordinates.py
--rw-r--r--  2.0 unx      102 b- defN 23-Jun-20 12:46 atoti_core/level_key.py
--rw-r--r--  2.0 unx      637 b- defN 23-Jun-20 12:46 atoti_core/license_key.py
--rw-r--r--  2.0 unx      364 b- defN 23-Jun-20 12:46 atoti_core/measure_coordinates.py
--rw-r--r--  2.0 unx      282 b- defN 23-Jun-20 12:46 atoti_core/missing_plugin_error.py
--rw-r--r--  2.0 unx     9157 b- defN 23-Jun-20 12:46 atoti_core/operand_convertible_with_coordinates.py
--rw-r--r--  2.0 unx    25609 b- defN 23-Jun-20 12:46 atoti_core/operation.py
--rw-r--r--  2.0 unx      315 b- defN 23-Jun-20 12:46 atoti_core/pandas_nullable_dtype_to_non_nullable_dtype.py
--rw-r--r--  2.0 unx      180 b- defN 23-Jun-20 12:46 atoti_core/path.py
--rw-r--r--  2.0 unx      738 b- defN 23-Jun-20 12:46 atoti_core/plugin.py
--rw-r--r--  2.0 unx      866 b- defN 23-Jun-20 12:46 atoti_core/plugins.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-20 12:46 atoti_core/py.typed
--rw-r--r--  2.0 unx     9949 b- defN 23-Jun-20 12:46 atoti_core/query_doc.py
--rw-r--r--  2.0 unx      405 b- defN 23-Jun-20 12:46 atoti_core/query_filter.py
--rw-r--r--  2.0 unx      789 b- defN 23-Jun-20 12:46 atoti_core/raise_multiple_levels_with_same_name_error.py
--rw-r--r--  2.0 unx     2270 b- defN 23-Jun-20 12:46 atoti_core/reactive_mutable_set.py
--rw-r--r--  2.0 unx     2202 b- defN 23-Jun-20 12:46 atoti_core/repr_json.py
--rw-r--r--  2.0 unx       28 b- defN 23-Jun-20 12:46 atoti_core/scenario.py
--rw-r--r--  2.0 unx      563 b- defN 23-Jun-20 12:46 atoti_core/str_to_bool.py
--rw-r--r--  2.0 unx      855 b- defN 23-Jun-20 12:53 atoti_core-0.8.1.dist-info/METADATA
--rw-r--r--  2.0 unx      109 b- defN 23-Jun-20 12:53 atoti_core-0.8.1.dist-info/WHEEL
--rw-r--r--  2.0 unx       11 b- defN 23-Jun-20 12:53 atoti_core-0.8.1.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     6665 b- defN 23-Jun-20 12:53 atoti_core-0.8.1.dist-info/RECORD
-78 files, 193860 bytes uncompressed, 57903 bytes compressed:  70.1%
+Zip file size: 70851 bytes, number of entries: 83
+-rw-r--r--  2.0 unx    23472 b- defN 23-Jul-03 17:49 atoti_core/LICENSE
+-rw-r--r--  2.0 unx     2490 b- defN 23-Jul-03 17:39 atoti_core/__init__.py
+-rw-r--r--  2.0 unx     1679 b- defN 23-Jul-03 17:39 atoti_core/_get_endpoint_path.py
+-rw-r--r--  2.0 unx     1565 b- defN 23-Jul-03 17:39 atoti_core/_link.py
+-rw-r--r--  2.0 unx      145 b- defN 23-Jul-03 17:39 atoti_core/_other_identifier.py
+-rw-r--r--  2.0 unx      384 b- defN 23-Jul-03 17:39 atoti_core/_server_versions.py
+-rw-r--r--  2.0 unx     8797 b- defN 23-Jul-03 17:39 atoti_core/activeviam_client.py
+-rw-r--r--  2.0 unx      128 b- defN 23-Jul-03 17:39 atoti_core/arithmetic_operator.py
+-rw-r--r--  2.0 unx     2437 b- defN 23-Jul-03 17:39 atoti_core/base_cube.py
+-rw-r--r--  2.0 unx      561 b- defN 23-Jul-03 17:39 atoti_core/base_cubes.py
+-rw-r--r--  2.0 unx     2273 b- defN 23-Jul-03 17:39 atoti_core/base_hierarchies.py
+-rw-r--r--  2.0 unx     5672 b- defN 23-Jul-03 17:39 atoti_core/base_hierarchy.py
+-rw-r--r--  2.0 unx     4989 b- defN 23-Jul-03 17:39 atoti_core/base_level.py
+-rw-r--r--  2.0 unx     3961 b- defN 23-Jul-03 17:39 atoti_core/base_levels.py
+-rw-r--r--  2.0 unx     2551 b- defN 23-Jul-03 17:39 atoti_core/base_measure.py
+-rw-r--r--  2.0 unx     1365 b- defN 23-Jul-03 17:39 atoti_core/base_measures.py
+-rw-r--r--  2.0 unx    11005 b- defN 23-Jul-03 17:39 atoti_core/base_session.py
+-rw-r--r--  2.0 unx      221 b- defN 23-Jul-03 17:39 atoti_core/boolean_operator.py
+-rw-r--r--  2.0 unx      494 b- defN 23-Jul-03 17:39 atoti_core/column_identifier.py
+-rw-r--r--  2.0 unx     3537 b- defN 23-Jul-03 17:39 atoti_core/combine_conditions.py
+-rw-r--r--  2.0 unx      732 b- defN 23-Jul-03 17:39 atoti_core/comparison_operator.py
+-rw-r--r--  2.0 unx      764 b- defN 23-Jul-03 17:39 atoti_core/condition_to_dict.py
+-rw-r--r--  2.0 unx      913 b- defN 23-Jul-03 17:39 atoti_core/condition_to_pairs.py
+-rw-r--r--  2.0 unx     5240 b- defN 23-Jul-03 17:39 atoti_core/constant.py
+-rw-r--r--  2.0 unx       88 b- defN 23-Jul-03 17:39 atoti_core/context.py
+-rw-r--r--  2.0 unx     3313 b- defN 23-Jul-03 17:39 atoti_core/convert_series.py
+-rw-r--r--  2.0 unx     1720 b- defN 23-Jul-03 17:39 atoti_core/create_dataframe.py
+-rw-r--r--  2.0 unx     3946 b- defN 23-Jul-03 17:39 atoti_core/data_type.py
+-rw-r--r--  2.0 unx     9596 b- defN 23-Jul-03 17:39 atoti_core/decombine_condition.py
+-rw-r--r--  2.0 unx       78 b- defN 23-Jul-03 17:39 atoti_core/default_query_timeout.py
+-rw-r--r--  2.0 unx     3191 b- defN 23-Jul-03 17:39 atoti_core/delegate_mutable_mapping.py
+-rw-r--r--  2.0 unx     1325 b- defN 23-Jul-03 17:39 atoti_core/delegate_mutable_set.py
+-rw-r--r--  2.0 unx      553 b- defN 23-Jul-03 17:39 atoti_core/deprecated.py
+-rw-r--r--  2.0 unx     1900 b- defN 23-Jul-03 17:39 atoti_core/doc.py
+-rw-r--r--  2.0 unx      165 b- defN 23-Jul-03 17:39 atoti_core/empty_mapping.py
+-rw-r--r--  2.0 unx     3471 b- defN 23-Jul-03 17:39 atoti_core/fetch_json.py
+-rw-r--r--  2.0 unx      590 b- defN 23-Jul-03 17:39 atoti_core/find_corresponding_top_level_variable_name.py
+-rw-r--r--  2.0 unx      326 b- defN 23-Jul-03 17:39 atoti_core/get_env_flag.py
+-rw-r--r--  2.0 unx      318 b- defN 23-Jul-03 17:39 atoti_core/get_identifier.py
+-rw-r--r--  2.0 unx     1613 b- defN 23-Jul-03 17:39 atoti_core/get_installed_plugins.py
+-rw-r--r--  2.0 unx     1008 b- defN 23-Jul-03 17:39 atoti_core/get_ipython.py
+-rw-r--r--  2.0 unx     2145 b- defN 23-Jul-03 17:39 atoti_core/get_literal_args.py
+-rw-r--r--  2.0 unx      358 b- defN 23-Jul-03 17:39 atoti_core/get_package_version.py
+-rw-r--r--  2.0 unx      265 b- defN 23-Jul-03 17:39 atoti_core/get_top_level_package_name.py
+-rw-r--r--  2.0 unx      367 b- defN 23-Jul-03 17:39 atoti_core/has_identifier.py
+-rw-r--r--  2.0 unx      642 b- defN 23-Jul-03 17:39 atoti_core/hierarchy_identifier.py
+-rw-r--r--  2.0 unx     3954 b- defN 23-Jul-03 17:39 atoti_core/hierarchy_isin_condition.py
+-rw-r--r--  2.0 unx       69 b- defN 23-Jul-03 17:39 atoti_core/hierarchy_key.py
+-rw-r--r--  2.0 unx      109 b- defN 23-Jul-03 17:39 atoti_core/http_method.py
+-rw-r--r--  2.0 unx      144 b- defN 23-Jul-03 17:39 atoti_core/identifiable.py
+-rw-r--r--  2.0 unx      348 b- defN 23-Jul-03 17:39 atoti_core/identifier.py
+-rw-r--r--  2.0 unx      146 b- defN 23-Jul-03 17:39 atoti_core/identifier_like.py
+-rw-r--r--  2.0 unx      312 b- defN 23-Jul-03 17:39 atoti_core/identify.py
+-rw-r--r--  2.0 unx      886 b- defN 23-Jul-03 17:39 atoti_core/immutable_mapping.py
+-rw-r--r--  2.0 unx      404 b- defN 23-Jul-03 17:39 atoti_core/ipython_key_completions.py
+-rw-r--r--  2.0 unx     3407 b- defN 23-Jul-03 17:39 atoti_core/isin_condition.py
+-rw-r--r--  2.0 unx      109 b- defN 23-Jul-03 17:39 atoti_core/java_max_int.py
+-rw-r--r--  2.0 unx     1055 b- defN 23-Jul-03 17:39 atoti_core/keyword_only_dataclass.py
+-rw-r--r--  2.0 unx      767 b- defN 23-Jul-03 17:39 atoti_core/level_identifier.py
+-rw-r--r--  2.0 unx      102 b- defN 23-Jul-03 17:39 atoti_core/level_key.py
+-rw-r--r--  2.0 unx      637 b- defN 23-Jul-03 17:39 atoti_core/license_key.py
+-rw-r--r--  2.0 unx      777 b- defN 23-Jul-03 17:39 atoti_core/measure_identifier.py
+-rw-r--r--  2.0 unx      295 b- defN 23-Jul-03 17:39 atoti_core/mime_type.py
+-rw-r--r--  2.0 unx      282 b- defN 23-Jul-03 17:39 atoti_core/missing_plugin_error.py
+-rw-r--r--  2.0 unx     9041 b- defN 23-Jul-03 17:39 atoti_core/operand_convertible_with_identifier.py
+-rw-r--r--  2.0 unx    25370 b- defN 23-Jul-03 17:39 atoti_core/operation.py
+-rw-r--r--  2.0 unx      315 b- defN 23-Jul-03 17:39 atoti_core/pandas_nullable_dtype_to_non_nullable_dtype.py
+-rw-r--r--  2.0 unx      180 b- defN 23-Jul-03 17:39 atoti_core/path.py
+-rw-r--r--  2.0 unx      738 b- defN 23-Jul-03 17:39 atoti_core/plugin.py
+-rw-r--r--  2.0 unx      866 b- defN 23-Jul-03 17:39 atoti_core/plugins.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-03 17:39 atoti_core/py.typed
+-rw-r--r--  2.0 unx     9949 b- defN 23-Jul-03 17:39 atoti_core/query_doc.py
+-rw-r--r--  2.0 unx      399 b- defN 23-Jul-03 17:39 atoti_core/query_filter.py
+-rw-r--r--  2.0 unx      785 b- defN 23-Jul-03 17:39 atoti_core/raise_multiple_levels_with_same_name_error.py
+-rw-r--r--  2.0 unx     2270 b- defN 23-Jul-03 17:39 atoti_core/reactive_mutable_set.py
+-rw-r--r--  2.0 unx     2202 b- defN 23-Jul-03 17:39 atoti_core/repr_json.py
+-rw-r--r--  2.0 unx       28 b- defN 23-Jul-03 17:39 atoti_core/scenario.py
+-rw-r--r--  2.0 unx      563 b- defN 23-Jul-03 17:39 atoti_core/str_to_bool.py
+-rw-r--r--  2.0 unx      352 b- defN 23-Jul-03 17:39 atoti_core/table_identifier.py
+-rw-r--r--  2.0 unx      855 b- defN 23-Jul-03 17:49 atoti_core-0.8.2.dist-info/METADATA
+-rw-r--r--  2.0 unx      109 b- defN 23-Jul-03 17:49 atoti_core-0.8.2.dist-info/WHEEL
+-rw-r--r--  2.0 unx       11 b- defN 23-Jul-03 17:49 atoti_core-0.8.2.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     7056 b- defN 23-Jul-03 17:49 atoti_core-0.8.2.dist-info/RECORD
+83 files, 197245 bytes uncompressed, 59659 bytes compressed:  69.8%
```

## zipnote {}

```diff
@@ -3,15 +3,18 @@
 
 Filename: atoti_core/__init__.py
 Comment: 
 
 Filename: atoti_core/_get_endpoint_path.py
 Comment: 
 
-Filename: atoti_core/_other_coordinates.py
+Filename: atoti_core/_link.py
+Comment: 
+
+Filename: atoti_core/_other_identifier.py
 Comment: 
 
 Filename: atoti_core/_server_versions.py
 Comment: 
 
 Filename: atoti_core/activeviam_client.py
 Comment: 
@@ -45,15 +48,15 @@
 
 Filename: atoti_core/base_session.py
 Comment: 
 
 Filename: atoti_core/boolean_operator.py
 Comment: 
 
-Filename: atoti_core/column_coordinates.py
+Filename: atoti_core/column_identifier.py
 Comment: 
 
 Filename: atoti_core/combine_conditions.py
 Comment: 
 
 Filename: atoti_core/comparison_operator.py
 Comment: 
@@ -69,20 +72,14 @@
 
 Filename: atoti_core/context.py
 Comment: 
 
 Filename: atoti_core/convert_series.py
 Comment: 
 
-Filename: atoti_core/coordinates.py
-Comment: 
-
-Filename: atoti_core/coordinates_like.py
-Comment: 
-
 Filename: atoti_core/create_dataframe.py
 Comment: 
 
 Filename: atoti_core/data_type.py
 Comment: 
 
 Filename: atoti_core/decombine_condition.py
@@ -108,18 +105,18 @@
 
 Filename: atoti_core/fetch_json.py
 Comment: 
 
 Filename: atoti_core/find_corresponding_top_level_variable_name.py
 Comment: 
 
-Filename: atoti_core/get_coordinates.py
+Filename: atoti_core/get_env_flag.py
 Comment: 
 
-Filename: atoti_core/get_env_flag.py
+Filename: atoti_core/get_identifier.py
 Comment: 
 
 Filename: atoti_core/get_installed_plugins.py
 Comment: 
 
 Filename: atoti_core/get_ipython.py
 Comment: 
@@ -129,29 +126,41 @@
 
 Filename: atoti_core/get_package_version.py
 Comment: 
 
 Filename: atoti_core/get_top_level_package_name.py
 Comment: 
 
-Filename: atoti_core/has_coordinates.py
+Filename: atoti_core/has_identifier.py
 Comment: 
 
-Filename: atoti_core/hierarchy_coordinates.py
+Filename: atoti_core/hierarchy_identifier.py
 Comment: 
 
 Filename: atoti_core/hierarchy_isin_condition.py
 Comment: 
 
 Filename: atoti_core/hierarchy_key.py
 Comment: 
 
 Filename: atoti_core/http_method.py
 Comment: 
 
+Filename: atoti_core/identifiable.py
+Comment: 
+
+Filename: atoti_core/identifier.py
+Comment: 
+
+Filename: atoti_core/identifier_like.py
+Comment: 
+
+Filename: atoti_core/identify.py
+Comment: 
+
 Filename: atoti_core/immutable_mapping.py
 Comment: 
 
 Filename: atoti_core/ipython_key_completions.py
 Comment: 
 
 Filename: atoti_core/isin_condition.py
@@ -159,30 +168,33 @@
 
 Filename: atoti_core/java_max_int.py
 Comment: 
 
 Filename: atoti_core/keyword_only_dataclass.py
 Comment: 
 
-Filename: atoti_core/level_coordinates.py
+Filename: atoti_core/level_identifier.py
 Comment: 
 
 Filename: atoti_core/level_key.py
 Comment: 
 
 Filename: atoti_core/license_key.py
 Comment: 
 
-Filename: atoti_core/measure_coordinates.py
+Filename: atoti_core/measure_identifier.py
+Comment: 
+
+Filename: atoti_core/mime_type.py
 Comment: 
 
 Filename: atoti_core/missing_plugin_error.py
 Comment: 
 
-Filename: atoti_core/operand_convertible_with_coordinates.py
+Filename: atoti_core/operand_convertible_with_identifier.py
 Comment: 
 
 Filename: atoti_core/operation.py
 Comment: 
 
 Filename: atoti_core/pandas_nullable_dtype_to_non_nullable_dtype.py
 Comment: 
@@ -216,20 +228,23 @@
 
 Filename: atoti_core/scenario.py
 Comment: 
 
 Filename: atoti_core/str_to_bool.py
 Comment: 
 
-Filename: atoti_core-0.8.1.dist-info/METADATA
+Filename: atoti_core/table_identifier.py
+Comment: 
+
+Filename: atoti_core-0.8.2.dist-info/METADATA
 Comment: 
 
-Filename: atoti_core-0.8.1.dist-info/WHEEL
+Filename: atoti_core-0.8.2.dist-info/WHEEL
 Comment: 
 
-Filename: atoti_core-0.8.1.dist-info/top_level.txt
+Filename: atoti_core-0.8.2.dist-info/top_level.txt
 Comment: 
 
-Filename: atoti_core-0.8.1.dist-info/RECORD
+Filename: atoti_core-0.8.2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## atoti_core/LICENSE

```diff
@@ -1,8 +1,8 @@
-This free community end user license agreement ("EULA") is entered into by and between You ("END USER") acting as a legal representative of a business entity ("END CUSTOMER") and Quartet Financial Systems, Inc., d.b.a ActiveViam, a company registered under the laws of the State of Delaware in the United States of America, with office located at 550 7th Avenue, 19th Floor, New York, New York 10018, United States of America ("ActiveViam") and governs the use by End User of Atoti CE version 0.8.1, a tool composed of a set of libraries, extensions such as JupyterLab extension, and its documentation that allows the development of rapid decision-making applications based on a large volume of datasets, developed by ActiveViam (the "SOFTWARE").
+This free community end user license agreement ("EULA") is entered into by and between You ("END USER") acting as a legal representative of a business entity ("END CUSTOMER") and Quartet Financial Systems, Inc., d.b.a ActiveViam, a company registered under the laws of the State of Delaware in the United States of America, with office located at 550 7th Avenue, 19th Floor, New York, New York 10018, United States of America ("ActiveViam") and governs the use by End User of Atoti CE version 0.8.2, a tool composed of a set of libraries, extensions such as JupyterLab extension, and its documentation that allows the development of rapid decision-making applications based on a large volume of datasets, developed by ActiveViam (the "SOFTWARE").
 
 By requesting to have access to the Software, downloading or using the Software, End User acknowledges that he/she and End Customer has understood and agreed with the terms of this EULA.
 If End Customer does not accept these terms, End User must not use the Software.
 
 End Customer and ActiveViam are hereinafter individually or collectively referred to as the "PARTY (IES)".
 
 1. Purpose & description of the Software
```

## atoti_core/__init__.py

```diff
@@ -8,58 +8,59 @@
 from .base_hierarchy import *
 from .base_level import *
 from .base_levels import *
 from .base_measure import *
 from .base_measures import *
 from .base_session import *
 from .boolean_operator import *
-from .column_coordinates import *
+from .column_identifier import *
 from .combine_conditions import *
 from .comparison_operator import *
 from .condition_to_dict import *
 from .condition_to_pairs import *
 from .constant import *
 from .context import *
 from .convert_series import *
-from .coordinates import *
-from .coordinates_like import *
 from .create_dataframe import *
 from .data_type import *
 from .decombine_condition import *
 from .default_query_timeout import *
 from .delegate_mutable_mapping import *
 from .delegate_mutable_set import *
 from .deprecated import *
 from .doc import *
 from .empty_mapping import *
 from .fetch_json import *
 from .find_corresponding_top_level_variable_name import *
-from .get_coordinates import *
 from .get_env_flag import *
 from .get_installed_plugins import *
 from .get_ipython import *
 from .get_literal_args import *
 from .get_package_version import *
 from .get_top_level_package_name import *
-from .has_coordinates import *
-from .hierarchy_coordinates import *
+from .has_identifier import *
+from .hierarchy_identifier import *
 from .hierarchy_isin_condition import *
 from .hierarchy_key import *
 from .http_method import *
+from .identifiable import *
+from .identifier import *
+from .identify import *
 from .immutable_mapping import *
 from .ipython_key_completions import *
 from .isin_condition import *
 from .java_max_int import *
 from .keyword_only_dataclass import *
-from .level_coordinates import *
+from .level_identifier import *
 from .level_key import *
 from .license_key import *
-from .measure_coordinates import *
+from .measure_identifier import *
+from .mime_type import *
 from .missing_plugin_error import *
-from .operand_convertible_with_coordinates import *
+from .operand_convertible_with_identifier import *
 from .operation import *
 from .pandas_nullable_dtype_to_non_nullable_dtype import *
 from .path import *
 from .plugin import *
 
 # To avoid `"get_installed_plugins" is not exported from module "atoti_core.plugins", import from "atoti_core.get_installed_plugins" instead` Pyright error.
 # Revisit when upgrading Pyright.
@@ -67,7 +68,8 @@
 from .query_doc import *
 from .query_filter import *
 from .raise_multiple_levels_with_same_name_error import *
 from .reactive_mutable_set import *
 from .repr_json import *
 from .scenario import *
 from .str_to_bool import *
+from .table_identifier import *
```

## atoti_core/_server_versions.py

```diff
@@ -1,13 +1,13 @@
 from collections.abc import Mapping, Sequence
 from typing import TypedDict
 
 
 class _ApiVersion(TypedDict):
-    id: str  # noqa: A003
+    id: str
     restPath: str
 
 
 class ApiVersion(_ApiVersion, TypedDict, total=False):
     wsPath: str
```

## atoti_core/activeviam_client.py

```diff
@@ -37,15 +37,15 @@
 from .fetch_json import JSON_CONTENT_TYPE, JsonResponse, fetch_json
 from .http_method import HttpMethod
 from .path import local_to_absolute_path
 
 
 class _ErrorChainItem(TypedDict):
     message: str
-    type: str  # noqa: A003
+    type: str
 
 
 class _CurrentActiveViamJsonHttpErrorBody(TypedDict):
     errorChain: Sequence[_ErrorChainItem]
     stackTrace: str
```

## atoti_core/base_hierarchies.py

```diff
@@ -1,15 +1,15 @@
 from __future__ import annotations
 
 from abc import abstractmethod
 from collections.abc import Iterable, Mapping
 from typing import Optional, TypeVar, Union
 
 from .base_hierarchy import BaseHierarchyBound
-from .hierarchy_coordinates import HierarchyCoordinates
+from .hierarchy_identifier import HierarchyIdentifier
 from .hierarchy_key import HierarchyKey
 from .repr_json import ReprJson, ReprJsonable
 
 HierarchyT = TypeVar("HierarchyT", bound=BaseHierarchyBound, covariant=True)
 
 
 class BaseHierarchies(Mapping[tuple[str, str], HierarchyT], ReprJsonable):
@@ -44,18 +44,18 @@
             return (None, key)
 
         return key
 
     @staticmethod
     def _multiple_hierarchies_error(
         key: HierarchyKey,
-        hierarchies: Union[Iterable[HierarchyT], Iterable[HierarchyCoordinates]],
+        hierarchies: Union[Iterable[HierarchyT], Iterable[HierarchyIdentifier]],
     ) -> KeyError:
         return KeyError(
             f"""Multiple hierarchies with name {key}. Specify the dimension: {", ".join([
-            f'cube.hierarchies["{hierarchy.dimension_name}", "{hierarchy.dimension_name}"]'if isinstance(hierarchy, HierarchyCoordinates) else f'cube.hierarchies["{hierarchy.dimension}", "{hierarchy.name}"]'
+            f'cube.hierarchies["{hierarchy.dimension_name}", "{hierarchy.dimension_name}"]'if isinstance(hierarchy, HierarchyIdentifier) else f'cube.hierarchies["{hierarchy.dimension}", "{hierarchy.name}"]'
             for hierarchy in hierarchies
         ])}"""
         )
 
 
 BaseHierarchiesBound = BaseHierarchies[BaseHierarchyBound]
```

## atoti_core/base_hierarchy.py

```diff
@@ -2,45 +2,42 @@
 
 from abc import abstractmethod
 from collections.abc import Mapping
 from typing import Generic, Literal, TypeVar
 
 from .base_level import BaseLevel
 from .constant import Constant, ConstantValue
-from .has_coordinates import HasCoordinates
-from .hierarchy_coordinates import HierarchyCoordinates
+from .has_identifier import HasIdentifier
+from .hierarchy_identifier import HierarchyIdentifier
 from .hierarchy_isin_condition import HierarchyIsinCondition
 from .operation import Condition
 from .repr_json import ReprJson, ReprJsonable
 
 LevelT = TypeVar("LevelT", bound=BaseLevel, covariant=True)
 
 
-class BaseHierarchy(
-    Generic[LevelT], HasCoordinates[HierarchyCoordinates], ReprJsonable
-):
-    def __init__(self, name: str, /, *, dimension: str) -> None:
+class BaseHierarchy(Generic[LevelT], HasIdentifier[HierarchyIdentifier], ReprJsonable):
+    def __init__(self, identifier: HierarchyIdentifier, /) -> None:
         super().__init__()
 
-        self._name = name
-        self._dimension = dimension
+        self.__identifier = identifier
 
     @property
     def name(self) -> str:
         """Name of the hierarchy."""
-        return self._name
+        return self._identifier.hierarchy_name
 
     @property
-    @abstractmethod
     def dimension(self) -> str:
         """Name of the dimension of the hierarchy.
 
         A dimension is a logical group of attributes (e.g. :guilabel:`Geography`).
         It can be thought of as a folder containing hierarchies.
         """
+        return self._identifier.dimension_name
 
     @property
     @abstractmethod
     def levels(self) -> Mapping[str, LevelT]:
         """Levels of the hierarchy."""
 
     @property
@@ -55,15 +52,15 @@
         * A slicing hierarchy is not aggregable at the top level, meaning that it does not make sense to aggregate data across all members of the hierarchy.
 
           For instance, for an :guilabel:`As of date` hierarchy giving the current bank account :guilabel:`Balance` for a given date, it does not provide any meaningful information to aggregate the :guilabel:`Balance` across all the dates.
         """
 
     def isin(
         self, *member_paths: tuple[ConstantValue, ...]
-    ) -> Condition[HierarchyCoordinates, Literal["isin"], Constant, None]:
+    ) -> Condition[HierarchyIdentifier, Literal["isin"], Constant, None]:
         """Return a condition to check that the hierarchy is on one of the given members.
 
         Considering ``hierarchy_1`` containing ``level_1`` and ``level_2``, ``hierarchy_1.isin((a,), (b, c))`` is equivalent to ``(level_1 == a) | ((level_1 == b) & (level_2 == c))``.
 
         Args:
             member_paths: One or more member paths expressed as tuples on which the hierarchy should be.
                 Each element in a tuple corresponds to a level of the hierarchy, from the shallowest to the deepest.
@@ -107,15 +104,15 @@
             .. doctest:: Hierarchy.isin
                 :hide:
 
                 Clear the session to isolate the multiple methods sharing this docstring.
                 >>> session._clear()
         """
         return HierarchyIsinCondition(
-            subject=self._coordinates,
+            subject=self._identifier,
             level_names=(*self.levels,),
             member_paths=tuple(
                 tuple(Constant(member) for member in member_path)
                 for member_path in member_paths
             ),
         )
 
@@ -127,16 +124,16 @@
             {
                 "root": root,
                 "expanded": False,
             },
         )
 
     @property
-    def _coordinates(self) -> HierarchyCoordinates:
-        return HierarchyCoordinates(self.dimension, self.name)
+    def _identifier(self) -> HierarchyIdentifier:
+        return self.__identifier
 
     def __hash__(self) -> int:
         # See comment in `OperandConvertible.__hash__()`.
         return id(self)
 
 
 BaseHierarchyBound = BaseHierarchy[BaseLevel]
```

## atoti_core/base_level.py

```diff
@@ -1,55 +1,55 @@
 from __future__ import annotations
 
 from abc import abstractmethod
 from typing import Literal
 
 from .constant import Constant, ConstantValue
 from .isin_condition import IsinCondition
-from .level_coordinates import LevelCoordinates
-from .operand_convertible_with_coordinates import OperandConvertibleWithCoordinates
+from .level_identifier import LevelIdentifier
+from .operand_convertible_with_identifier import OperandConvertibleWithIdentifier
 from .operation import ComparisonCondition, Condition
 from .repr_json import ReprJson, ReprJsonable
 
 
 class BaseLevel(
-    OperandConvertibleWithCoordinates[LevelCoordinates],
+    OperandConvertibleWithIdentifier[LevelIdentifier],
     ReprJsonable,
 ):
-    def __init__(self, name: str, /) -> None:
+    def __init__(self, identifier: LevelIdentifier, /) -> None:
         super().__init__()
 
-        self._name = name
+        self.__identifier = identifier
 
     @property
     def name(self) -> str:
         """Name of the level."""
-        return self._name
+        return self._identifier.level_name
 
     @property
-    @abstractmethod
     def dimension(self) -> str:
         """Name of the dimension holding the level."""
+        return self._identifier.hierarchy_identifier.dimension_name
 
     @property
-    @abstractmethod
     def hierarchy(self) -> str:
         """Name of the hierarchy holding the level."""
+        return self._identifier.hierarchy_identifier.hierarchy_name
 
     @property
-    def _coordinates(self) -> LevelCoordinates:
-        return LevelCoordinates(self.dimension, self.hierarchy, self._name)
+    def _identifier(self) -> LevelIdentifier:
+        return self.__identifier
 
     @property
-    def _operation_operand(self) -> LevelCoordinates:
-        return self._coordinates
+    def _operation_operand(self) -> LevelIdentifier:
+        return self._identifier
 
     def isin(
         self, *members: ConstantValue
-    ) -> Condition[LevelCoordinates, Literal["isin"], Constant, None]:
+    ) -> Condition[LevelIdentifier, Literal["isin"], Constant, None]:
         """Return a condition to check that the level is on one of the given members.
 
         ``level.isin(a, b)`` is equivalent to ``(level == a) | (level == b)``.
 
         Args:
             members: One or more members on which the level should be.
 
@@ -95,15 +95,15 @@
         return IsinCondition(
             subject=self._operation_operand,
             elements=tuple(Constant(member) for member in members),
         )
 
     def isnull(
         self,
-    ) -> Condition[LevelCoordinates, Literal["eq"], None, None]:
+    ) -> Condition[LevelIdentifier, Literal["eq"], None, None]:
         """Return a condition evaluating to ``True`` when a level is not expressed in a query and ``False`` otherwise.
 
         Use `~level.isnull()` for the opposite behavior.
 
         Example:
             >>> df = pd.DataFrame(
             ...     columns=["Country", "City", "Price"],
```

## atoti_core/base_measure.py

```diff
@@ -1,25 +1,25 @@
 from abc import abstractmethod
 from typing import Literal, Optional
 
-from .measure_coordinates import MeasureCoordinates
-from .operand_convertible_with_coordinates import OperandConvertibleWithCoordinates
+from .measure_identifier import MeasureIdentifier
+from .operand_convertible_with_identifier import OperandConvertibleWithIdentifier
 from .operation import ComparisonCondition, Condition
 
 
-class BaseMeasure(OperandConvertibleWithCoordinates[MeasureCoordinates]):
-    def __init__(self, name: str, /) -> None:
+class BaseMeasure(OperandConvertibleWithIdentifier[MeasureIdentifier]):
+    def __init__(self, identifier: MeasureIdentifier, /) -> None:
         super().__init__()
 
-        self._name = name
+        self.__identifier = identifier
 
     @property
     def name(self) -> str:
         """Name of the measure."""
-        return self._name
+        return self._identifier.measure_name
 
     @property
     @abstractmethod
     def folder(self) -> Optional[str]:
         """Folder of the measure."""
 
     @property
@@ -33,15 +33,15 @@
         """Description of the measure."""
 
     @property
     @abstractmethod
     def formatter(self) -> Optional[str]:
         """Formatter of the measure."""
 
-    def isnull(self) -> Condition[MeasureCoordinates, Literal["eq"], None, None]:
+    def isnull(self) -> Condition[MeasureIdentifier, Literal["eq"], None, None]:
         """Return a condition evaluating to ``True`` if the measure evalutes to ``None`` and ``False`` otherwise.
 
         Use ``~measure.isnull()`` for the opposite behavior.
 
         Example:
             >>> df = pd.DataFrame(
             ...     columns=["Country", "City", "Price"],
@@ -67,13 +67,13 @@
 
         """
         return ComparisonCondition(
             subject=self._operation_operand, operator="eq", target=None
         )
 
     @property
-    def _coordinates(self) -> MeasureCoordinates:
-        return MeasureCoordinates(self.name)
+    def _identifier(self) -> MeasureIdentifier:
+        return self.__identifier
 
     @property
-    def _operation_operand(self) -> MeasureCoordinates:
-        return self._coordinates
+    def _operation_operand(self) -> MeasureIdentifier:
+        return self._identifier
```

## atoti_core/base_session.py

```diff
@@ -6,14 +6,15 @@
 from collections.abc import Mapping
 from datetime import timedelta
 from time import time
 from typing import Any, Generic, Literal, Optional, TypeVar, cast
 
 import pandas as pd
 
+from ._link import Link
 from .activeviam_client import ActiveViamClient
 from .base_cubes import BaseCubesBound
 from .context import Context
 from .default_query_timeout import DEFAULT_QUERY_TIMEOUT
 from .doc import doc
 from .empty_mapping import EMPTY_MAPPING
 from .find_corresponding_top_level_variable_name import (
@@ -37,74 +38,67 @@
 
 class BaseSession(Generic[CubesT, _SecurityT], ReprJsonable):
     """Base class for session."""
 
     def __init__(self) -> None:
         self.__id = _generate_session_id()
 
-        def link(
-            session: BaseSessionBound,  # noqa: ARG001
-            /,
-            *,
-            path: str,  # noqa: ARG001
-        ) -> object:
-            raise MissingPluginError("jupyterlab3")
-
         def visualize(
             session: BaseSessionBound,  # noqa: ARG001
             /,
             *,
             name: Optional[str] = None,  # noqa: ARG001
         ) -> None:
             raise MissingPluginError("jupyterlab3")
 
-        self._link = link
         self._visualize = visualize
 
     @property
     @abstractmethod
     def _client(self) -> ActiveViamClient:
         ...
 
     @property
     @abstractmethod
-    def _location(self) -> Mapping[str, Any]:
+    def _location(self) -> Mapping[str, object]:
         """Location data used to create a link to this session."""
 
     def link(
         self,
         *,
         path: str = "",
     ) -> object:
         """Display a link to this session.
 
-        Clicking on the link will open it in a new browser tab.
+        If the :mod:`atoti-jupyterlab3 <atoti_jupyterlab3>` plugin is:
 
-        Note:
-            This method requires the :mod:`atoti-jupyterlab3 <atoti_jupyterlab3>` plugin.
-
-        The extension will try to access the session through (in that order):
+        * not enabled, the session's local URL will be used so the link may not be reachable if Atoti is running on a remote machine.
+          In that situation, the session may be reached from ``f{public_ip_or_domain_of_machine_hosting_atoti}:{session.port}`` (see :meth:`atoti.Session.port`).
+        * enabled, the JupyterLab extension will try to access the session through (in this order):
 
-        #. `Jupyter Server Proxy <https://jupyter-server-proxy.readthedocs.io/>`__ if it is enabled.
-        #. ``f"{session_protocol}//{jupyter_server_hostname}:{session.port}"`` for :class:`atoti.Session` and ``session.url`` for :class:`atoti_query.QuerySession`.
+            #. `Jupyter Server Proxy <https://jupyter-server-proxy.readthedocs.io/>`__ if it is enabled.
+            #. ``f"{session_protocol}//{jupyter_server_hostname}:{session.port}"`` for :class:`~atoti.Session` and ``session.url`` for :class:`~atoti_query.QuerySession`.
 
         Args:
             path: The path to append to the session base URL.
                 Defaults to the session home page.
 
         Example:
-            Pointing directly to an existing dashboard:
+            Linking to an existing dashboard:
 
             .. testcode::
 
                 dashboard_id = "92i"
                 session.link(path=f"#/dashboard/{dashboard_id}")
-
         """
-        return self._link(self, path=path)
+        return Link(
+            path=path,
+            session_local_url=self._local_url,
+            session_location=self._location,
+        )
 
     @property
     @abstractmethod
     def cubes(self) -> CubesT:
         """Cubes of the session."""
 
     @property
@@ -116,15 +110,15 @@
     @abstractmethod
     def _local_url(self) -> str:
         """URL that can be used to access the session on the host machine's network."""
 
     def visualize(
         self,
         name: Optional[str] = None,
-    ) -> None:
+    ) -> object:
         """Display an Atoti widget to explore the session interactively.
 
         Note:
             This method requires the :mod:`atoti-jupyterlab3 <atoti_jupyterlab3>` plugin.
 
         The widget state will be stored in the cell metadata.
         This state should not have to be edited but, if desired, it can be found in JupyterLab by opening the "Notebook tools" sidebar and expanding the "Advanced Tools" section.
```

## atoti_core/condition_to_dict.py

```diff
@@ -1,28 +1,28 @@
 from typing import Literal, Optional
 
 from .condition_to_pairs import condition_to_pairs
-from .has_coordinates import CoordinatesT
+from .has_identifier import IdentifierT
 from .operation import Condition, ConditionTargetT
 
 
 def condition_to_dict(
     condition: Condition[
-        CoordinatesT,
+        IdentifierT,
         Literal["eq"],
         ConditionTargetT,
         Optional[Literal["and"]],
     ],
     /,
-) -> dict[CoordinatesT, ConditionTargetT]:
+) -> dict[IdentifierT, ConditionTargetT]:
     pairs = condition_to_pairs(condition)
-    result: dict[CoordinatesT, ConditionTargetT] = {}
+    result: dict[IdentifierT, ConditionTargetT] = {}
 
-    for coordinates, target in pairs:
-        if coordinates in result:
+    for identifier, target in pairs:
+        if identifier in result:
             raise ValueError(
-                f"Expected the combined condition to have distinct subjects but got `{coordinates}` twice."
+                f"Expected the combined condition to have distinct subjects but got `{identifier}` twice."
             )
 
-        result[coordinates] = target
+        result[identifier] = target
 
     return result
```

## atoti_core/decombine_condition.py

```diff
@@ -1,15 +1,15 @@
 from itertools import chain, product
 from typing import TypeVar, cast
 
 from .boolean_operator import ALL_BOOLEAN_OPERATORS, BooleanOperator
 from .comparison_operator import ALL_COMPARISON_OPERATORS, ComparisonOperator
 from .constant import Constant
-from .coordinates import Coordinates
 from .hierarchy_isin_condition import HierarchyIsinCondition
+from .identifier import Identifier
 from .isin_condition import IsinCondition, IsinConditionElementT
 from .operation import (
     CombinedCondition,
     ComparisonCondition,
     ConditionBound,
     ConditionSubjectBound,
     ConditionSubjectT,
@@ -47,30 +47,30 @@
     /,
     *,
     allowed_subject_types: tuple[
         type[ConditionSubjectT],
         ...
         # Pyright is able to check the default value's type but mypy cannot.
     ] = (  # type: ignore[assignment]
-        Coordinates,
+        Identifier,
         Operation,
     ),
     allowed_comparison_operators: tuple[
         _ComparisonOperatorT,
         ...
         # Pyright is able to check the default value's type but mypy cannot.
     ] = ALL_COMPARISON_OPERATORS,  # type: ignore[assignment]
     allowed_target_types: tuple[
         type[ConditionTargetT],
         ...
         # Pyright is able to check the default value's type but mypy cannot.
     ] = (  # type: ignore[assignment]
         _NONE_TYPE,
         Constant,
-        Coordinates,
+        Identifier,
         Operation,
     ),
     allowed_combination_operators: tuple[
         _CombinationOperatorT,
         ...
         # Pyright is able to check the default value's type but mypy cannot.
     ] = ALL_BOOLEAN_OPERATORS,  # type: ignore[assignment]
```

## atoti_core/doc.py

```diff
@@ -46,12 +46,12 @@
                 arg.format(**kwargs)
                 if isinstance(arg, str)
                 else dedent(arg.__doc__ or "")
                 for arg in docstring_components
             ]
         )
 
-        wrapper._docstring_components = docstring_components  # type: ignore[attr-defined] # pyright: ignore[reportFunctionMemberAccess]
+        wrapper._docstring_components = docstring_components  # type: ignore[attr-defined] # pyright: ignore[reportGeneralTypeIssues]
 
         return wrapper
 
     return decorator
```

## atoti_core/fetch_json.py

```diff
@@ -31,15 +31,15 @@
 
 
 @overload
 def fetch_json(
     url: str,
     /,
     *,
-    body: _Json = ...,
+    body: Optional[_Json] = ...,
     headers: Mapping[str, str] = ...,
     json_dump_default: Optional[_JsonDumpDefault] = ...,
     method: Optional[HttpMethod] = ...,
     opener_director: Optional[OpenerDirector] = ...,
     timeout: Optional[timedelta] = ...,
     raw: Literal[True],
 ) -> HTTPResponse:
@@ -47,15 +47,15 @@
 
 
 @overload
 def fetch_json(
     url: str,
     /,
     *,
-    body: _Json = ...,
+    body: Optional[_Json] = ...,
     headers: Mapping[str, str] = ...,
     json_dump_default: Optional[_JsonDumpDefault] = ...,
     method: Optional[HttpMethod] = ...,
     opener_director: Optional[OpenerDirector] = ...,
     timeout: Optional[timedelta] = ...,
     raw: Literal[False] = ...,
 ) -> JsonResponse:
@@ -63,30 +63,30 @@
 
 
 @overload
 def fetch_json(
     url: str,
     /,
     *,
-    body: _Json = ...,
+    body: Optional[_Json] = ...,
     headers: Mapping[str, str] = ...,
     json_dump_default: Optional[_JsonDumpDefault] = ...,
     method: Optional[HttpMethod] = ...,
     opener_director: Optional[OpenerDirector] = ...,
     timeout: Optional[timedelta] = ...,
     raw: bool = ...,
 ) -> Union[JsonResponse, HTTPResponse]:
     ...
 
 
 def fetch_json(
     url: str,
     /,
     *,
-    body: _Json = None,
+    body: Optional[_Json] = None,
     headers: Mapping[str, str] = EMPTY_MAPPING,
     json_dump_default: Optional[_JsonDumpDefault] = None,
     method: Optional[HttpMethod] = None,
     opener_director: Optional[OpenerDirector] = None,
     timeout: Optional[timedelta] = None,
     raw: bool = False,
 ) -> Union[JsonResponse, HTTPResponse]:
```

## atoti_core/hierarchy_isin_condition.py

```diff
@@ -1,32 +1,32 @@
 from collections.abc import Iterable
 from dataclasses import dataclass
 from functools import cached_property
 from typing import Literal, NoReturn, Optional, Union
 
 from .combine_conditions import combine_conditions
 from .constant import Constant
-from .coordinates import Coordinates
-from .hierarchy_coordinates import HierarchyCoordinates
-from .level_coordinates import LevelCoordinates
+from .hierarchy_identifier import HierarchyIdentifier
+from .identifier import Identifier
+from .level_identifier import LevelIdentifier
 from .operation import ComparisonCondition, Condition, ConditionCombinationOperatorBound
 
 
 @dataclass(frozen=True)
 class HierarchyIsinCondition(
-    Condition[HierarchyCoordinates, Literal["isin"], Constant, None]
+    Condition[HierarchyIdentifier, Literal["isin"], Constant, None]
 ):
-    subject: HierarchyCoordinates
+    subject: HierarchyIdentifier
     level_names: tuple[str, ...]
     _member_paths: frozenset[tuple[Constant, ...]]
 
     def __init__(
         self,
         *,
-        subject: HierarchyCoordinates,
+        subject: HierarchyIdentifier,
         level_names: tuple[str, ...],
         member_paths: Iterable[tuple[Constant, ...]],
     ) -> None:
         if not member_paths:
             raise ValueError(
                 "No passed member paths, the condition will always evaluate to `False`."
             )
@@ -51,67 +51,59 @@
         # The member paths are sorted to ensure predictability.
         return tuple(sorted(self._member_paths))
 
     @cached_property
     def normalized(
         self,
     ) -> Condition[
-        Union[HierarchyCoordinates, LevelCoordinates],
+        Union[HierarchyIdentifier, LevelIdentifier],
         Literal["eq", "isin"],
         Constant,
         Optional[Literal["and"]],
     ]:
         if len(self.member_paths) != 1:
             return self
 
         return combine_conditions(
             (
                 [
                     ComparisonCondition(
-                        subject=LevelCoordinates(
-                            self.subject.dimension_name,
-                            self.subject.hierarchy_name,
-                            level_name,
-                        ),
+                        subject=LevelIdentifier(self.subject, level_name),
                         operator="eq",
                         target=member,
                     )
                     for level_name, member in zip(
                         self.level_names, next(iter(self.member_paths))
                     )
                 ],
             )
         )
 
     @property
     def combined_comparison_condition(
         self,
     ) -> Condition[
-        LevelCoordinates, Literal["eq"], Constant, ConditionCombinationOperatorBound
+        LevelIdentifier, Literal["eq"], Constant, ConditionCombinationOperatorBound
     ]:
         return combine_conditions(
             [
                 [
                     ComparisonCondition(
-                        subject=LevelCoordinates(
-                            self.subject.dimension_name,
-                            self.subject.hierarchy_name,
-                            level_name,
-                        ),
+                        subject=LevelIdentifier(self.subject, level_name),
                         operator="eq",
                         target=member,
                     )
                     for level_name, member in zip(self.level_names, member_path)
                 ]
                 for member_path in self.member_paths
             ]
         )
 
     @property
-    def _coordinates_classes(self) -> frozenset[type[Coordinates]]:
+    def _identifier_types(self) -> frozenset[type[Identifier]]:
         return frozenset([type(self.subject)])
 
     def __invert__(
         self,
     ) -> NoReturn:
         raise RuntimeError(f"A `{type(self).__name__}` cannot be inverted.")
         # It can actually be done using `~hierarchy_isin_condition.combined_comparison_condition` but this changes the type of `subject` which breaks the contract of `Condition.__invert__()`.
```

## atoti_core/isin_condition.py

```diff
@@ -1,16 +1,16 @@
 from collections.abc import Iterable
 from dataclasses import dataclass
 from functools import cached_property
 from typing import Literal, Optional, TypeVar
 
 from .combine_conditions import combine_conditions
 from .constant import Constant
-from .coordinates import Coordinates
-from .hierarchy_coordinates import HierarchyCoordinates
+from .hierarchy_identifier import HierarchyIdentifier
+from .identifier import Identifier
 from .operation import (
     ComparisonCondition,
     Condition,
     ConditionCombinationOperatorBound,
     ConditionComparisonOperatorBound,
     ConditionSubjectT,
 )
@@ -27,15 +27,15 @@
     subject: ConditionSubjectT
     _elements: frozenset[IsinConditionElementT]
 
     def __init__(
         self, *, subject: ConditionSubjectT, elements: Iterable[IsinConditionElementT]
     ) -> None:
         assert not isinstance(
-            subject, HierarchyCoordinates
+            subject, HierarchyIdentifier
         ), "Conditions on hierarchies must use `HierarchyIsinCondition`."
 
         if not elements:
             raise ValueError(
                 "No passed elements, the condition will always evaluate to `False`."
             )
 
@@ -80,16 +80,16 @@
                     ),
                 )
                 for element in self.elements
             ]
         )
 
     @property
-    def _coordinates_classes(self) -> frozenset[type[Coordinates]]:
-        return self._get_coordinates_classes(self.subject)
+    def _identifier_types(self) -> frozenset[type[Identifier]]:
+        return self._get_identifier_types(self.subject)
 
     def __invert__(
         self,
     ) -> Condition[
         ConditionSubjectT,
         ConditionComparisonOperatorBound,
         IsinConditionElementT,
@@ -97,8 +97,8 @@
     ]:
         return ~self.combined_comparison_condition
 
     def __repr__(self) -> str:
         return f"{self.subject!r}.isin{tuple(element.value if isinstance(element, Constant) else element for element in self.elements)!r}"
 
 
-IsinConditionBound = IsinCondition[Coordinates, Optional[Constant]]
+IsinConditionBound = IsinCondition[Identifier, Optional[Constant]]
```

## atoti_core/keyword_only_dataclass.py

```diff
@@ -16,13 +16,13 @@
     @wraps(init)
     def init_enforcing_keyword_only_arguments(
         self: _T, *args: Any, **kwargs: Any
     ) -> None:
         assert (
             len(args) == 0
         ), f"{cls.__name__} expects keyword-only arguments but the following positional arguments were passed: {args}."
-        init(self, **kwargs)
+        init(self, **kwargs)  # pyright: ignore[reportGeneralTypeIssues]
 
     setattr(cls, "__init__", init_enforcing_keyword_only_arguments)  # noqa: B010
 
     # Mypy reports `got "Type[DataclassInstance]", expected "Type[_T]"`.
     return cls  # type: ignore[return-value]
```

## atoti_core/operation.py

```diff
@@ -11,82 +11,82 @@
     NoReturn,
     Optional,
     TypeVar,
     Union,
     overload,
 )
 
-from ._other_coordinates import OtherCoordinatesT
+from ._other_identifier import OtherIdentifierT
 from .arithmetic_operator import ArithmeticOperator
 from .boolean_operator import BooleanOperator
 from .comparison_operator import OPERATOR_TO_INVERSE_OPERATOR, ComparisonOperator
 from .constant import Constant, ConstantValue
-from .coordinates import Coordinates
 from .data_type import DataType
-from .has_coordinates import CoordinatesT, HasCoordinates
-from .hierarchy_coordinates import HierarchyCoordinates
+from .has_identifier import HasIdentifier, IdentifierT
+from .hierarchy_identifier import HierarchyIdentifier
+from .identifier import Identifier
 from .keyword_only_dataclass import keyword_only_dataclass
 
 
 @overload
 def convert_to_operand(value: None, /) -> None:
     ...
 
 
 @overload
 def convert_to_operand(value: ConstantValue, /) -> Constant:
     ...
 
 
 @overload
-def convert_to_operand(value: HasCoordinates[CoordinatesT], /) -> CoordinatesT:
+def convert_to_operand(value: HasIdentifier[IdentifierT], /) -> IdentifierT:
     ...
 
 
 @overload
 def convert_to_operand(
-    value: OperandCondition[CoordinatesT],
+    value: OperandCondition[IdentifierT],
     /,
-) -> OperandCondition[CoordinatesT]:
+) -> OperandCondition[IdentifierT]:
     ...
 
 
 @overload
-def convert_to_operand(value: Operation[CoordinatesT], /) -> Operation[CoordinatesT]:
+def convert_to_operand(value: Operation[IdentifierT], /) -> Operation[IdentifierT]:
     ...
 
 
 def convert_to_operand(
     value: Optional[
         Union[
-            OperandCondition[CoordinatesT],
+            OperandCondition[IdentifierT],
             ConstantValue,
-            HasCoordinates[CoordinatesT],
-            Operation[CoordinatesT],
+            HasIdentifier[IdentifierT],
+            Operation[IdentifierT],
         ]
     ],
     /,
-) -> Optional[Operand[CoordinatesT]]:
+) -> Optional[Operand[IdentifierT]]:
     if value is None or isinstance(value, (Condition, Operation)):
         return value
-    if isinstance(value, HasCoordinates):
-        return value._coordinates
+    if isinstance(value, HasIdentifier):
+        return value._identifier
     return Constant(value)
 
 
-class OperandConvertible(Generic[CoordinatesT], ABC):
+class OperandConvertible(Generic[IdentifierT], ABC):
     @property
     @abstractmethod
-    def _operation_operand(self) -> NonConstantNonConditionOperand[CoordinatesT]:
+    def _operation_operand(self) -> NonConstantNonConditionOperand[IdentifierT]:
         ...
 
     def isnull(
         self,
     ) -> Condition[
-        NonConstantNonConditionOperand[CoordinatesT], Literal["eq"], None, None
+        NonConstantNonConditionOperand[IdentifierT], Literal["eq"], None, None
     ]:
         """Return a condition evaluating to ``True`` when the element evaluates to ``None`` and ``False`` otherwise.
 
         Use `~obj.isnull()` for the opposite behavior.
         """
         return ComparisonCondition(
             subject=self._operation_operand,
@@ -107,417 +107,417 @@
 
     def __getitem__(
         self,
         index: Union[
             slice,
             int,
             tuple[int, ...],
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
-    ) -> Operation[Union[CoordinatesT, OtherCoordinatesT]]:
+    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
         return IndexingOperation(
             operand=self._operation_operand,
-            index=index._coordinates
-            if isinstance(index, HasCoordinates)
+            index=index._identifier
+            if isinstance(index, HasIdentifier)
             else (
                 index
                 if isinstance(index, (slice, Operation))
                 else Constant(list(index) if isinstance(index, tuple) else index)
             ),
         )
 
     # The signature is not compatible with `object.__eq__()` on purpose.
     def __eq__(  # type: ignore[override] # pyright: ignore[reportIncompatibleMethodOverride]
         self,
         other: Union[
             ConstantValue,
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
     ) -> Condition[
-        NonConstantNonConditionOperand[CoordinatesT],
+        NonConstantNonConditionOperand[IdentifierT],
         Literal["eq"],
-        Union[Constant, OtherCoordinatesT, Operation[OtherCoordinatesT]],
+        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
         None,
     ]:
         assert other is not None, "Use `isnull()` instead."
         return ComparisonCondition(
             subject=self._operation_operand,
             target=convert_to_operand(other),
             operator="eq",
         )
 
     def __ge__(
         self,
         other: Union[
             ConstantValue,
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
     ) -> Condition[
-        NonConstantNonConditionOperand[CoordinatesT],
+        NonConstantNonConditionOperand[IdentifierT],
         Literal["ge"],
-        Union[Constant, OtherCoordinatesT, Operation[OtherCoordinatesT]],
+        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
         None,
     ]:
         return ComparisonCondition(
             subject=self._operation_operand,
             operator="ge",
             target=convert_to_operand(other),
         )
 
     def __gt__(
         self,
         other: Union[
             ConstantValue,
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
     ) -> Condition[
-        NonConstantNonConditionOperand[CoordinatesT],
+        NonConstantNonConditionOperand[IdentifierT],
         Literal["gt"],
-        Union[Constant, OtherCoordinatesT, Operation[OtherCoordinatesT]],
+        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
         None,
     ]:
         return ComparisonCondition(
             subject=self._operation_operand,
             operator="gt",
             target=convert_to_operand(other),
         )
 
     def __le__(
         self,
         other: Union[
             ConstantValue,
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
     ) -> Condition[
-        NonConstantNonConditionOperand[CoordinatesT],
+        NonConstantNonConditionOperand[IdentifierT],
         Literal["le"],
-        Union[Constant, OtherCoordinatesT, Operation[OtherCoordinatesT]],
+        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
         None,
     ]:
         return ComparisonCondition(
             subject=self._operation_operand,
             operator="le",
             target=convert_to_operand(other),
         )
 
     def __lt__(
         self,
         other: Union[
             ConstantValue,
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
     ) -> Condition[
-        NonConstantNonConditionOperand[CoordinatesT],
+        NonConstantNonConditionOperand[IdentifierT],
         Literal["lt"],
-        Union[Constant, OtherCoordinatesT, Operation[OtherCoordinatesT]],
+        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
         None,
     ]:
         return ComparisonCondition(
             subject=self._operation_operand,
             operator="lt",
             target=convert_to_operand(other),
         )
 
     # The signature is not compatible with `object.__ne__()` on purpose.
     def __ne__(  # type: ignore[override] # pyright: ignore[reportIncompatibleMethodOverride]
         self,
         other: Union[
             ConstantValue,
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
     ) -> Condition[
-        NonConstantNonConditionOperand[CoordinatesT],
+        NonConstantNonConditionOperand[IdentifierT],
         Literal["ne"],
-        Union[Constant, OtherCoordinatesT, Operation[OtherCoordinatesT]],
+        Union[Constant, OtherIdentifierT, Operation[OtherIdentifierT]],
         None,
     ]:
         assert other is not None, "Use `~isnull()` instead."
         return ComparisonCondition(
             subject=self._operation_operand,
             operator="ne",
             target=convert_to_operand(other),
         )
 
     def __add__(
         self,
         other: Union[
             ConstantValue,
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
-    ) -> Operation[Union[CoordinatesT, OtherCoordinatesT]]:
+    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
         return ArithmeticOperation(
             operands=(self._operation_operand, convert_to_operand(other)),
             operator="add",
         )
 
     def __radd__(
         self,
         other: Union[
             ConstantValue,
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
-    ) -> Operation[Union[CoordinatesT, OtherCoordinatesT]]:
+    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
         return ArithmeticOperation(
             operands=(convert_to_operand(other), self._operation_operand),
             operator="add",
         )
 
     def __floordiv__(
         self,
         other: Union[
             ConstantValue,
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
-    ) -> Operation[Union[CoordinatesT, OtherCoordinatesT]]:
+    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
         return ArithmeticOperation(
             operands=(self._operation_operand, convert_to_operand(other)),
             operator="floordiv",
         )
 
     def __rfloordiv__(
         self,
         other: Union[
             ConstantValue,
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
-    ) -> Operation[Union[CoordinatesT, OtherCoordinatesT]]:
+    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
         return ArithmeticOperation(
             operands=(convert_to_operand(other), self._operation_operand),
             operator="floordiv",
         )
 
     def __mod__(
         self,
         other: Union[
             ConstantValue,
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
-    ) -> Operation[Union[CoordinatesT, OtherCoordinatesT]]:
+    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
         return ArithmeticOperation(
             operands=(self._operation_operand, convert_to_operand(other)),
             operator="mod",
         )
 
     def __rmod__(
         self,
         other: Union[
             ConstantValue,
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
-    ) -> Operation[Union[CoordinatesT, OtherCoordinatesT]]:
+    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
         return ArithmeticOperation(
             operands=(convert_to_operand(other), self._operation_operand),
             operator="mod",
         )
 
     def __mul__(
         self,
         other: Union[
             ConstantValue,
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
-    ) -> Operation[Union[CoordinatesT, OtherCoordinatesT]]:
+    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
         return ArithmeticOperation(
             operands=(self._operation_operand, convert_to_operand(other)),
             operator="mul",
         )
 
     def __rmul__(
         self,
         other: Union[
             ConstantValue,
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
-    ) -> Operation[Union[CoordinatesT, OtherCoordinatesT]]:
+    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
         return ArithmeticOperation(
             operands=(convert_to_operand(other), self._operation_operand),
             operator="mul",
         )
 
     def __neg__(
         self,
-    ) -> Operation[CoordinatesT]:
+    ) -> Operation[IdentifierT]:
         return ArithmeticOperation(operands=(self._operation_operand,), operator="neg")
 
     def __pow__(
         self,
         other: Union[
             ConstantValue,
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
-    ) -> Operation[Union[CoordinatesT, OtherCoordinatesT]]:
+    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
         return ArithmeticOperation(
             operands=(self._operation_operand, convert_to_operand(other)),
             operator="pow",
         )
 
     def __rpow__(
         self,
         other: Union[
             ConstantValue,
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
-    ) -> Operation[Union[CoordinatesT, OtherCoordinatesT]]:
+    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
         return ArithmeticOperation(
             operands=(convert_to_operand(other), self._operation_operand),
             operator="pow",
         )
 
     def __sub__(
         self,
         other: Union[
             ConstantValue,
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
-    ) -> Operation[Union[CoordinatesT, OtherCoordinatesT]]:
+    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
         return ArithmeticOperation(
             operands=(self._operation_operand, convert_to_operand(other)),
             operator="sub",
         )
 
     def __rsub__(
         self,
         other: Union[
             ConstantValue,
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
-    ) -> Operation[Union[CoordinatesT, OtherCoordinatesT]]:
+    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
         return ArithmeticOperation(
             operands=(convert_to_operand(other), self._operation_operand),
             operator="sub",
         )
 
     def __truediv__(
         self,
         other: Union[
             ConstantValue,
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
-    ) -> Operation[Union[CoordinatesT, OtherCoordinatesT]]:
+    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
         return ArithmeticOperation(
             operands=(self._operation_operand, convert_to_operand(other)),
             operator="truediv",
         )
 
     def __rtruediv__(
         self,
         other: Union[
             ConstantValue,
-            HasCoordinates[OtherCoordinatesT],
-            Operation[OtherCoordinatesT],
+            HasIdentifier[OtherIdentifierT],
+            Operation[OtherIdentifierT],
         ],
         /,
-    ) -> Operation[Union[CoordinatesT, OtherCoordinatesT]]:
+    ) -> Operation[Union[IdentifierT, OtherIdentifierT]]:
         return ArithmeticOperation(
             operands=(convert_to_operand(other), self._operation_operand),
             operator="truediv",
         )
 
 
-OperandConvertibleBound = OperandConvertible[Coordinates]
+OperandConvertibleBound = OperandConvertible[Identifier]
 
 
 class _BaseOperation(ABC):
     """An operation is made out of one or more operands and possibly some other primitive attributes such as strings or numbers.
 
-    To ensure that operations are immutable and serializable, operands must never be of type `ConstantValue` or `HasCoordinates`.
-    These must be converted to `Constant` and `Coordinates` instead.
+    To ensure that operations are immutable and serializable, operands must never be of type `ConstantValue` or `HasIdentifier`.
+    These must be converted to `Constant` and `Identifier` instead.
 
     This base class' sole purpose is to provide a shared fundation for `Condition` and `Operation`.
     All classes inheriting from `_BaseOperation` must inherit from one of these two classes.
     As such, this class must remain private and not referenced outside this file.
     """
 
     @property
     @abstractmethod
-    def _coordinates_classes(self) -> frozenset[type[Coordinates]]:
-        """The set of classes of the coordinates used in this operation.
+    def _identifier_types(self) -> frozenset[type[Identifier]]:
+        """The set of types of the identifiers used in this operation.
 
         This is used, for instance, to detect whether an operation is purely column-based and could thus be the input of a UDAF.
         """
 
     @classmethod
-    def _get_coordinates_classes(
-        cls, operand: Optional[Operand[Coordinates]], /
-    ) -> frozenset[type[Coordinates]]:
+    def _get_identifier_types(
+        cls, operand: Optional[Operand[Identifier]], /
+    ) -> frozenset[type[Identifier]]:
         if operand is None or isinstance(operand, Constant):
             return frozenset()
-        if isinstance(operand, Coordinates):
+        if isinstance(operand, Identifier):
             return frozenset([type(operand)])
-        return operand._coordinates_classes
+        return operand._identifier_types
 
 
 class Operation(
-    OperandConvertible[CoordinatesT],
+    OperandConvertible[IdentifierT],
     _BaseOperation,
 ):
     @property
-    def _operation_operand(self) -> Operation[CoordinatesT]:
+    def _operation_operand(self) -> Operation[IdentifierT]:
         return self
 
 
-OperationBound = Operation[Coordinates]
+OperationBound = Operation[Identifier]
 
 # The following classes can be constructed from any `OperandConvertible` using Python's built-in operators.
 # Because overriding these operators requires to implement methods on `OperandConvertible` instantiating the classes below, they all have to be declared in the same file to avoid circular imports.
 
 
-ConditionSubjectBound = Union[Coordinates, OperationBound]
+ConditionSubjectBound = Union[Identifier, OperationBound]
 ConditionSubjectT = TypeVar(
     "ConditionSubjectT", bound=ConditionSubjectBound, covariant=True
 )
 
 ConditionComparisonOperatorBound = Literal[ComparisonOperator, "isin"]
 ConditionComparisonOperatorT = TypeVar(
     "ConditionComparisonOperatorT",
     bound=ConditionComparisonOperatorBound,
     covariant=True,
 )
 
-ConditionTargetBound = Optional[Union[Constant, Coordinates, OperationBound]]
+ConditionTargetBound = Optional[Union[Constant, Identifier, OperationBound]]
 ConditionTargetT = TypeVar(
     "ConditionTargetT", bound=ConditionTargetBound, covariant=True
 )
 
 ConditionCombinationOperatorBound = Optional[BooleanOperator]
 ConditionCombinationOperatorT = TypeVar(
     "ConditionCombinationOperatorT",
@@ -680,19 +680,19 @@
     ]:
         return CombinedCondition(
             sub_conditions=(~self.sub_conditions[0], ~self.sub_conditions[1]),
             operator="or" if self.operator == "and" else "and",
         )
 
     @property
-    def _coordinates_classes(self) -> frozenset[type[Coordinates]]:
+    def _identifier_types(self) -> frozenset[type[Identifier]]:
         return frozenset(
             chain(
                 *(
-                    sub_condition._coordinates_classes
+                    sub_condition._identifier_types
                     for sub_condition in self.sub_conditions
                 )
             )
         )
 
     def __repr__(self) -> str:
         return f"({self.sub_conditions[0]!r}) {'&' if self.operator == 'and' else '|'} ({self.sub_conditions[1]!r})"
@@ -721,28 +721,28 @@
 ):
     subject: ConditionSubjectT
     operator: _ComparisonOperatorT
     target: ConditionTargetT
 
     def __post_init__(self) -> None:
         assert not isinstance(
-            self.subject, HierarchyCoordinates
+            self.subject, HierarchyIdentifier
         ), "Conditions on hierarchies must use `HierarchyIsinCondition`."
 
         if self.target is None and self.operator not in {"eq", "ne"}:
             raise ValueError(
                 f"Expected `{self.target}` to be compared with an equality operator but got operator `{self.operator}`."
             )
 
     @property
-    def _coordinates_classes(self) -> frozenset[type[Coordinates]]:
+    def _identifier_types(self) -> frozenset[type[Identifier]]:
         return frozenset(
             chain(
                 *(
-                    self._get_coordinates_classes(operand)
+                    self._get_identifier_types(operand)
                     for operand in [self.subject, self.target]
                 )
             )
         )
 
     def __invert__(
         self,
@@ -766,24 +766,22 @@
     "sub": "-",
     "truediv": "/",
 }
 
 
 @keyword_only_dataclass
 @dataclass(eq=False, frozen=True)
-class ArithmeticOperation(Operation[CoordinatesT]):
-    operands: tuple[NonConditionOperand[CoordinatesT], ...]
+class ArithmeticOperation(Operation[IdentifierT]):
+    operands: tuple[NonConditionOperand[IdentifierT], ...]
     operator: ArithmeticOperator
 
     @property
-    def _coordinates_classes(self) -> frozenset[type[Coordinates]]:
+    def _identifier_types(self) -> frozenset[type[Identifier]]:
         return frozenset(
-            chain(
-                *(self._get_coordinates_classes(operand) for operand in self.operands)
-            )
+            chain(*(self._get_identifier_types(operand) for operand in self.operands))
         )
 
     def __repr__(self) -> str:
         if self.operator == "neg":
             return f"-{self._repr_operand(0)}"
 
         return f"{self._repr_operand(0)} {_ARITHMETIC_OPERATOR_TO_SYMBOL[self.operator]} {self._repr_operand(1)}"
@@ -799,53 +797,53 @@
             if operation_is_function_call_result
             else f"({operand_representation})"
         )
 
 
 @keyword_only_dataclass
 @dataclass(eq=False, frozen=True)
-class IndexingOperation(Operation[CoordinatesT]):
-    operand: NonConstantNonConditionOperand[CoordinatesT]
+class IndexingOperation(Operation[IdentifierT]):
+    operand: NonConstantNonConditionOperand[IdentifierT]
     index: Union[
         Constant,
         slice,
-        CoordinatesT,
-        Operation[CoordinatesT],
+        IdentifierT,
+        Operation[IdentifierT],
     ]
 
     def __post_init__(self) -> None:
         allowed_data_types: tuple[DataType, ...] = ("int", "int[]", "long", "long[]")
 
         if (
             isinstance(self.index, Constant)
             and self.index.data_type not in allowed_data_types
         ):
             raise TypeError(
                 f"Expected constant index's type to be one of `{allowed_data_types}` but got `{self.index.data_type}`."
             )
 
     @property
-    def _coordinates_classes(self) -> frozenset[type[Coordinates]]:
-        return self._get_coordinates_classes(self.operand).union(
+    def _identifier_types(self) -> frozenset[type[Identifier]]:
+        return self._get_identifier_types(self.operand).union(
             frozenset([])
             if isinstance(self.index, (int, tuple, slice))
-            else self._get_coordinates_classes(self.index)
+            else self._get_identifier_types(self.index)
         )
 
     def __repr__(self) -> str:
         return f"{self.operand!r}[{self.index!r}]"
 
 
-NonConstantNonConditionOperand = Union[CoordinatesT, Operation[CoordinatesT]]
-NonConditionOperand = Union[Constant, NonConstantNonConditionOperand[CoordinatesT]]
+NonConstantNonConditionOperand = Union[IdentifierT, Operation[IdentifierT]]
+NonConditionOperand = Union[Constant, NonConstantNonConditionOperand[IdentifierT]]
 
 OperandCondition = Condition[
-    NonConstantNonConditionOperand[CoordinatesT],
+    NonConstantNonConditionOperand[IdentifierT],
     ConditionComparisonOperatorBound,
-    Optional[NonConditionOperand[CoordinatesT]],
+    Optional[NonConditionOperand[IdentifierT]],
     ConditionCombinationOperatorBound,
 ]
 
 NonConstantOperand = Union[
-    NonConstantNonConditionOperand[CoordinatesT], OperandCondition[CoordinatesT]
+    NonConstantNonConditionOperand[IdentifierT], OperandCondition[IdentifierT]
 ]
-Operand = Union[Constant, NonConstantOperand[CoordinatesT]]
+Operand = Union[Constant, NonConstantOperand[IdentifierT]]
```

## atoti_core/query_filter.py

```diff
@@ -1,15 +1,15 @@
 from __future__ import annotations
 
 from typing import Literal, Optional, Union
 
 from .constant import Constant
-from .hierarchy_coordinates import HierarchyCoordinates
-from .level_coordinates import LevelCoordinates
+from .hierarchy_identifier import HierarchyIdentifier
+from .level_identifier import LevelIdentifier
 from .operation import Condition
 
 QueryFilter = Condition[
-    Union[HierarchyCoordinates, LevelCoordinates],
+    Union[HierarchyIdentifier, LevelIdentifier],
     Literal["eq", "isin", "ne"],
     Constant,
     Optional[Literal["and"]],
 ]
```

## atoti_core/raise_multiple_levels_with_same_name_error.py

```diff
@@ -1,18 +1,18 @@
 from collections.abc import Iterable
 from typing import NoReturn, Union
 
 from .base_hierarchy import BaseHierarchyBound
-from .hierarchy_coordinates import HierarchyCoordinates
+from .hierarchy_identifier import HierarchyIdentifier
 
 
 def raise_multiple_levels_with_same_name_error(
     level_name: str,
     *,
-    hierarchies: Union[Iterable[HierarchyCoordinates], Iterable[BaseHierarchyBound]],
+    hierarchies: Union[Iterable[HierarchyIdentifier], Iterable[BaseHierarchyBound]],
 ) -> NoReturn:
     raise KeyError(
         f"""Multiple levels are named {level_name}. Specify the hierarchy (and the dimension if necessary): {", ".join([
-            f'cube.levels["{hierarchy.dimension_name}", "{hierarchy.hierarchy_name}", "{level_name}"]' if isinstance(hierarchy, HierarchyCoordinates) else f'cube.levels["{hierarchy.dimension}", "{hierarchy.name}", "{level_name}"]'
+            f'cube.levels["{hierarchy.dimension_name}", "{hierarchy.hierarchy_name}", "{level_name}"]' if isinstance(hierarchy, HierarchyIdentifier) else f'cube.levels["{hierarchy.dimension}", "{hierarchy.name}", "{level_name}"]'
             for hierarchy in hierarchies
         ])}"""
     )
```

## Comparing `atoti_core/level_coordinates.py` & `atoti_core/hierarchy_identifier.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 from dataclasses import dataclass
-from functools import cached_property
 
-from .coordinates import Coordinates
-from .hierarchy_coordinates import HierarchyCoordinates
+from typing_extensions import Self
+
+from .identifier import Identifier
 
 
 @dataclass(frozen=True)
-class LevelCoordinates(Coordinates):  # pylint: disable=keyword-only-dataclass
+class HierarchyIdentifier(Identifier):  # pylint: disable=keyword-only-dataclass
     dimension_name: str
     hierarchy_name: str
-    level_name: str
 
-    @property
-    def key(self) -> tuple[str, str, str]:
-        return self.dimension_name, self.hierarchy_name, self.level_name
+    @classmethod
+    def from_java_description(cls, java_description: str, /) -> Self:
+        hierarchy_name, dimension_name = java_description.split("@")
+        return cls(dimension_name, hierarchy_name)
 
-    @cached_property
-    def hierarchy_coordinates(self) -> HierarchyCoordinates:
-        return HierarchyCoordinates(self.dimension_name, self.hierarchy_name)
+    @property
+    def key(self) -> tuple[str, str]:
+        return self.dimension_name, self.hierarchy_name
 
     def __repr__(self) -> str:
-        return f"l[{self.key}]"
+        return f"h[{self.key}]"
```

## Comparing `atoti_core-0.8.1.dist-info/METADATA` & `atoti_core-0.8.2.dist-info/METADATA`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: atoti-core
-Version: 0.8.1
+Version: 0.8.2
 Summary: Package containing private symbols shared by the other Atoti packages
 Home-page: https://www.atoti.io
 Author: ActiveViam
 Author-email: dev@atoti.io
 Keywords: atoti,core
 Classifier: Development Status :: 4 - Beta
 Classifier: License :: Free To Use But Restricted
```

## Comparing `atoti_core-0.8.1.dist-info/RECORD` & `atoti_core-0.8.2.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,78 +1,83 @@
-atoti_core/LICENSE,sha256=4jO4tBGuaf1seZk3ces3swwK45eg_VUFxtDjY5ivqNo,23472
-atoti_core/__init__.py,sha256=yGsk1Ux4qooVFza3toxtJJWrTtf5ObwMTp7dW7McPA4,2451
+atoti_core/LICENSE,sha256=JSyRUznwhVW6jj2RsFMZDaY_2QEQFMMOlbJvTy8OgOk,23472
+atoti_core/__init__.py,sha256=uHM5zuc6B5_91WRdbo-xd8xPFt8ZnxAZF84UTUJZJPc,2490
 atoti_core/_get_endpoint_path.py,sha256=zmrlyiXz6APpXtMEAFb2-o3C82bAKGuTC6ZTjaSskf0,1679
-atoti_core/_other_coordinates.py,sha256=OZRQXRu2NQovSUwQNE3ryTxprmRwE3hVoKPtZfL21cs,150
-atoti_core/_server_versions.py,sha256=uJO4uAxTvrdT7EO9pYqT_5sP1jnEr7VxIkXaI6wzc3U,398
-atoti_core/activeviam_client.py,sha256=d7ndwFDgp93l7oSBWO6WxP4BwsZOAjKM7iwoL1vcwGA,8811
+atoti_core/_link.py,sha256=ggyp5Jw-2-XVIMiNZ0gFe2anSRMcIcCZpniSSQpRBCA,1565
+atoti_core/_other_identifier.py,sha256=YWiRGiK8zNSi1MjDZrvtAFqKyHmBkGjuvJ-j-cRUbaU,145
+atoti_core/_server_versions.py,sha256=f2L-z8f3isTBH0fNttGgESTWKe62ZbofJ2Ay1DYw3AU,384
+atoti_core/activeviam_client.py,sha256=qEzCgjvP0HwnmSHXjzrNgc7lP2h8DUA8sXebIjH0KzM,8797
 atoti_core/arithmetic_operator.py,sha256=KXpKn1Zw2z_bxkW2VebZU_g6kWrBTTqeQTkEg0JxI08,128
 atoti_core/base_cube.py,sha256=cXn8jGSL6zRfDMKWzEIuhz45zdAMFEBs6R3CrpkT3ns,2437
 atoti_core/base_cubes.py,sha256=v05VbN41yBTEjFdhS3b05I8VqBmV_2qsjYZhff2INwQ,561
-atoti_core/base_hierarchies.py,sha256=jwuUaqzu4r_KrLKdMy0g1IAVEc8fi41dFg3pJbdGy6A,2277
-atoti_core/base_hierarchy.py,sha256=D0lBr25Jk9eLnBsYbZl8axOkBk49iuWhNkAApQr0PRs,5690
-atoti_core/base_level.py,sha256=Yia9kO_ZCZGL7Lpj4kY9rp6q_6F1LChhJLA9S2M7j_Y,4900
+atoti_core/base_hierarchies.py,sha256=JaQZJ8WuULcmBmiOdzmZ4azxjOl0UBpax9rTlUl1MOY,2273
+atoti_core/base_hierarchy.py,sha256=TrObNDpHg2yCey_5QEDRCughVtbX33Ik1u-xdOBQpfE,5672
+atoti_core/base_level.py,sha256=SppB6xmJDINc-R7i7BEBxyMqO4KMngPchfkQalda1v0,4989
 atoti_core/base_levels.py,sha256=RhYXjoqTdqswXu-odkcmtDl6R7q9EEyFlLRmXw2RkwY,3961
-atoti_core/base_measure.py,sha256=LW3YhnI8JPpwW5aBk_6Pt6Z956x3ZbA-9pbwI-jRetw,2522
+atoti_core/base_measure.py,sha256=MLWzp2YvvkA823CKQtkrFp1ULs4XwXGEeL0NRY32Vis,2551
 atoti_core/base_measures.py,sha256=9v1yjAflQ_F2bkdG-BWBDEqBM9UGFpf8WFfjb_RDX94,1365
-atoti_core/base_session.py,sha256=NDpwG8wiAf6FJgxsZudAye5lj11DCfuzwqUOGuE1n5Q,10896
+atoti_core/base_session.py,sha256=fCwz2vuScEf7Uh_IHQdDwQMakcesJnGcaDLc0z85DmQ,11005
 atoti_core/boolean_operator.py,sha256=ibSEuUAGWYkFj8vsE22j4adXLkXIUsKS4_p9Fpyny88,221
-atoti_core/column_coordinates.py,sha256=eF1jbMXoq_HMflJtCzfaUVr01THYx37YFyFwBif3Qs8,420
+atoti_core/column_identifier.py,sha256=awh9TWAnourUfIV9X_Z_WOAcvNjcsCtp6pvJ5oKszQw,494
 atoti_core/combine_conditions.py,sha256=sZ_bmrorhcfPg8VT_dOxz7g4tl-wMgEyNqvFT0Q5WsM,3537
 atoti_core/comparison_operator.py,sha256=UrFgPkRECKxU9wqcB45dloVYBrUGrZyAMGdN_Q4aii8,732
-atoti_core/condition_to_dict.py,sha256=c4C4cB9MRIQXKn8Zclii5oCK71t8qQRP1PDiRTcLCDw,773
+atoti_core/condition_to_dict.py,sha256=zbXzfUQtmTNmyGybbdJ2McyQlDlnT5q290F4XYzD7u4,764
 atoti_core/condition_to_pairs.py,sha256=zQQWT70scCM8YGYXZxKC2tdZkKPNUB31nSx3CjYa09s,913
 atoti_core/constant.py,sha256=-G09zKPly0G6wClLBp6KKQ1J0DMFSCRWvWdf_itYNs8,5240
 atoti_core/context.py,sha256=_vh7nlMabh6221vp0fcpZ35WAOAqsssG_DCQb3SeXVM,88
 atoti_core/convert_series.py,sha256=NAYgA_WspxiQztdWk0ch41TB3VPThiIxHBpo8-F5OIQ,3313
-atoti_core/coordinates.py,sha256=9bG02aFagh97zrSf1K2ymkldZ-do0ZId2xALM3Pqv-M,349
-atoti_core/coordinates_like.py,sha256=rAR_Ec0CYyNbLCrVWceigz8vDwliH4glgmevfiXUZ4w,153
 atoti_core/create_dataframe.py,sha256=HJ5EaXfOPzgzQQXsui4KSubzkSIN60zSmYukOd-0R4c,1720
 atoti_core/data_type.py,sha256=UjVTL6mmwYFNUMkLJHQVE7DNy4VAngMLQfc9XIolV3c,3946
-atoti_core/decombine_condition.py,sha256=XLcuFZqpyfynHMChTTADy6JdWqW_0TTtKFpe0pQmfVs,9600
+atoti_core/decombine_condition.py,sha256=yI-uzoQ0DKVsPP7ChyplvvRuAFQzUqEWj-hmqtI8HnQ,9596
 atoti_core/default_query_timeout.py,sha256=W5qgzdk26T0eoXVM6W2VC3nv7bKUwplM6wE8wl3qRiQ,78
 atoti_core/delegate_mutable_mapping.py,sha256=Q_HDEv3mKSoGUsZMaKLCaWr77cIlZNcTXbi_nREGRss,3191
 atoti_core/delegate_mutable_set.py,sha256=Wh54XQj4d63yVaiGN7xUdPkLUwuul0avd8xvvMrPQ-g,1325
 atoti_core/deprecated.py,sha256=Z9PKwNBfem77PUTqEJYUHZYNgK_s56A1gYOF4aDQ9yU,553
-atoti_core/doc.py,sha256=kmMhZ3bfr3UH25ao3yC82QaCEQX1DItgsCIGX_b5LhM,1903
+atoti_core/doc.py,sha256=0yG7EWcSogqzwRAh_zLP9gBoayTQ-L-PY8i8_YOWHa4,1900
 atoti_core/empty_mapping.py,sha256=i2jBPz404-PcpHoHusfQNv9kmEYP10Hzn7XB02F-sGc,165
-atoti_core/fetch_json.py,sha256=fkm8PqxYWeSfVWun-P7_tfLQS2_Qz7VREZjhCqawUg8,3431
+atoti_core/fetch_json.py,sha256=fvxOcK7YNwR-qZDM8lPsYYBSR7X-YG2JCLPqlzwmrqk,3471
 atoti_core/find_corresponding_top_level_variable_name.py,sha256=SOsU4RpW8Ix29C4aTIBIu-xacAGGIXBr5468b7XsVtU,590
-atoti_core/get_coordinates.py,sha256=_mJQ5kx1zDmfElj5098n1NKvXikgdDQQddICnwrkrlA,344
 atoti_core/get_env_flag.py,sha256=vVc3jfLZEuvIDwvlENInkhMOMQtZrIUHMaGtbjMHIsg,326
+atoti_core/get_identifier.py,sha256=4rxxuyL0UsNyJ8qt0SH-8jrqQ_CeUQ2OuixWSJ2knCg,318
 atoti_core/get_installed_plugins.py,sha256=eeeu0Er_udDLVfqupKiQ-4IkqDynFylyCBnfRK92MhE,1613
 atoti_core/get_ipython.py,sha256=n9B-amc65pSIZFf5ZdOR8goqvpkozP_QV5PVuF-EZx4,1008
 atoti_core/get_literal_args.py,sha256=Z3nRNgn-cu6KsBXm6QZP9_P5RNvMlaq1Bwzgf2UwH6A,2145
 atoti_core/get_package_version.py,sha256=w0QRERDT9e2S15aTujfv7py3QNkAf-Z5LxG0B3tqOcA,358
 atoti_core/get_top_level_package_name.py,sha256=RTsEgQWDzXL5WokrXDVzyK2GSsTf4XUbCOXgi08cq-w,265
-atoti_core/has_coordinates.py,sha256=wpMC6_XTYrnDnQGGknKQWTaHtK6OgUTuyaRQpypUeW8,379
-atoti_core/hierarchy_coordinates.py,sha256=woAlAErOh7CIBMzuB9w4cwCs4bBvTJTMxJCG5PhbFTk,402
-atoti_core/hierarchy_isin_condition.py,sha256=lgx27I9WBva54NdmJxkmAI-ms8E-WY5_WL0EW6R7V3M,4282
+atoti_core/has_identifier.py,sha256=LpBFEXLhV-ykvr0zshktk5fpVtE6bJHLRtQsL7tZDXw,367
+atoti_core/hierarchy_identifier.py,sha256=RzzgHxdSiYC0mUim80agXEhw06hsSfhj7W6aU_06EF0,642
+atoti_core/hierarchy_isin_condition.py,sha256=g7VuAbge8AbUnNAOHSzCHqi7Ebs5lrheRudCXZXmNuU,3954
 atoti_core/hierarchy_key.py,sha256=9phdmKk2sp8q1GGsTZKpyiLM7-ojibRebA8FcBgQFpo,69
 atoti_core/http_method.py,sha256=wd2TYDjpLryll8PLHOWKP8nYZEDaG-iW4aim7PjSXho,109
+atoti_core/identifiable.py,sha256=AKysC9y9afOLgFIf2o5VCKQCF1tYRpwQmvURgjSF0Qs,144
+atoti_core/identifier.py,sha256=j2ur4ysQIGJ-v4d9I5yXUFhJZJXKvsLJhPK1kfC8TZ4,348
+atoti_core/identifier_like.py,sha256=nMN6LGnbLhabNGc9esuS0wBYPTR9Dxw1bfzV-6WuiGE,146
+atoti_core/identify.py,sha256=wRsGwqgRDPIGkccClLsEwlWyCQeSLXDDEjEbidU7dhc,312
 atoti_core/immutable_mapping.py,sha256=l_6zp5OO8uheyS91xlZvasdOjTR-IcN6Nd7xq7YoNmY,886
 atoti_core/ipython_key_completions.py,sha256=ur_ahskeZIkJlhVtUnKWvw9ZD80pFw6T8342bSyDdYk,404
-atoti_core/isin_condition.py,sha256=EMp00i3wrgzRx1Sfce_AKBzwRmN6wAe0cmXZG9esbSE,3420
+atoti_core/isin_condition.py,sha256=dV_zOcBsUnnAW4vVCBZIciRQ5rdnSatk4MRmkRR_TEA,3407
 atoti_core/java_max_int.py,sha256=EPR4gNoGUOyaWAi6OnT2L_KutDLHQBpzOFMwWVwvtbQ,109
-atoti_core/keyword_only_dataclass.py,sha256=5DfSEtbZlcSsS0uslcDXiMNtajinp2sxTNEVhpTS9DA,1011
-atoti_core/level_coordinates.py,sha256=Cy6TC4EBuFHQ-G6TcByCO7ChMaqnZ_oGbHb4rKIGJ88,695
+atoti_core/keyword_only_dataclass.py,sha256=MVuE-zdwuCf7bcPj6eh8C2MkyiTnAzVxxuzMzhQaGoU,1055
+atoti_core/level_identifier.py,sha256=fBjExmd9VC0kzjncowfOY9suottu2xqhaSpdr94PJZg,767
 atoti_core/level_key.py,sha256=KJSltyI9tDw4I2Jyy7bnH74YcO0Qml-c5GtEuMFhrbo,102
 atoti_core/license_key.py,sha256=-CIVHH-Q0mCDHwdZPciTpSpeqDnt0958jTVLZOOe3dQ,637
-atoti_core/measure_coordinates.py,sha256=0cHmnrOadaLXn8jwenxkAnK33PdesKvJkw0Om7B7Z9s,364
+atoti_core/measure_identifier.py,sha256=-xWbp6QMnejDpe5LUIyeoEjPPCynp7vwwTLiAO9FxpY,777
+atoti_core/mime_type.py,sha256=5GZJ0QrOl-jigCwp_FLob5y96K3inJgHsmRuECSksss,295
 atoti_core/missing_plugin_error.py,sha256=tzuIKMAfNosWfSLjFh5NXQPzWxdI_uMFznLowMhD1Gk,282
-atoti_core/operand_convertible_with_coordinates.py,sha256=Curj3ggcD9WsEcmM-yRB-XbkEYH_wSAzP3c0apl6lfY,9157
-atoti_core/operation.py,sha256=lNurcb1UHnnSL960WJlKdski_PNVPK5NrvS9l0w9dWU,25609
+atoti_core/operand_convertible_with_identifier.py,sha256=lVcM1Cvnc14YwyTgjOXU9TfxY7KlRVHrQ8qSHFoU7i4,9041
+atoti_core/operation.py,sha256=azRQvP202ftQbglZ8TZ4QAzFCJIrIuKbTeaNztdpDXg,25370
 atoti_core/pandas_nullable_dtype_to_non_nullable_dtype.py,sha256=GtlR0Ow9OZWcfYEctr0NI1SwNei20YORnaWW01IS42Y,315
 atoti_core/path.py,sha256=477HG_h_YrE320S-Q5hwnlbCh9xjcthKVkmI0Mn7wVQ,180
 atoti_core/plugin.py,sha256=XwymA0gJ3UAM4iZ7QQ5ZyNd3suP7SWKZY3OV31JwoDI,738
 atoti_core/plugins.py,sha256=28ckZdVW3Rn_XmQ14MKMsa5Vj7zgQClv2Du7HSuMgq8,866
 atoti_core/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 atoti_core/query_doc.py,sha256=SZ81X9K2srZBJnZrhK5-HhUIIvZ26BwqhvwRs3hceqI,9949
-atoti_core/query_filter.py,sha256=HIkG6l92qzfDVTgv-LFUtqcMEP_DO2BCxEUMrta3prw,405
-atoti_core/raise_multiple_levels_with_same_name_error.py,sha256=OW_obnSS-nNM415T3c4h8iyFd-axoaXMoMqpNWa9R8Y,789
+atoti_core/query_filter.py,sha256=AHuU6ZL4OOqmjunwaBnd4jAFZ7zTPsN9cXvDN4KtDj8,399
+atoti_core/raise_multiple_levels_with_same_name_error.py,sha256=J9lEGm-e52uYKDdtGxxnpTdHUduZionB0Njky4SpDp8,785
 atoti_core/reactive_mutable_set.py,sha256=vGQlNAiDnto2GWLdVhL6sM4qKRxdA8uqXm4NYMbUi14,2270
 atoti_core/repr_json.py,sha256=0M2H3k3A0AW-De2xt71MzgyFTFfWc9eQin_S5ZbCYiQ,2202
 atoti_core/scenario.py,sha256=Kp7RU9veySavOAG6mufEAjZPcBdh-m2P8MDpHY2Q4HE,28
 atoti_core/str_to_bool.py,sha256=Nq27fx8yRn3bDBcDr2ktT9emk-wlnBbNfRBOVLJfgmM,563
-atoti_core-0.8.1.dist-info/METADATA,sha256=LItciXjZlTVZh2k6Rt6eX49OnCjfEC6EBSjg-zZsl0A,855
-atoti_core-0.8.1.dist-info/WHEEL,sha256=-xFWYjBwxwp_eg2T02KSILmYxFgZAplP6Hjbi2nYCnQ,109
-atoti_core-0.8.1.dist-info/top_level.txt,sha256=X4wSoqoZ3mCpyKACr5RpBXn4RbvtPqwcYyaJXAiLuy4,11
-atoti_core-0.8.1.dist-info/RECORD,,
+atoti_core/table_identifier.py,sha256=gXWslfq_yJqe0sCzU8zaMHCsl12ZT8xmTVPU9Lg_FVQ,352
+atoti_core-0.8.2.dist-info/METADATA,sha256=xRLywPk-q6wbeAniBAWO2zov3q7VmLSWkPHXAaEngkk,855
+atoti_core-0.8.2.dist-info/WHEEL,sha256=8ngoJnqny485_Zhidm3gUHNLPQTUIjfhFb7Qoa0d3wA,109
+atoti_core-0.8.2.dist-info/top_level.txt,sha256=X4wSoqoZ3mCpyKACr5RpBXn4RbvtPqwcYyaJXAiLuy4,11
+atoti_core-0.8.2.dist-info/RECORD,,
```

