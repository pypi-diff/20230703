# Comparing `tmp/atoti_query-0.8.1-0_ad0cf24-py3-none-any.whl.zip` & `tmp/atoti_query-0.8.2-0_80138c9-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,64 +1,64 @@
-Zip file size: 59498 bytes, number of entries: 62
--rw-r--r--  2.0 unx    23472 b- defN 23-Jun-20 12:53 atoti_query/LICENSE
--rw-r--r--  2.0 unx      701 b- defN 23-Jun-20 12:46 atoti_query/__init__.py
--rw-r--r--  2.0 unx     1396 b- defN 23-Jun-20 12:46 atoti_query/_arrow_to_pandas.py
--rw-r--r--  2.0 unx     1551 b- defN 23-Jun-20 12:46 atoti_query/_cellset.py
--rw-r--r--  2.0 unx    16443 b- defN 23-Jun-20 12:46 atoti_query/_cellset_to_query_result.py
--rw-r--r--  2.0 unx     2734 b- defN 23-Jun-20 12:46 atoti_query/_create_query_cubes_from_discovery.py
--rw-r--r--  2.0 unx     1800 b- defN 23-Jun-20 12:46 atoti_query/_discovery.py
--rw-r--r--  2.0 unx      644 b- defN 23-Jun-20 12:46 atoti_query/_execute_gaq.py
--rw-r--r--  2.0 unx      312 b- defN 23-Jun-20 12:46 atoti_query/_gaq_filter.py
--rw-r--r--  2.0 unx    13046 b- defN 23-Jun-20 12:46 atoti_query/_generate_mdx.py
--rw-r--r--  2.0 unx      591 b- defN 23-Jun-20 12:46 atoti_query/_get_cube.py
--rw-r--r--  2.0 unx      285 b- defN 23-Jun-20 12:46 atoti_query/_get_data_types.py
--rw-r--r--  2.0 unx      729 b- defN 23-Jun-20 12:46 atoti_query/_get_dimensions_mapping.py
--rw-r--r--  2.0 unx      675 b- defN 23-Jun-20 12:46 atoti_query/_hierarchy_filter.py
--rw-r--r--  2.0 unx     1193 b- defN 23-Jun-20 12:46 atoti_query/_index_cellset.py
--rw-r--r--  2.0 unx     2436 b- defN 23-Jun-20 12:46 atoti_query/_index_discovery.py
--rw-r--r--  2.0 unx      509 b- defN 23-Jun-20 12:46 atoti_query/_is_gaq_filter.py
--rw-r--r--  2.0 unx      105 b- defN 23-Jun-20 12:46 atoti_query/_named.py
--rw-r--r--  2.0 unx      553 b- defN 23-Jun-20 12:46 atoti_query/_parse_level_coordinates.py
--rw-r--r--  2.0 unx      490 b- defN 23-Jun-20 12:46 atoti_query/_query_mdx.py
--rw-r--r--  2.0 unx      282 b- defN 23-Jun-20 12:46 atoti_query/_query_private_parameters.py
--rw-r--r--  2.0 unx      452 b- defN 23-Jun-20 12:46 atoti_query/_widget_conversion_details.py
--rw-r--r--  2.0 unx      524 b- defN 23-Jun-20 12:46 atoti_query/auth.py
--rw-r--r--  2.0 unx     1034 b- defN 23-Jun-20 12:46 atoti_query/basic_authentication.py
--rw-r--r--  2.0 unx     1944 b- defN 23-Jun-20 12:46 atoti_query/client_certificate.py
--rw-r--r--  2.0 unx     1950 b- defN 23-Jun-20 12:46 atoti_query/oauth2_resource_owner_password_authentication.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-20 12:46 atoti_query/py.typed
--rw-r--r--  2.0 unx     4455 b- defN 23-Jun-20 12:46 atoti_query/query_cube.py
--rw-r--r--  2.0 unx      170 b- defN 23-Jun-20 12:46 atoti_query/query_cubes.py
--rw-r--r--  2.0 unx      728 b- defN 23-Jun-20 12:46 atoti_query/query_hierarchies.py
--rw-r--r--  2.0 unx     1028 b- defN 23-Jun-20 12:46 atoti_query/query_hierarchy.py
--rw-r--r--  2.0 unx      772 b- defN 23-Jun-20 12:46 atoti_query/query_level.py
--rw-r--r--  2.0 unx     1316 b- defN 23-Jun-20 12:46 atoti_query/query_levels.py
--rw-r--r--  2.0 unx      990 b- defN 23-Jun-20 12:46 atoti_query/query_measure.py
--rw-r--r--  2.0 unx      191 b- defN 23-Jun-20 12:46 atoti_query/query_measures.py
--rw-r--r--  2.0 unx     5648 b- defN 23-Jun-20 12:46 atoti_query/query_result.py
--rw-r--r--  2.0 unx    12502 b- defN 23-Jun-20 12:46 atoti_query/query_session.py
--rw-r--r--  2.0 unx      752 b- defN 23-Jun-20 12:46 atoti_query/token_authentication.py
--rw-r--r--  2.0 unx      150 b- defN 23-Jun-20 12:46 atoti_query/_internal/__init__.py
--rw-r--r--  2.0 unx      134 b- defN 23-Jun-20 12:46 atoti_query/security/__init__.py
--rw-r--r--  2.0 unx       94 b- defN 23-Jun-20 12:46 atoti_query/security/_authentication_type.py
--rw-r--r--  2.0 unx       28 b- defN 23-Jun-20 12:46 atoti_query/security/_column_key.py
--rw-r--r--  2.0 unx      371 b- defN 23-Jun-20 12:46 atoti_query/security/_constants.py
--rw-r--r--  2.0 unx     2997 b- defN 23-Jun-20 12:46 atoti_query/security/_content_client.py
--rw-r--r--  2.0 unx      258 b- defN 23-Jun-20 12:46 atoti_query/security/_restriction.py
--rw-r--r--  2.0 unx      728 b- defN 23-Jun-20 12:46 atoti_query/security/_restriction_from_mapping.py
--rw-r--r--  2.0 unx     1411 b- defN 23-Jun-20 12:46 atoti_query/security/_restriction_to_dict.py
--rw-r--r--  2.0 unx     1162 b- defN 23-Jun-20 12:46 atoti_query/security/_restrictions.py
--rw-r--r--  2.0 unx     5094 b- defN 23-Jun-20 12:46 atoti_query/security/_roles.py
--rw-r--r--  2.0 unx     6003 b- defN 23-Jun-20 12:46 atoti_query/security/_service.py
--rw-r--r--  2.0 unx     4375 b- defN 23-Jun-20 12:46 atoti_query/security/basic_security.py
--rw-r--r--  2.0 unx     1041 b- defN 23-Jun-20 12:46 atoti_query/security/default_roles.py
--rw-r--r--  2.0 unx     4174 b- defN 23-Jun-20 12:46 atoti_query/security/individual_roles.py
--rw-r--r--  2.0 unx      730 b- defN 23-Jun-20 12:46 atoti_query/security/kerberos_security.py
--rw-r--r--  2.0 unx     1934 b- defN 23-Jun-20 12:46 atoti_query/security/ldap_security.py
--rw-r--r--  2.0 unx     2459 b- defN 23-Jun-20 12:46 atoti_query/security/oidc_security.py
--rw-r--r--  2.0 unx     3839 b- defN 23-Jun-20 12:46 atoti_query/security/role_mapping.py
--rw-r--r--  2.0 unx    12217 b- defN 23-Jun-20 12:46 atoti_query/security/security.py
--rw-r--r--  2.0 unx      913 b- defN 23-Jun-20 12:53 atoti_query-0.8.1.dist-info/METADATA
--rw-r--r--  2.0 unx      109 b- defN 23-Jun-20 12:53 atoti_query-0.8.1.dist-info/WHEEL
--rw-r--r--  2.0 unx       12 b- defN 23-Jun-20 12:53 atoti_query-0.8.1.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     5484 b- defN 23-Jun-20 12:53 atoti_query-0.8.1.dist-info/RECORD
-62 files, 160120 bytes uncompressed, 50692 bytes compressed:  68.3%
+Zip file size: 59501 bytes, number of entries: 62
+-rw-r--r--  2.0 unx    23472 b- defN 23-Jul-03 17:49 atoti_query/LICENSE
+-rw-r--r--  2.0 unx      701 b- defN 23-Jul-03 17:39 atoti_query/__init__.py
+-rw-r--r--  2.0 unx     1380 b- defN 23-Jul-03 17:39 atoti_query/_arrow_to_pandas.py
+-rw-r--r--  2.0 unx     1537 b- defN 23-Jul-03 17:39 atoti_query/_cellset.py
+-rw-r--r--  2.0 unx    16523 b- defN 23-Jul-03 17:39 atoti_query/_cellset_to_query_result.py
+-rw-r--r--  2.0 unx     2833 b- defN 23-Jul-03 17:39 atoti_query/_create_query_cubes_from_discovery.py
+-rw-r--r--  2.0 unx     1800 b- defN 23-Jul-03 17:39 atoti_query/_discovery.py
+-rw-r--r--  2.0 unx      638 b- defN 23-Jul-03 17:39 atoti_query/_execute_gaq.py
+-rw-r--r--  2.0 unx      308 b- defN 23-Jul-03 17:39 atoti_query/_gaq_filter.py
+-rw-r--r--  2.0 unx    12981 b- defN 23-Jul-03 17:39 atoti_query/_generate_mdx.py
+-rw-r--r--  2.0 unx      591 b- defN 23-Jul-03 17:39 atoti_query/_get_cube.py
+-rw-r--r--  2.0 unx      281 b- defN 23-Jul-03 17:39 atoti_query/_get_data_types.py
+-rw-r--r--  2.0 unx      729 b- defN 23-Jul-03 17:39 atoti_query/_get_dimensions_mapping.py
+-rw-r--r--  2.0 unx      675 b- defN 23-Jul-03 17:39 atoti_query/_hierarchy_filter.py
+-rw-r--r--  2.0 unx     1193 b- defN 23-Jul-03 17:39 atoti_query/_index_cellset.py
+-rw-r--r--  2.0 unx     2436 b- defN 23-Jul-03 17:39 atoti_query/_index_discovery.py
+-rw-r--r--  2.0 unx      509 b- defN 23-Jul-03 17:39 atoti_query/_is_gaq_filter.py
+-rw-r--r--  2.0 unx      105 b- defN 23-Jul-03 17:39 atoti_query/_named.py
+-rw-r--r--  2.0 unx      579 b- defN 23-Jul-03 17:39 atoti_query/_parse_level_identifier.py
+-rw-r--r--  2.0 unx      490 b- defN 23-Jul-03 17:39 atoti_query/_query_mdx.py
+-rw-r--r--  2.0 unx      282 b- defN 23-Jul-03 17:39 atoti_query/_query_private_parameters.py
+-rw-r--r--  2.0 unx      452 b- defN 23-Jul-03 17:39 atoti_query/_widget_conversion_details.py
+-rw-r--r--  2.0 unx      524 b- defN 23-Jul-03 17:39 atoti_query/auth.py
+-rw-r--r--  2.0 unx     1034 b- defN 23-Jul-03 17:39 atoti_query/basic_authentication.py
+-rw-r--r--  2.0 unx     1944 b- defN 23-Jul-03 17:39 atoti_query/client_certificate.py
+-rw-r--r--  2.0 unx     1950 b- defN 23-Jul-03 17:39 atoti_query/oauth2_resource_owner_password_authentication.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-03 17:39 atoti_query/py.typed
+-rw-r--r--  2.0 unx     4439 b- defN 23-Jul-03 17:39 atoti_query/query_cube.py
+-rw-r--r--  2.0 unx      170 b- defN 23-Jul-03 17:39 atoti_query/query_cubes.py
+-rw-r--r--  2.0 unx      728 b- defN 23-Jul-03 17:39 atoti_query/query_hierarchies.py
+-rw-r--r--  2.0 unx      807 b- defN 23-Jul-03 17:39 atoti_query/query_hierarchy.py
+-rw-r--r--  2.0 unx      354 b- defN 23-Jul-03 17:39 atoti_query/query_level.py
+-rw-r--r--  2.0 unx     1316 b- defN 23-Jul-03 17:39 atoti_query/query_levels.py
+-rw-r--r--  2.0 unx     1035 b- defN 23-Jul-03 17:39 atoti_query/query_measure.py
+-rw-r--r--  2.0 unx      191 b- defN 23-Jul-03 17:39 atoti_query/query_measures.py
+-rw-r--r--  2.0 unx     5803 b- defN 23-Jul-03 17:39 atoti_query/query_result.py
+-rw-r--r--  2.0 unx    12492 b- defN 23-Jul-03 17:39 atoti_query/query_session.py
+-rw-r--r--  2.0 unx      752 b- defN 23-Jul-03 17:39 atoti_query/token_authentication.py
+-rw-r--r--  2.0 unx      150 b- defN 23-Jul-03 17:39 atoti_query/_internal/__init__.py
+-rw-r--r--  2.0 unx      134 b- defN 23-Jul-03 17:39 atoti_query/security/__init__.py
+-rw-r--r--  2.0 unx       94 b- defN 23-Jul-03 17:39 atoti_query/security/_authentication_type.py
+-rw-r--r--  2.0 unx       28 b- defN 23-Jul-03 17:39 atoti_query/security/_column_key.py
+-rw-r--r--  2.0 unx      371 b- defN 23-Jul-03 17:39 atoti_query/security/_constants.py
+-rw-r--r--  2.0 unx     3096 b- defN 23-Jul-03 17:39 atoti_query/security/_content_client.py
+-rw-r--r--  2.0 unx      256 b- defN 23-Jul-03 17:39 atoti_query/security/_restriction.py
+-rw-r--r--  2.0 unx      784 b- defN 23-Jul-03 17:39 atoti_query/security/_restriction_from_mapping.py
+-rw-r--r--  2.0 unx     1443 b- defN 23-Jul-03 17:39 atoti_query/security/_restriction_to_dict.py
+-rw-r--r--  2.0 unx     1162 b- defN 23-Jul-03 17:39 atoti_query/security/_restrictions.py
+-rw-r--r--  2.0 unx     5094 b- defN 23-Jul-03 17:39 atoti_query/security/_roles.py
+-rw-r--r--  2.0 unx     6003 b- defN 23-Jul-03 17:39 atoti_query/security/_service.py
+-rw-r--r--  2.0 unx     4375 b- defN 23-Jul-03 17:39 atoti_query/security/basic_security.py
+-rw-r--r--  2.0 unx     1041 b- defN 23-Jul-03 17:39 atoti_query/security/default_roles.py
+-rw-r--r--  2.0 unx     4174 b- defN 23-Jul-03 17:39 atoti_query/security/individual_roles.py
+-rw-r--r--  2.0 unx      730 b- defN 23-Jul-03 17:39 atoti_query/security/kerberos_security.py
+-rw-r--r--  2.0 unx     1934 b- defN 23-Jul-03 17:39 atoti_query/security/ldap_security.py
+-rw-r--r--  2.0 unx     2459 b- defN 23-Jul-03 17:39 atoti_query/security/oidc_security.py
+-rw-r--r--  2.0 unx     3839 b- defN 23-Jul-03 17:39 atoti_query/security/role_mapping.py
+-rw-r--r--  2.0 unx    12217 b- defN 23-Jul-03 17:39 atoti_query/security/security.py
+-rw-r--r--  2.0 unx      913 b- defN 23-Jul-03 17:49 atoti_query-0.8.2.dist-info/METADATA
+-rw-r--r--  2.0 unx      109 b- defN 23-Jul-03 17:49 atoti_query-0.8.2.dist-info/WHEEL
+-rw-r--r--  2.0 unx       12 b- defN 23-Jul-03 17:49 atoti_query-0.8.2.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     5483 b- defN 23-Jul-03 17:49 atoti_query-0.8.2.dist-info/RECORD
+62 files, 159935 bytes uncompressed, 50697 bytes compressed:  68.3%
```

## zipnote {}

```diff
@@ -48,15 +48,15 @@
 
 Filename: atoti_query/_is_gaq_filter.py
 Comment: 
 
 Filename: atoti_query/_named.py
 Comment: 
 
-Filename: atoti_query/_parse_level_coordinates.py
+Filename: atoti_query/_parse_level_identifier.py
 Comment: 
 
 Filename: atoti_query/_query_mdx.py
 Comment: 
 
 Filename: atoti_query/_query_private_parameters.py
 Comment: 
@@ -168,20 +168,20 @@
 
 Filename: atoti_query/security/role_mapping.py
 Comment: 
 
 Filename: atoti_query/security/security.py
 Comment: 
 
-Filename: atoti_query-0.8.1.dist-info/METADATA
+Filename: atoti_query-0.8.2.dist-info/METADATA
 Comment: 
 
-Filename: atoti_query-0.8.1.dist-info/WHEEL
+Filename: atoti_query-0.8.2.dist-info/WHEEL
 Comment: 
 
-Filename: atoti_query-0.8.1.dist-info/top_level.txt
+Filename: atoti_query-0.8.2.dist-info/top_level.txt
 Comment: 
 
-Filename: atoti_query-0.8.1.dist-info/RECORD
+Filename: atoti_query-0.8.2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## atoti_query/LICENSE

```diff
@@ -1,8 +1,8 @@
-This free community end user license agreement ("EULA") is entered into by and between You ("END USER") acting as a legal representative of a business entity ("END CUSTOMER") and Quartet Financial Systems, Inc., d.b.a ActiveViam, a company registered under the laws of the State of Delaware in the United States of America, with office located at 550 7th Avenue, 19th Floor, New York, New York 10018, United States of America ("ActiveViam") and governs the use by End User of Atoti CE version 0.8.1, a tool composed of a set of libraries, extensions such as JupyterLab extension, and its documentation that allows the development of rapid decision-making applications based on a large volume of datasets, developed by ActiveViam (the "SOFTWARE").
+This free community end user license agreement ("EULA") is entered into by and between You ("END USER") acting as a legal representative of a business entity ("END CUSTOMER") and Quartet Financial Systems, Inc., d.b.a ActiveViam, a company registered under the laws of the State of Delaware in the United States of America, with office located at 550 7th Avenue, 19th Floor, New York, New York 10018, United States of America ("ActiveViam") and governs the use by End User of Atoti CE version 0.8.2, a tool composed of a set of libraries, extensions such as JupyterLab extension, and its documentation that allows the development of rapid decision-making applications based on a large volume of datasets, developed by ActiveViam (the "SOFTWARE").
 
 By requesting to have access to the Software, downloading or using the Software, End User acknowledges that he/she and End Customer has understood and agreed with the terms of this EULA.
 If End Customer does not accept these terms, End User must not use the Software.
 
 End Customer and ActiveViam are hereinafter individually or collectively referred to as the "PARTY (IES)".
 
 1. Purpose & description of the Software
```

## atoti_query/_arrow_to_pandas.py

```diff
@@ -1,13 +1,13 @@
 from collections.abc import Iterable
 
 import pandas as pd
 import pyarrow as pa
 
-from ._parse_level_coordinates import parse_level_coordinates
+from ._parse_level_identifier import parse_level_identifier
 
 # See https://arrow.apache.org/docs/python/pandas.html#nullable-types.
 # Only types that can be sent by Atoti Server are listed.
 _ARROW_TYPE_TO_PANDAS_NULLABLE_TYPE = {
     pa.int32(): pd.Int32Dtype(),
     pa.int64(): pd.Int64Dtype(),
     pa.bool_(): pd.BooleanDtype(),
@@ -22,18 +22,17 @@
 ) -> pd.DataFrame:
     # Fast for small tables (less than 100k lines) but can take several seconds for larger datasets.
     dataframe: pd.DataFrame = table.to_pandas(
         # The level columns could stay non nullable but there is no fast way to handle them differently than measure columns.
         types_mapper=_ARROW_TYPE_TO_PANDAS_NULLABLE_TYPE.get
     )
     column_names: Iterable[str] = table.column_names
-    level_coordinates = {
-        column_name: parse_level_coordinates(column_name)
-        for column_name in column_names
+    level_identifier = {
+        column_name: parse_level_identifier(column_name) for column_name in column_names
     }
     return dataframe.rename(
         columns={
-            column_name: level_coordinates.level_name
-            for column_name, level_coordinates in level_coordinates.items()
-            if level_coordinates is not None
+            column_name: level_identifier.level_name
+            for column_name, level_identifier in level_identifier.items()
+            if level_identifier is not None
         }
     )
```

## atoti_query/_cellset.py

```diff
@@ -16,15 +16,15 @@
 class CellSetMember(TypedDict):
     captionPath: Sequence[str]
     namePath: Sequence[str]
 
 
 class CellSetAxis(TypedDict):
     hierarchies: Sequence[CellSetHierarchy]
-    id: int  # noqa: A003
+    id: int
     positions: Sequence[Sequence[CellSetMember]]
 
 
 class NormalizedCellSetAxis(CellSetAxis, TypedDict):
     maxLevelPerHierarchy: Sequence[int]
     """This property exists in CellSets returned by the WebSocket API but not in those returned by the REST API.
```

## atoti_query/_cellset_to_query_result.py

```diff
@@ -5,17 +5,17 @@
 from typing import TYPE_CHECKING, Any, Literal, Optional, Union, cast
 
 import pandas as pd
 from atoti_core import (
     Context,
     DataFrameColumnDescription,
     DataType,
-    HierarchyCoordinates,
-    LevelCoordinates,
-    MeasureCoordinates,
+    HierarchyIdentifier,
+    LevelIdentifier,
+    MeasureIdentifier,
     convert_series,
     create_dataframe,
 )
 
 from ._cellset import (
     CellSetAxis,
     CellSetCellProperties,
@@ -34,15 +34,15 @@
     from pandas.io.formats.style import Styler  # pylint: disable=nested-import
 
 
 _MEASURES_HIERARCHY: CellSetHierarchy = {
     "dimension": "Measures",
     "hierarchy": "Measures",
 }
-_MEASURES_HIERARCHY_COORDINATES = HierarchyCoordinates(
+_MEASURES_HIERARCHY_IDENTIFIER = HierarchyIdentifier(
     _MEASURES_HIERARCHY["dimension"],
     _MEASURES_HIERARCHY["hierarchy"],
 )
 
 _GRAND_TOTAL_CAPTION = "Total"
 
 
@@ -88,22 +88,25 @@
         if hierarchy == _MEASURES_HIERARCHY
         for position in axis["positions"]
     }
 
     return list(name_to_caption.keys()), list(name_to_caption.values())
 
 
-def _get_levels_coordinates(
+def _get_level_identifiers(
     axes: Iterable[NormalizedCellSetAxis],
     /,
     *,
     cube: IndexedDiscoveryCube,
-) -> list[LevelCoordinates]:
+) -> list[LevelIdentifier]:
     return [
-        LevelCoordinates(hierarchy["dimension"], hierarchy["hierarchy"], level["name"])
+        LevelIdentifier(
+            HierarchyIdentifier(hierarchy["dimension"], hierarchy["hierarchy"]),
+            level["name"],
+        )
         for axis in axes
         if not _is_slicer(axis)
         for hierarchy_index, hierarchy in enumerate(axis["hierarchies"])
         if hierarchy != _MEASURES_HIERARCHY
         for level_index, level in enumerate(
             cube["dimensions"][hierarchy["dimension"]]["hierarchies"][
                 hierarchy["hierarchy"]
@@ -179,15 +182,15 @@
 
     if lower_formatted_value == "false":
         return "False"
 
     return formatted_value
 
 
-CellMembers = dict[HierarchyCoordinates, CellSetMember]
+CellMembers = dict[HierarchyIdentifier, CellSetMember]
 
 
 def _get_cell_members_and_is_total(
     ordinal: int,
     /,
     *,
     axes: Iterable[NormalizedCellSetAxis],
@@ -199,96 +202,98 @@
 
     for axis in axes:
         if _is_slicer(axis):
             continue
 
         ordinal, position_index = divmod(ordinal, len(axis["positions"]))
         for hierarchy_index, hierarchy in enumerate(axis["hierarchies"]):
-            hierarchy_coordinates = HierarchyCoordinates(
+            hierarchy_identifier = HierarchyIdentifier(
                 hierarchy["dimension"], hierarchy["hierarchy"]
             )
             member = axis["positions"][position_index][hierarchy_index]
 
             is_total |= (
                 len(member["namePath"]) != axis["maxLevelPerHierarchy"][hierarchy_index]
             )
 
             if not keep_totals and is_total:
                 return {}, True
 
-            cell_members[hierarchy_coordinates] = (
+            cell_members[hierarchy_identifier] = (
                 member
-                if hierarchy_coordinates == _MEASURES_HIERARCHY_COORDINATES
-                or cube["dimensions"][hierarchy_coordinates.dimension_name][
+                if hierarchy_identifier == _MEASURES_HIERARCHY_IDENTIFIER
+                or cube["dimensions"][hierarchy_identifier.dimension_name][
                     "hierarchies"
-                ][hierarchy_coordinates.hierarchy_name]["slicing"]
+                ][hierarchy_identifier.hierarchy_name]["slicing"]
                 else {
                     "captionPath": member["captionPath"][1:],
                     "namePath": member["namePath"][1:],
                 }
             )
 
     return cell_members, is_total
 
 
 def _get_member_name_index(
-    levels_coordinates: Collection[LevelCoordinates],
+    level_identifiers: Collection[LevelIdentifier],
     /,
     *,
     cube_name: str,
     get_data_types: Optional[GetDataTypes],
     keep_totals: bool,
     members: Iterable[tuple[Optional[str], ...]],
 ) -> Optional[pd.Index]:
-    if not levels_coordinates:
+    if not level_identifiers:
         return None
 
-    types: dict[LevelCoordinates, DataType] = (
-        get_data_types(levels_coordinates, cube_name=cube_name)
+    types: dict[LevelIdentifier, DataType] = (
+        get_data_types(level_identifiers, cube_name=cube_name)
         if get_data_types
-        else {level_coordinates: "Object" for level_coordinates in levels_coordinates}
+        else {level_identifier: "Object" for level_identifier in level_identifiers}
     )
     index_dataframe = create_dataframe(
         members,
         [
             DataFrameColumnDescription(
-                level_coordinates.level_name,
-                types[level_coordinates],
+                level_identifier.level_name,
+                types[level_identifier],
                 nullable=keep_totals,  # A level cell can only be null if it is a total.
             )
-            for level_coordinates in levels_coordinates
+            for level_identifier in level_identifiers
         ],
     )
 
     return (
         pd.Index(index_dataframe.iloc[:, 0])
-        if len(levels_coordinates) == 1
+        if len(level_identifiers) == 1
         else pd.MultiIndex.from_frame(index_dataframe)
     )
 
 
 def _get_member_caption_index(
-    levels_coordinates: Collection[LevelCoordinates],
+    level_identifiers: Collection[LevelIdentifier],
     /,
     *,
     cube: IndexedDiscoveryCube,
     members: Iterable[tuple[Optional[str], ...]],
 ) -> Optional[pd.Index]:
-    if not levels_coordinates:
+    if not level_identifiers:
         return None
 
     level_captions = tuple(
         next(
             level["caption"]
             for level_name, level in cube["dimensions"][
-                level_coordinates.dimension_name
-            ]["hierarchies"][level_coordinates.hierarchy_name]["levels"].items()
-            if level_name == level_coordinates.level_name
+                level_identifier.hierarchy_identifier.dimension_name
+            ]["hierarchies"][level_identifier.hierarchy_identifier.hierarchy_name][
+                "levels"
+            ].items()
+            if level_name == level_identifier.level_name
         )
-        for level_coordinates in levels_coordinates
+        for level_identifier in level_identifiers
     )
 
     members_with_grand_total_caption = (
         (_GRAND_TOTAL_CAPTION,)
         if all(element is None for element in member)
         else member
         for member in members
@@ -296,48 +301,48 @@
 
     index_dataframe = pd.DataFrame(
         members_with_grand_total_caption,
         columns=level_captions,
         dtype="string",
     ).fillna("")
 
-    if len(levels_coordinates) == 1:
+    if len(level_identifiers) == 1:
         return pd.Index(index_dataframe.iloc[:, 0])
 
     return pd.MultiIndex.from_frame(index_dataframe)
 
 
 def _get_measure_values(
     measure_values: Iterable[Mapping[str, Any]],
     /,
     *,
     cube_name: str,
     get_data_types: Optional[GetDataTypes],
     index: Optional[pd.Index],
     measure_names: Collection[str],
 ) -> dict[str, Iterable[Any]]:
-    types: dict[MeasureCoordinates, DataType] = (
+    types: dict[MeasureIdentifier, DataType] = (
         get_data_types(
-            [MeasureCoordinates(measure_name) for measure_name in measure_names],
+            [MeasureIdentifier(measure_name) for measure_name in measure_names],
             cube_name=cube_name,
         )
         if get_data_types
         else {
-            MeasureCoordinates(measure_name): "Object" for measure_name in measure_names
+            MeasureIdentifier(measure_name): "Object" for measure_name in measure_names
         }
     )
 
     return {
         measure_name: convert_series(
             pd.Series(
                 [values.get(measure_name) for values in measure_values],
                 dtype="object",  # To prevent any preliminary conversion.
                 index=index,
             ),
-            data_type=types[MeasureCoordinates(measure_name)],
+            data_type=types[MeasureIdentifier(measure_name)],
             nullable=True,  # Measures are always nullable.
         )
         for measure_name in measure_names
     }
 
 
 def _get_members_path(
@@ -407,22 +412,22 @@
         if keep_totals or not is_total:
             if not default_measure:
                 raise RuntimeError(
                     "Expected a default member for measures but found none."
                 )
 
             measure = cell_members.setdefault(
-                _MEASURES_HIERARCHY_COORDINATES,
+                _MEASURES_HIERARCHY_IDENTIFIER,
                 default_measure,
             )
 
             non_measure_cell_members = tuple(
                 cell_member
                 for hierarchy, cell_member in cell_members.items()
-                if hierarchy != _MEASURES_HIERARCHY_COORDINATES
+                if hierarchy != _MEASURES_HIERARCHY_IDENTIFIER
             )
 
             member_names = _get_members_path(
                 non_measure_cell_members, property_name="namePath"
             )
             member_captions = _get_members_path(
                 non_measure_cell_members, property_name="captionPath"
@@ -444,29 +449,29 @@
                     measure["captionPath"][0]
                 ] = (
                     ""
                     if cell is None
                     else _cell_properties_to_style(cell["properties"])
                 )
 
-    levels_coordinates = _get_levels_coordinates(
+    level_identifiers = _get_level_identifiers(
         cellset["axes"],
         cube=cube,
     )
 
     member_name_index = _get_member_name_index(
-        levels_coordinates,
+        level_identifiers,
         cube_name=cellset["cube"],
         get_data_types=get_data_types,
         keep_totals=keep_totals,
         members=member_names_to_measure_values.keys(),
     )
 
     member_caption_index = _get_member_caption_index(
-        levels_coordinates,
+        level_identifiers,
         cube=cube,
         members=member_captions_to_measure_formatted_values.keys(),
     )
 
     measure_names, measure_captions = _get_measure_names_and_captions(
         cellset["axes"], default_measure=default_measure
     )
```

## atoti_query/_create_query_cubes_from_discovery.py

```diff
@@ -1,12 +1,17 @@
 from __future__ import annotations
 
 from typing import Optional
 
-from atoti_core import ImmutableMapping
+from atoti_core import (
+    HierarchyIdentifier,
+    ImmutableMapping,
+    LevelIdentifier,
+    MeasureIdentifier,
+)
 
 from ._discovery import (
     IndexedDiscovery,
     IndexedDiscoveryCube,
     IndexedDiscoveryHierarchy,
 )
 from ._execute_gaq import ExecuteGaq
@@ -22,28 +27,26 @@
 
 def _create_hierarchy(
     hierarchy: IndexedDiscoveryHierarchy,
     /,
     *,
     dimension_name: str,
 ) -> QueryHierarchy:
+    hierarchy_identifier = HierarchyIdentifier(dimension_name, hierarchy["name"])
     levels = ImmutableMapping(
         {
             level["name"]: QueryLevel(
-                level["name"],
-                dimension=dimension_name,
-                hierarchy=hierarchy["name"],
+                LevelIdentifier(hierarchy_identifier, level["name"])
             )
             for level in hierarchy["levels"].values()
             if level["type"] != "ALL"
         }
     )
     return QueryHierarchy(
-        hierarchy["name"],
-        dimension=dimension_name,
+        hierarchy_identifier,
         levels=levels,
         slicing=hierarchy["slicing"],
     )
 
 
 def _create_cube(
     cube: IndexedDiscoveryCube,
@@ -61,15 +64,15 @@
             if dimension["name"] != "Epoch"
             for hierarchy in dimension["hierarchies"].values()
         }
     )
     measures = QueryMeasures(
         {
             measure["name"]: QueryMeasure(
-                measure["name"],
+                MeasureIdentifier(measure["name"]),
                 description=measure.get("description"),
                 folder=measure.get("folder"),
                 formatter=measure.get("formatString"),
                 visible=measure["visible"],
             )
             for measure in cube["measures"].values()
         }
```

## atoti_query/_execute_gaq.py

```diff
@@ -1,24 +1,24 @@
 from collections.abc import Iterable
 from datetime import timedelta
 from typing import Optional, Protocol
 
 import pandas as pd
-from atoti_core import LevelCoordinates, MeasureCoordinates
+from atoti_core import LevelIdentifier, MeasureIdentifier
 
 from ._gaq_filter import GaqFilter
 
 
 class ExecuteGaq(Protocol):
     def __call__(
         self,
         *,
         cube_name: str,
         filter: Optional[GaqFilter] = None,  # noqa: A002
         include_empty_rows: bool,
         include_totals: bool,
-        levels_coordinates: Iterable[LevelCoordinates],
-        measures_coordinates: Iterable[MeasureCoordinates],
+        level_identifiers: Iterable[LevelIdentifier],
+        measure_identifiers: Iterable[MeasureIdentifier],
         scenario: str,
         timeout: timedelta,
     ) -> pd.DataFrame:
         ...
```

## atoti_query/_gaq_filter.py

```diff
@@ -1,12 +1,12 @@
 from __future__ import annotations
 
 from typing import Literal, Optional, Union
 
-from atoti_core import Condition, Constant, HierarchyCoordinates, LevelCoordinates
+from atoti_core import Condition, Constant, HierarchyIdentifier, LevelIdentifier
 
 GaqFilter = Condition[
-    Union[HierarchyCoordinates, LevelCoordinates],
+    Union[HierarchyIdentifier, LevelIdentifier],
     Literal["eq", "isin"],
     Constant,
     Optional[Literal["and"]],
 ]
```

## atoti_query/_generate_mdx.py

```diff
@@ -1,19 +1,19 @@
 from collections.abc import Collection, Iterable, Mapping, Sequence
 from typing import Literal, Optional
 
 from atoti_core import (
     BASE_SCENARIO_NAME,
     ComparisonCondition,
     Constant,
-    HierarchyCoordinates,
+    HierarchyIdentifier,
     HierarchyIsinCondition,
     IsinCondition,
-    LevelCoordinates,
-    MeasureCoordinates,
+    LevelIdentifier,
+    MeasureIdentifier,
     QueryFilter,
     decombine_condition,
 )
 
 from ._discovery import IndexedDiscoveryCube, IndexedDiscoveryHierarchy
 from ._hierarchy_filter import HierarchyFilter
 
@@ -27,284 +27,285 @@
 ) -> str:
     if single_element_short_syntax and len(members) == 1:
         return next(iter(members))
 
     return f"""{{{", ".join(members)}}}"""
 
 
-def _generate_columns_set(measures_coordinates: Iterable[MeasureCoordinates], /) -> str:
+def _generate_columns_set(measure_identifiers: Iterable[MeasureIdentifier], /) -> str:
     return _generate_set(
         [
-            f"[Measures].[{_escape(measure_coordinates.measure_name)}]"
-            for measure_coordinates in measures_coordinates
+            f"[Measures].[{_escape(measure_identifier.measure_name)}]"
+            for measure_identifier in measure_identifiers
         ],
         # Atoti UI 5 does not support it.
         # See https://support.activeviam.com/jira/browse/UI-5036.
         single_element_short_syntax=False,
     )
 
 
 def _keep_only_deepest_levels(
-    levels_coordinates: Iterable[LevelCoordinates],
+    level_identifiers: Iterable[LevelIdentifier],
     /,
     *,
     cube: IndexedDiscoveryCube,
-) -> dict[LevelCoordinates, int]:
-    hierarchy_to_max_level_depth: dict[HierarchyCoordinates, int] = {}
+) -> dict[LevelIdentifier, int]:
+    hierarchy_to_max_level_depth: dict[HierarchyIdentifier, int] = {}
 
-    for level_coordinates in levels_coordinates:
-        hierarchy_coordinates = level_coordinates.hierarchy_coordinates
+    for level_identifier in level_identifiers:
+        hierarchy_identifier = level_identifier.hierarchy_identifier
         current_max_level_depth = hierarchy_to_max_level_depth.get(
-            hierarchy_coordinates, -1
+            hierarchy_identifier, -1
         )
         regular_level_names = [
             level["name"]
-            for level in cube["dimensions"][hierarchy_coordinates.dimension_name][
+            for level in cube["dimensions"][hierarchy_identifier.dimension_name][
                 "hierarchies"
-            ][hierarchy_coordinates.hierarchy_name]["levels"].values()
+            ][hierarchy_identifier.hierarchy_name]["levels"].values()
         ]
-        level_depth = regular_level_names.index(level_coordinates.level_name)
+        level_depth = regular_level_names.index(level_identifier.level_name)
 
         if level_depth > current_max_level_depth:
-            hierarchy_to_max_level_depth[hierarchy_coordinates] = level_depth
+            hierarchy_to_max_level_depth[hierarchy_identifier] = level_depth
 
     return {
-        LevelCoordinates(
-            hierarchy_coordinates.dimension_name,
-            hierarchy_coordinates.hierarchy_name,
+        LevelIdentifier(
+            hierarchy_identifier,
             list(
-                cube["dimensions"][hierarchy_coordinates.dimension_name]["hierarchies"][
-                    hierarchy_coordinates.hierarchy_name
+                cube["dimensions"][hierarchy_identifier.dimension_name]["hierarchies"][
+                    hierarchy_identifier.hierarchy_name
                 ]["levels"]
             )[depth],
         ): depth
-        for hierarchy_coordinates, depth in hierarchy_to_max_level_depth.items()
+        for hierarchy_identifier, depth in hierarchy_to_max_level_depth.items()
     }
 
 
 def _get_first_level(hierarchy: IndexedDiscoveryHierarchy, /) -> str:
     return next(iter(hierarchy["levels"])) if hierarchy["slicing"] else "ALL"
 
 
 def _generate_hierarchy_unique_name(
-    hierarchy_coordinates: HierarchyCoordinates,
+    hierarchy_identifier: HierarchyIdentifier,
     /,
     *,
     cube: IndexedDiscoveryCube,
     include_first_level: bool = False,
 ) -> str:
-    parts = [hierarchy_coordinates.dimension_name, hierarchy_coordinates.hierarchy_name]
+    parts = [hierarchy_identifier.dimension_name, hierarchy_identifier.hierarchy_name]
 
     if include_first_level:
-        hierarchy = cube["dimensions"][hierarchy_coordinates.dimension_name][
+        hierarchy = cube["dimensions"][hierarchy_identifier.dimension_name][
             "hierarchies"
-        ][hierarchy_coordinates.hierarchy_name]
+        ][hierarchy_identifier.hierarchy_name]
         parts.append(_get_first_level(hierarchy))
 
     return ".".join(f"[{_escape(part)}]" for part in parts)
 
 
 def _generate_level_set(
-    level_coordinates: LevelCoordinates,
+    level_identifier: LevelIdentifier,
     /,
     *,
     cube: IndexedDiscoveryCube,
     include_totals: bool,
     level_depth: int,
 ) -> str:
-    hierarchy = cube["dimensions"][level_coordinates.dimension_name]["hierarchies"][
-        level_coordinates.hierarchy_name
-    ]
+    hierarchy = cube["dimensions"][
+        level_identifier.hierarchy_identifier.dimension_name
+    ]["hierarchies"][level_identifier.hierarchy_identifier.hierarchy_name]
     return (
-        f"{_generate_hierarchy_unique_name(level_coordinates.hierarchy_coordinates, cube=cube)}.[{_escape(level_coordinates.level_name)}].Members"
+        f"{_generate_hierarchy_unique_name(level_identifier.hierarchy_identifier, cube=cube)}.[{_escape(level_identifier.level_name)}].Members"
         if hierarchy["slicing"] or not include_totals
-        else f"Hierarchize(Descendants({{{_generate_hierarchy_unique_name(level_coordinates.hierarchy_coordinates, cube=cube, include_first_level=True)}.[AllMember]}}, {level_depth}, SELF_AND_BEFORE))"
+        else f"Hierarchize(Descendants({{{_generate_hierarchy_unique_name(level_identifier.hierarchy_identifier, cube=cube, include_first_level=True)}.[AllMember]}}, {level_depth}, SELF_AND_BEFORE))"
     )
 
 
 def _generate_rows_set(
-    levels_coordinates: Mapping[LevelCoordinates, int],
+    level_identifiers: Mapping[LevelIdentifier, int],
     /,
     *,
     cube: IndexedDiscoveryCube,
     include_totals: bool,
 ) -> str:
-    if len(levels_coordinates) == 1:
-        level_coordinates, level_depth = next(iter(levels_coordinates.items()))
+    if len(level_identifiers) == 1:
+        level_identifier, level_depth = next(iter(level_identifiers.items()))
         return _generate_level_set(
-            level_coordinates,
+            level_identifier,
             cube=cube,
             include_totals=include_totals,
             level_depth=level_depth,
         )
 
     return f"""Crossjoin({", ".join(
         [
-            _generate_level_set(level_coordinates, cube=cube,include_totals=include_totals, level_depth=level_depth)
-            for level_coordinates, level_depth in levels_coordinates.items()
+            _generate_level_set(level_identifier, cube=cube,include_totals=include_totals, level_depth=level_depth)
+            for level_identifier, level_depth in level_identifiers.items()
         ]
     )})"""
 
 
 def _ensure_condition_on_shallowest_level(
-    level_coordinates: LevelCoordinates,
+    level_identifier: LevelIdentifier,
     /,
     *,
     cube: IndexedDiscoveryCube,
 ) -> None:
     if (
         next(
             level["name"]
-            for level in cube["dimensions"][level_coordinates.dimension_name][
-                "hierarchies"
-            ][level_coordinates.hierarchy_name]["levels"].values()
+            for level in cube["dimensions"][
+                level_identifier.hierarchy_identifier.dimension_name
+            ]["hierarchies"][level_identifier.hierarchy_identifier.hierarchy_name][
+                "levels"
+            ].values()
             if level["type"] != "ALL"
         )
-        != level_coordinates.level_name
+        != level_identifier.level_name
     ):
         raise (
             ValueError(
-                f"Only conditions based on the shallowest level of a hierarchy are supported but level {level_coordinates} was given."
+                f"Only conditions based on the shallowest level of a hierarchy are supported but level {level_identifier} was given."
             )
         )
 
 
-def _generate_hierarchy_coordinates_to_filter(
+def _generate_hierarchy_identifier_to_filter(
     *,
     comparison_conditions: Iterable[
-        ComparisonCondition[LevelCoordinates, Literal["eq", "ne"], Constant]
+        ComparisonCondition[LevelIdentifier, Literal["eq", "ne"], Constant]
     ],
     cube: IndexedDiscoveryCube,
     hierarchy_isin_conditions: Iterable[HierarchyIsinCondition],
-    isin_conditions: Iterable[IsinCondition[LevelCoordinates, Constant]],
-) -> dict[HierarchyCoordinates, HierarchyFilter]:
-    hierarchy_coordinates_to_filter: dict[HierarchyCoordinates, HierarchyFilter] = {}
+    isin_conditions: Iterable[IsinCondition[LevelIdentifier, Constant]],
+) -> dict[HierarchyIdentifier, HierarchyFilter]:
+    hierarchy_identifier_to_filter: dict[HierarchyIdentifier, HierarchyFilter] = {}
 
     def add_hierarchy_filter(
         hierarchy_filter: HierarchyFilter,
         /,
         *,
-        hierarchy_coordinates: HierarchyCoordinates,
+        hierarchy_identifier: HierarchyIdentifier,
     ) -> None:
-        existing_filter = hierarchy_coordinates_to_filter.get(hierarchy_coordinates)
+        existing_filter = hierarchy_identifier_to_filter.get(hierarchy_identifier)
 
-        hierarchy_coordinates_to_filter[hierarchy_coordinates] = (
+        hierarchy_identifier_to_filter[hierarchy_identifier] = (
             existing_filter & hierarchy_filter if existing_filter else hierarchy_filter
         )
 
     for comparison_condition in comparison_conditions:
         _ensure_condition_on_shallowest_level(comparison_condition.subject, cube=cube)
 
         add_hierarchy_filter(
             HierarchyFilter(
                 exclusion=comparison_condition.operator == "ne",
                 member_paths=[(comparison_condition.target,)],
             ),
-            hierarchy_coordinates=comparison_condition.subject.hierarchy_coordinates,
+            hierarchy_identifier=comparison_condition.subject.hierarchy_identifier,
         )
 
     for isin_condition in isin_conditions:
         _ensure_condition_on_shallowest_level(isin_condition.subject, cube=cube)
 
         add_hierarchy_filter(
             HierarchyFilter(
                 member_paths=[(member,) for member in isin_condition.elements],
             ),
-            hierarchy_coordinates=isin_condition.subject.hierarchy_coordinates,
+            hierarchy_identifier=isin_condition.subject.hierarchy_identifier,
         )
 
     for hierarchy_isin_condition in hierarchy_isin_conditions:
         add_hierarchy_filter(
             HierarchyFilter(
                 member_paths=hierarchy_isin_condition.member_paths,
             ),
-            hierarchy_coordinates=hierarchy_isin_condition.subject,
+            hierarchy_identifier=hierarchy_isin_condition.subject,
         )
 
-    return hierarchy_coordinates_to_filter
+    return hierarchy_identifier_to_filter
 
 
 def _generate_member_unique_name(
     member_path: Iterable[Constant],
     /,
     *,
     cube: IndexedDiscoveryCube,
-    hierarchy_coordinates: HierarchyCoordinates,
+    hierarchy_identifier: HierarchyIdentifier,
 ) -> str:
-    hierarchy = cube["dimensions"][hierarchy_coordinates.dimension_name]["hierarchies"][
-        hierarchy_coordinates.hierarchy_name
+    hierarchy = cube["dimensions"][hierarchy_identifier.dimension_name]["hierarchies"][
+        hierarchy_identifier.hierarchy_name
     ]
     parts = [
         _generate_hierarchy_unique_name(
-            hierarchy_coordinates, cube=cube, include_first_level=True
+            hierarchy_identifier, cube=cube, include_first_level=True
         )
     ]
 
     if not hierarchy["slicing"]:
         parts.append("[AllMember]")
 
     for member in member_path:
         value = member.value
         if not isinstance(value, str):
             raise (
                 TypeError(
-                    f"Only conditions against strings are supported but `{hierarchy_coordinates}` was compared against `{value}` of type `{type(value)}`."
+                    f"Only conditions against strings are supported but `{hierarchy_identifier}` was compared against `{value}` of type `{type(value)}`."
                 )
             )
 
         parts.append(f"[{_escape(value)}]")
 
     return ".".join(parts)
 
 
 def _generate_filter(
     hierarchy_filter: HierarchyFilter,
     /,
     *,
     cube: IndexedDiscoveryCube,
-    hierarchy_coordinates: HierarchyCoordinates,
+    hierarchy_identifier: HierarchyIdentifier,
 ) -> str:
     filter_set = _generate_set(
         [
             _generate_member_unique_name(
-                member_path, cube=cube, hierarchy_coordinates=hierarchy_coordinates
+                member_path, cube=cube, hierarchy_identifier=hierarchy_identifier
             )
             for member_path in hierarchy_filter.member_paths
         ]
     )
 
     return (
-        f"Except({_generate_hierarchy_unique_name(hierarchy_coordinates, cube=cube)}.Members,{filter_set})"
+        f"Except({_generate_hierarchy_unique_name(hierarchy_identifier, cube=cube)}.Members,{filter_set})"
         if hierarchy_filter.exclusion
         else filter_set
     )
 
 
 def _generate_filters(
-    hierarchy_coordinates_to_filter: Mapping[HierarchyCoordinates, HierarchyFilter],
+    hierarchy_identifier_to_filter: Mapping[HierarchyIdentifier, HierarchyFilter],
     /,
     *,
     cube: IndexedDiscoveryCube,
     scenario_name: str,
 ) -> list[str]:
     filters = [
         _generate_filter(
             hierarchy_filter,
             cube=cube,
-            hierarchy_coordinates=hierarchy_coordinates,
+            hierarchy_identifier=hierarchy_identifier,
         )
-        for hierarchy_coordinates, hierarchy_filter in hierarchy_coordinates_to_filter.items()
+        for hierarchy_identifier, hierarchy_filter in hierarchy_identifier_to_filter.items()
     ]
 
     if scenario_name != BASE_SCENARIO_NAME:
         filters.append(
             _generate_member_unique_name(
                 [Constant(scenario_name)],
                 cube=cube,
-                hierarchy_coordinates=HierarchyCoordinates("Epoch", "Epoch"),
+                hierarchy_identifier=HierarchyIdentifier("Epoch", "Epoch"),
             )
         )
 
     return filters
 
 
 def _generate_from_clause(
@@ -320,82 +321,82 @@
 
     return f"FROM (SELECT {filters[-1]} ON COLUMNS {_generate_from_clause(filters[0:-1], cube=cube)})"
 
 
 def _generate_mdx_with_decombined_conditions(
     *,
     comparison_conditions: Iterable[
-        ComparisonCondition[LevelCoordinates, Literal["eq", "ne"], Constant]
+        ComparisonCondition[LevelIdentifier, Literal["eq", "ne"], Constant]
     ] = (),
     cube: IndexedDiscoveryCube,
     hierarchy_isin_conditions: Iterable[HierarchyIsinCondition] = (),
     include_empty_rows: bool = False,
     include_totals: bool = False,
-    isin_conditions: Iterable[IsinCondition[LevelCoordinates, Constant]] = (),
-    levels_coordinates: Iterable[LevelCoordinates],
-    measures_coordinates: Iterable[MeasureCoordinates],
+    isin_conditions: Iterable[IsinCondition[LevelIdentifier, Constant]] = (),
+    level_identifiers: Iterable[LevelIdentifier],
+    measure_identifiers: Iterable[MeasureIdentifier],
     scenario_name: str,
 ) -> str:
-    mdx = f"SELECT {_generate_columns_set(measures_coordinates)} ON COLUMNS"
+    mdx = f"SELECT {_generate_columns_set(measure_identifiers)} ON COLUMNS"
 
-    deepest_levels = _keep_only_deepest_levels(levels_coordinates, cube=cube)
+    deepest_levels = _keep_only_deepest_levels(level_identifiers, cube=cube)
 
     if deepest_levels:
         mdx = f"{mdx}, {'' if include_empty_rows else 'NON EMPTY '}{_generate_rows_set(deepest_levels, cube=cube, include_totals=include_totals)} ON ROWS"
 
-    hierarchy_coordinates_to_filter = _generate_hierarchy_coordinates_to_filter(
+    hierarchy_identifier_to_filter = _generate_hierarchy_identifier_to_filter(
         comparison_conditions=comparison_conditions,
         cube=cube,
         hierarchy_isin_conditions=hierarchy_isin_conditions,
         isin_conditions=isin_conditions,
     )
 
     filters = _generate_filters(
-        hierarchy_coordinates_to_filter,
+        hierarchy_identifier_to_filter,
         cube=cube,
         scenario_name=scenario_name,
     )
 
     return f"{mdx} {_generate_from_clause(filters, cube=cube)}"
 
 
 def generate_mdx(
     *,
     cube: IndexedDiscoveryCube,
     filter: Optional[QueryFilter] = None,  # noqa: A002
     include_empty_rows: bool = False,
     include_totals: bool = False,
-    levels_coordinates: Iterable[LevelCoordinates] = (),
-    measures_coordinates: Iterable[MeasureCoordinates] = (),
+    level_identifiers: Iterable[LevelIdentifier] = (),
+    measure_identifiers: Iterable[MeasureIdentifier] = (),
     scenario: str = BASE_SCENARIO_NAME,
 ) -> str:
     """Return the corresponding MDX query.
 
     The value of the measures is given on all the members of the given levels.
     If no level is specified then the value at the top level is returned.
     """
     allowed_comparison_operators: tuple[Literal["eq", "ne"], ...] = ("eq", "ne")
 
     comparison_conditions, isin_conditions, hierarchy_isin_conditions = (
         ((), (), ())
         if filter is None
         else decombine_condition(
             filter,
-            allowed_subject_types=(LevelCoordinates,),
+            allowed_subject_types=(LevelIdentifier,),
             allowed_comparison_operators=allowed_comparison_operators,
             allowed_target_types=(Constant,),
             allowed_combination_operators=("and",),
             allowed_isin_element_types=(Constant,),
         )[0]
     )
 
     return _generate_mdx_with_decombined_conditions(
         comparison_conditions=comparison_conditions,
         cube=cube,
         hierarchy_isin_conditions=hierarchy_isin_conditions,
         include_empty_rows=include_empty_rows,
         include_totals=include_totals,
         isin_conditions=isin_conditions,
-        levels_coordinates=levels_coordinates,
-        measures_coordinates=measures_coordinates,
+        level_identifiers=level_identifiers,
+        measure_identifiers=measure_identifiers,
         scenario_name=scenario,
     )
```

## atoti_query/_get_data_types.py

```diff
@@ -1,11 +1,11 @@
 from collections.abc import Iterable
 from typing import Protocol
 
-from atoti_core import CoordinatesT, DataType
+from atoti_core import DataType, IdentifierT
 
 
 class GetDataTypes(Protocol):
     def __call__(
-        self, coordinates: Iterable[CoordinatesT], /, *, cube_name: str
-    ) -> dict[CoordinatesT, DataType]:
+        self, identifier: Iterable[IdentifierT], /, *, cube_name: str
+    ) -> dict[IdentifierT, DataType]:
         ...
```

## atoti_query/query_cube.py

```diff
@@ -67,41 +67,41 @@
         mode: Literal["pretty", "raw"] = "pretty",
         scenario: str = BASE_SCENARIO_NAME,
         timeout: timedelta = DEFAULT_QUERY_TIMEOUT,
         **kwargs: Any,
     ) -> pd.DataFrame:
         query_private_parameters = QueryPrivateParameters(**kwargs)
 
-        levels_coordinates = [level._coordinates for level in levels]
-        measures_coordinates = [measure._coordinates for measure in measures]
+        level_identifiers = [level._identifier for level in levels]
+        measure_identifiers = [measure._identifier for measure in measures]
 
         if (
             mode == "raw"
             and self._execute_gaq
             and not context
             and (filter is None or is_gaq_filter(filter))
         ):
             return self._execute_gaq(
                 cube_name=self.name,
                 filter=filter,
                 include_empty_rows=include_empty_rows,
                 include_totals=include_totals,
-                levels_coordinates=levels_coordinates,
-                measures_coordinates=measures_coordinates,
+                level_identifiers=level_identifiers,
+                measure_identifiers=measure_identifiers,
                 scenario=scenario,
                 timeout=timeout,
             )
 
         mdx = generate_mdx(
             cube=self._cube,
             filter=filter,
             include_empty_rows=include_empty_rows,
             include_totals=include_totals,
-            levels_coordinates=levels_coordinates,
-            measures_coordinates=measures_coordinates,
+            level_identifiers=level_identifiers,
+            measure_identifiers=measure_identifiers,
             scenario=scenario,
         )
 
         query_result = self._query_mdx(
             mdx,
             context=context,
             get_data_types=query_private_parameters.get_data_types,
@@ -118,16 +118,16 @@
         ):
             query_result._atoti_widget_conversion_details = WidgetConversionDetails(
                 mdx=generate_mdx(
                     cube=self._cube,
                     filter=filter,
                     include_empty_rows=include_empty_rows,
                     include_totals=True,
-                    levels_coordinates=levels_coordinates,
-                    measures_coordinates=measures_coordinates,
+                    level_identifiers=level_identifiers,
+                    measure_identifiers=measure_identifiers,
                     scenario=scenario,
                 ),
                 session_id=query_result._atoti_widget_conversion_details.session_id,
                 widget_creation_code=query_result._atoti_widget_conversion_details.widget_creation_code,
             )
 
         return query_result
```

## atoti_query/query_hierarchy.py

```diff
@@ -1,44 +1,33 @@
 from collections.abc import Mapping
 
-from atoti_core import BaseHierarchy
+from atoti_core import BaseHierarchy, HierarchyIdentifier
 
 from .query_level import QueryLevel
 
 
 class QueryHierarchy(BaseHierarchy[QueryLevel]):
     def __init__(
         self,
-        name: str,
+        identifier: HierarchyIdentifier,
         /,
         *,
-        dimension: str,
         levels: Mapping[str, QueryLevel],
         slicing: bool,
     ) -> None:
-        super().__init__(name, dimension=dimension)
+        super().__init__(identifier)
 
         self._levels = levels
         self._slicing = slicing
 
     @property
     def levels(self) -> Mapping[str, QueryLevel]:
         """Levels of the hierarchy."""
         return self._levels
 
     @property
-    def dimension(self) -> str:
-        """Dimension of the hierarchy."""
-        return self._dimension
-
-    @property
     def slicing(self) -> bool:
         """Whether the hierarchy is slicing or not."""
         return self._slicing
 
-    @property
-    def name(self) -> str:
-        """Name of the hierarchy."""
-        return self._name
-
     def __getitem__(self, key: str, /) -> QueryLevel:
         return self.levels[key]
```

## atoti_query/query_level.py

```diff
@@ -1,29 +1,13 @@
 from __future__ import annotations
 
 from atoti_core import BaseLevel, ReprJson
 
 
 class QueryLevel(BaseLevel):
-    def __init__(self, name: str, /, *, dimension: str, hierarchy: str) -> None:
-        super().__init__(name)
-
-        self._dimension = dimension
-        self._hierarchy = hierarchy
-
-    @property
-    def dimension(self) -> str:
-        """Dimension of the level."""
-        return self._dimension
-
-    @property
-    def hierarchy(self) -> str:
-        """Hierarchy of the level."""
-        return self._hierarchy
-
     def _repr_json_(self) -> ReprJson:
         data = {
             "dimension": self.dimension,
             "hierarchy": self.hierarchy,
         }
         return (
             data,
```

## atoti_query/query_measure.py

```diff
@@ -1,24 +1,24 @@
 from typing import Optional
 
-from atoti_core import BaseMeasure
+from atoti_core import BaseMeasure, MeasureIdentifier
 
 
 class QueryMeasure(BaseMeasure):
     def __init__(
         self,
-        name: str,
+        identifier: MeasureIdentifier,
         /,
         *,
         description: Optional[str],
         folder: Optional[str],
         formatter: Optional[str],
         visible: bool,
     ) -> None:
-        super().__init__(name)
+        super().__init__(identifier)
 
         self._description = description
         self._folder = folder
         self._formatter = formatter
         self._visible = visible
 
     @property
```

## atoti_query/query_result.py

```diff
@@ -1,15 +1,15 @@
 from __future__ import annotations
 
 import logging
 from collections.abc import Callable
 from typing import TYPE_CHECKING, Any, Optional
 
 import pandas as pd
-from atoti_core import Context
+from atoti_core import HTML_MIME_TYPE, TEXT_MIME_TYPE, Context
 from typeguard import typeguard_ignore
 
 from ._widget_conversion_details import (
     CONVERT_QUERY_RESULT_TO_WIDGET_MIME_TYPE,
     WidgetConversionDetails,
 )
 
@@ -27,24 +27,24 @@
         Unless mutated in place, the ``__repr__()``, ``_repr_html_()``, ``_repr_latex_()``, and ``_repr_mimebundle_()`` methods will use:
 
         * The caption of levels and members instead of their name.
         * The formatted value of measures instead of their value.
     """
 
     # See https://pandas.pydata.org/pandas-docs/stable/development/extending.html#define-original-properties
-    _internal_names = [
+    _internal_names = [  # noqa: RUF012
         *pd.DataFrame._internal_names,  # type: ignore[attr-defined] # pyright: ignore[reportGeneralTypeIssues]
         "_atoti_context",
         "_atoti_formatted_values",
         "_atoti_get_styler",
         "_atoti_has_been_mutated",
         "_atoti_initial_dataframe",
         "_atoti_widget_conversion_details",
     ]
-    _internal_names_set = set(_internal_names)
+    _internal_names_set = set(_internal_names)  # noqa: RUF012
 
     @typeguard_ignore
     def __init__(
         self,
         # pandas does not expose the types of these arguments.
         data: Any = None,
         index: Any = None,
@@ -99,41 +99,41 @@
         return self._atoti_repr(has_been_mutated=self._has_been_mutated())
 
     def _atoti_repr_html(self, *, has_been_mutated: bool) -> str:
         dataframe_to_repr = self._get_dataframe_to_repr(
             has_been_mutated=has_been_mutated
         )
         # `pandas-stubs` lacks the `_repr_html_` method.
-        html: str = dataframe_to_repr._repr_html_()  # type: ignore[operator]
+        html: str = dataframe_to_repr._repr_html_()  # type: ignore[operator] # pyright: ignore[reportGeneralTypeIssues]
         return html
 
     def _repr_html_(self) -> str:
         return self._atoti_repr_html(has_been_mutated=self._has_been_mutated())
 
     def _atoti_repr_latex(self, *, has_been_mutated: bool) -> str:
         dataframe_to_repr = self._get_dataframe_to_repr(
             has_been_mutated=has_been_mutated
         )
         # `pandas-stubs` lacks the `_repr_latex_` method.
-        latex: str = dataframe_to_repr._repr_latex_()  # type: ignore[operator]
+        latex: str = dataframe_to_repr._repr_latex_()  # type: ignore[operator] # pyright: ignore[reportGeneralTypeIssues]
         return latex
 
     def _repr_latex_(self) -> str:
         return self._atoti_repr_latex(has_been_mutated=self._has_been_mutated())
 
     def _repr_mimebundle_(
         self,
         include: object,  # noqa: ARG002
         exclude: object,  # noqa: ARG002
     ) -> dict[str, object]:
         has_been_mutated = self._has_been_mutated()
 
         mimebundle: dict[str, object] = {
-            "text/html": self._atoti_repr_html(has_been_mutated=has_been_mutated),
-            "text/plain": self._atoti_repr(has_been_mutated=has_been_mutated),
+            HTML_MIME_TYPE: self._atoti_repr_html(has_been_mutated=has_been_mutated),
+            TEXT_MIME_TYPE: self._atoti_repr(has_been_mutated=has_been_mutated),
         }
 
         if self._atoti_widget_conversion_details and not self._has_been_mutated():
             mimebundle[CONVERT_QUERY_RESULT_TO_WIDGET_MIME_TYPE] = {
                 "mdx": self._atoti_widget_conversion_details.mdx,
                 "sessionId": self._atoti_widget_conversion_details.session_id,
                 "widgetCreationCode": self._atoti_widget_conversion_details.widget_creation_code,
```

## atoti_query/query_session.py

```diff
@@ -14,16 +14,16 @@
     PLUGINS,
     ActiveViamClient,
     BaseSession,
     BaseSessionBound,
     Constant,
     Context,
     HierarchyIsinCondition,
-    LevelCoordinates,
-    MeasureCoordinates,
+    LevelIdentifier,
+    MeasureIdentifier,
     Plugin,
     QueryFilter,
     decombine_condition,
     doc,
     keyword_only_dataclass,
 )
 
@@ -47,15 +47,15 @@
 def _serialize_condition(condition: QueryFilter) -> dict[str, Any]:
     (
         level_conditions,
         level_isin_conditions,
         hierarchy_isin_conditions,
     ) = decombine_condition(
         condition,
-        allowed_subject_types=(LevelCoordinates,),
+        allowed_subject_types=(LevelIdentifier,),
         allowed_comparison_operators=("eq",),
         allowed_target_types=(Constant,),
         allowed_combination_operators=("and",),
         allowed_isin_element_types=(Constant,),
     )[
         0
     ]
@@ -212,15 +212,15 @@
         return self._client.url
 
     @property
     def _client(self) -> ActiveViamClient:
         return self.__client
 
     @property
-    def _location(self) -> Mapping[str, Any]:
+    def _location(self) -> Mapping[str, object]:
         return {"url": self.url}
 
     @property
     def _local_url(self) -> str:
         return self.url
 
     def _execute_arrow_query(
@@ -261,16 +261,16 @@
     def _execute_gaq(
         self,
         *,
         cube_name: str,
         filter: Optional[QueryFilter] = None,  # noqa: A002
         include_empty_rows: bool,
         include_totals: bool,
-        levels_coordinates: Iterable[LevelCoordinates],
-        measures_coordinates: Iterable[MeasureCoordinates],
+        level_identifiers: Iterable[LevelIdentifier],
+        measure_identifiers: Iterable[MeasureIdentifier],
         scenario: str,
         timeout: timedelta,
     ) -> pd.DataFrame:
         if include_empty_rows:
             raise NotImplementedError(
                 "Empty rows cannot be included with this query mode."
             )
@@ -278,20 +278,20 @@
         if include_totals:
             raise NotImplementedError("Totals cannot be included with this query mode.")
 
         body = {
             "cubeName": cube_name,
             "branch": scenario,
             "measures": [
-                measure_coordinates.measure_name
-                for measure_coordinates in measures_coordinates
+                measure_identifier.measure_name
+                for measure_identifier in measure_identifiers
             ],
             "levelCoordinates": [
-                level_coordinates.java_description
-                for level_coordinates in levels_coordinates
+                level_identifier.java_description
+                for level_identifier in level_identifiers
             ],
             **(
                 {"equalConditions": {}, "isinConditions": {}, "neConditions": {}}
                 if filter is None
                 else _serialize_condition(filter)
             ),
             "timeout": ceil(timeout.total_seconds()),
```

## atoti_query/security/_content_client.py

```diff
@@ -33,15 +33,17 @@
     content: str
 
 
 ContentEntry = Union[_DirectoryContentEntry, _FileContentEntry]
 
 
 class _DirectoryContentTreeOptionalProperties(TypedDict, total=False):
-    children: Mapping[str, ContentTree]  # Missing when there are no children.
+    # Pyright does not support recursive types.
+    children: Mapping[str, ContentTree]  # pyright: ignore[reportUndefinedVariable]
+    """Missing when there are no children."""
 
 
 class _DirectoryContentTree(_DirectoryContentTreeOptionalProperties):
     entry: _DirectoryContentEntry
 
 
 class _FileContentTree(TypedDict):
```

## atoti_query/security/_restriction.py

```diff
@@ -1,12 +1,12 @@
 from __future__ import annotations
 
 from typing import Literal, Optional
 
-from atoti_core import ColumnCoordinates, Condition, Constant
+from atoti_core import ColumnIdentifier, Condition, Constant
 
 Restriction = Condition[
-    ColumnCoordinates,
+    ColumnIdentifier,
     Literal["eq", "isin"],
     Constant,
     Optional[Literal["and"]],
 ]
```

## atoti_query/security/_restriction_from_mapping.py

```diff
@@ -1,21 +1,27 @@
 from __future__ import annotations
 
 from collections.abc import Mapping, Sequence
 
-from atoti_core import ColumnCoordinates, Constant, IsinCondition, combine_conditions
+from atoti_core import (
+    ColumnIdentifier,
+    Constant,
+    IsinCondition,
+    TableIdentifier,
+    combine_conditions,
+)
 
 from ._restriction import Restriction
 
 
 def restriction_from_mapping(
     restriction: Mapping[str, Mapping[str, Sequence[str]]], /
 ) -> Restriction:
     conditions = [
-        IsinCondition[ColumnCoordinates, Constant](
-            subject=ColumnCoordinates(table_name, column_name),
+        IsinCondition[ColumnIdentifier, Constant](
+            subject=ColumnIdentifier(TableIdentifier(table_name), column_name),
             elements=tuple(Constant(element) for element in elements),
         ).normalized
         for table_name, column_restriction in restriction.items()
         for column_name, elements in column_restriction.items()
     ]
     return combine_conditions((conditions,))
```

## atoti_query/security/_restriction_to_dict.py

```diff
@@ -1,10 +1,10 @@
 from __future__ import annotations
 
-from atoti_core import ColumnCoordinates, Constant, decombine_condition
+from atoti_core import ColumnIdentifier, Constant, decombine_condition
 
 from ._restriction import Restriction
 
 
 def _get_restricted_element(constant: Constant, /) -> str:
     value = constant.value
 
@@ -17,25 +17,25 @@
 
 
 def restriction_to_dict(restriction: Restriction, /) -> dict[str, dict[str, list[str]]]:
     result: dict[str, dict[str, list[str]]] = {}
 
     comparison_conditions, isin_conditions, _ = decombine_condition(
         restriction,
-        allowed_subject_types=(ColumnCoordinates,),
+        allowed_subject_types=(ColumnIdentifier,),
         allowed_comparison_operators=("eq",),
         allowed_target_types=(Constant,),
         allowed_combination_operators=("and",),
         allowed_isin_element_types=(Constant,),
     )[0]
 
     for comparison_condition in comparison_conditions:
-        result.setdefault(comparison_condition.subject.table_name, {})[
+        result.setdefault(comparison_condition.subject.table_identifier.table_name, {})[
             comparison_condition.subject.column_name
         ] = [_get_restricted_element(comparison_condition.target)]
 
     for isin_condition in isin_conditions:
-        result.setdefault(isin_condition.subject.table_name, {})[
+        result.setdefault(isin_condition.subject.table_identifier.table_name, {})[
             isin_condition.subject.column_name
         ] = [_get_restricted_element(element) for element in isin_condition.elements]
 
     return result
```

## Comparing `atoti_query/_parse_level_coordinates.py` & `atoti_query/_parse_level_identifier.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,24 +1,23 @@
 import re
 from typing import Optional
 
-from atoti_core import LevelCoordinates
+from atoti_core import HierarchyIdentifier, LevelIdentifier
 
 _LEVEL_UNIQUE_NAME_PATTERN = re.compile(
     r"^\[(?P<dimension>.*)\]\.\[(?P<hierarchy>.*)\]\.\[(?P<level>.*)\]$"
 )
 
 
-def parse_level_coordinates(
+def parse_level_identifier(
     level_unique_name: str,
-) -> Optional[LevelCoordinates]:
+) -> Optional[LevelIdentifier]:
     match = _LEVEL_UNIQUE_NAME_PATTERN.match(level_unique_name)
 
     return (
-        LevelCoordinates(
-            match.group("dimension"),
-            match.group("hierarchy"),
+        LevelIdentifier(
+            HierarchyIdentifier(match.group("dimension"), match.group("hierarchy")),
             match.group("level"),
         )
         if match
         else None
     )
```

## Comparing `atoti_query-0.8.1.dist-info/METADATA` & `atoti_query-0.8.2.dist-info/METADATA`

 * *Files 8% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 Metadata-Version: 2.1
 Name: atoti-query
-Version: 0.8.1
+Version: 0.8.2
 Summary: Package to query Atoti sessions.
 Home-page: https://www.atoti.io
 Author: ActiveViam
 Author-email: dev@atoti.io
-Project-URL: Documentation, https://docs.atoti.io/0.8.1/lib/atoti-query/atoti_query.html
+Project-URL: Documentation, https://docs.atoti.io/0.8.2/lib/atoti-query/atoti_query.html
 Project-URL: Bug Tracker, https://github.com/atoti/atoti/issues
 Keywords: atoti,query
 Classifier: Development Status :: 4 - Beta
 Classifier: License :: Free To Use But Restricted
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python :: 3
 Classifier: Typing :: Typed
-Requires-Dist: atoti-core (==0.8.1)
+Requires-Dist: atoti-core (==0.8.2)
 Requires-Dist: pandas
 Requires-Dist: pyarrow (>=11.0.0)
 Requires-Dist: typeguard (<3,>=2.13.3)
 Requires-Dist: typing-extensions
 Provides-Extra: dev
 Requires-Dist: atoti ; extra == 'dev'
 Requires-Dist: premailer ; extra == 'dev'
```

## Comparing `atoti_query-0.8.1.dist-info/RECORD` & `atoti_query-0.8.2.dist-info/RECORD`

 * *Files 7% similar despite different names*

```diff
@@ -1,62 +1,62 @@
-atoti_query/LICENSE,sha256=4jO4tBGuaf1seZk3ces3swwK45eg_VUFxtDjY5ivqNo,23472
+atoti_query/LICENSE,sha256=JSyRUznwhVW6jj2RsFMZDaY_2QEQFMMOlbJvTy8OgOk,23472
 atoti_query/__init__.py,sha256=nlKOuGwPpZjqAyzppFyoGObKuzwJ72BcKKBYZsWxbP8,701
-atoti_query/_arrow_to_pandas.py,sha256=avX5Ilx4PCWzh2CtuVCRMrpQU6PAmakZNL46YStpm4o,1396
-atoti_query/_cellset.py,sha256=iZ0DBg2TISNxCD6F-gMOm20lrV-CsInejXoO37_owcQ,1551
-atoti_query/_cellset_to_query_result.py,sha256=2yv66wgv81cvqe7VACD3d8ekxmLrcGYdPoVkbRqG9qA,16443
-atoti_query/_create_query_cubes_from_discovery.py,sha256=uFFjeIXlsqt47c0Wz3NEOELw6q-xWfegBs5r2xfnwCQ,2734
+atoti_query/_arrow_to_pandas.py,sha256=7znZL4BF0SAqHDHvYIM25DFVJ9maARtC8b4g_WTecQY,1380
+atoti_query/_cellset.py,sha256=31VjRBClRi1hJNILVBI0ukBqsMDSjvuIjVspjwpEYxA,1537
+atoti_query/_cellset_to_query_result.py,sha256=mIHCUOROlBfxjcWUd6fsDkd0zk1FnbuPonM_rOVTO_8,16523
+atoti_query/_create_query_cubes_from_discovery.py,sha256=DPebYApqK1hjn5lxsTOcggHAHvj4r_e0CspZZQLwHeU,2833
 atoti_query/_discovery.py,sha256=74zt9CSuHqlpTKAcvByB2cb12SGFvV0DsSip_MxL_3c,1800
-atoti_query/_execute_gaq.py,sha256=prt1BzGfqzMRvCV_-q0ob2e2xfXKsYlc-6nJFlQqiCg,644
-atoti_query/_gaq_filter.py,sha256=Y1CgSp6A6L5T7bg97k2AmUZzAlRGXFTZaHxX7c0-frA,312
-atoti_query/_generate_mdx.py,sha256=dQLOmMwcS5FmJLFrfES8ZWCxKyMCZW1HmMkthyDrDjQ,13046
+atoti_query/_execute_gaq.py,sha256=daLDTkHO1f1bAqz-cdlSJM9MZ-yavNOjhV5n7pZoVOc,638
+atoti_query/_gaq_filter.py,sha256=XMz-s-JHvnXOCe1wbshc52uMv_68BK-S3hvuDmsTaek,308
+atoti_query/_generate_mdx.py,sha256=pv2jR3lrbqs55MCJx2fI_JkiG3ynAiUc_RI_nn6DlcI,12981
 atoti_query/_get_cube.py,sha256=ZehybO2Pe-uRE6-N7tFMkAVHT6oPQg3uInUGrL5Tuc0,591
-atoti_query/_get_data_types.py,sha256=tPfujg6ocWmWKX8toQzssgw1Bn9KmVDjHOkmcseHHgk,285
+atoti_query/_get_data_types.py,sha256=-Ac4HRAaPL8XAz46S5pZGKMZZCbOG53MylDogxIZ-6I,281
 atoti_query/_get_dimensions_mapping.py,sha256=G5WsMN4Rk2YFgLYSKihXMxXaR1FPfxnkO7kBilXNeqY,729
 atoti_query/_hierarchy_filter.py,sha256=3Pb5KQK7jBKh8IQLW7vPXbIZogSZnlcCoHAtgKzSCx0,675
 atoti_query/_index_cellset.py,sha256=8AcqobIYFHLt1kJx_Be1bcyDWAKY7abZH1f10YL5LTA,1193
 atoti_query/_index_discovery.py,sha256=bypkfSbsJGPXm2JZF7GFTFOQKCxpNn5WPJtwkcjnWn4,2436
 atoti_query/_is_gaq_filter.py,sha256=b1xSy1it2F5s17YMs1_U3Md7WVQR7XEhENMgiMjwHQ0,509
 atoti_query/_named.py,sha256=vx1is0vXKoeVTvQ_WmVTOzDjGh7Ej07fDKkwwxTVZIE,105
-atoti_query/_parse_level_coordinates.py,sha256=2uVEJmbCZ7Mlsp0e-eAZAEiC3-A0hy2ZagNFYZXSgSc,553
+atoti_query/_parse_level_identifier.py,sha256=TaDTOssQmS9KFTNAABR9S_tGUM8DvzWR2ysV-c47lyQ,579
 atoti_query/_query_mdx.py,sha256=VQp6CVWfxZLuUPCUt_grsS_yTj4bfMYymrYa9xxTJPE,490
 atoti_query/_query_private_parameters.py,sha256=6Jah5FPzeuxLMfuk8Ajfgvm7Cdr_4BIwknSSopqyGts,282
 atoti_query/_widget_conversion_details.py,sha256=ernM6QROJNCrr0eeJyhlbxqlrLh7segI1rVyieGMI-A,452
 atoti_query/auth.py,sha256=tGtvk4CmR8NLykP6o4XG3sA5q1CL-M_SqPkn8uxRizw,524
 atoti_query/basic_authentication.py,sha256=oHJcqmq9KoFIMozAdr2RLiNiEc87RAqAms9o7uccXkM,1034
 atoti_query/client_certificate.py,sha256=cUVpT4K2dTvxBTFNHVRNHa9IwxNuKhmt76b5Gyf3Zv4,1944
 atoti_query/oauth2_resource_owner_password_authentication.py,sha256=UIWeJPk6TWIgN60tDs2p5HhyFvB-1mYKXgtslsY1DI0,1950
 atoti_query/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-atoti_query/query_cube.py,sha256=eLfXdy1fCjjlj-w5s-3RGR_BvqNR2UMtDxpRr6SxsRc,4455
+atoti_query/query_cube.py,sha256=fWTgHt6GjBKbJzK9f0X0AqK_qHgh7o1ll1NUJhjp47Q,4439
 atoti_query/query_cubes.py,sha256=BEuklC8h2hVyYxJWRg_yf36uZLeYz6TrjkihBVTm15E,170
 atoti_query/query_hierarchies.py,sha256=0SqmmMRO5iGKAp_sO7ZRG72_NeDlf48a_zNF21rG6q8,728
-atoti_query/query_hierarchy.py,sha256=nArbliZV4WxmvKVDTsIGJdiq-jQT1HAHa0r051fdf5I,1028
-atoti_query/query_level.py,sha256=0-aUja2anm08Q4I_ICvHE3VmAfs045JPxV6dXeQ3J8E,772
+atoti_query/query_hierarchy.py,sha256=TpMxai7hLu1v71ZlNNnTJF0r75MqUx8vXU-4uigCZeY,807
+atoti_query/query_level.py,sha256=HGqEjLoQDO3OiU0lmn8wd2Kbpp5V4yBmkUSHD-ceOzQ,354
 atoti_query/query_levels.py,sha256=Ni4tHEaxE1w3DT-HGGnaDJsH_HFLIkva2ssdo7IBWjk,1316
-atoti_query/query_measure.py,sha256=js8Am-LRkDjdINvF5Mfl2bjCdX09xaaK9gfsVOVjINM,990
+atoti_query/query_measure.py,sha256=uG5jDqrmPH_9OodLZe6Ey8gYSFhDD-39WOmMn1uVgQ8,1035
 atoti_query/query_measures.py,sha256=ITYf51DPopmKzs55svPisEkcfjCYbsfEg0L3BMy6Dtw,191
-atoti_query/query_result.py,sha256=lVy2La8ZZ9u6lISUnR4N8dqrmQ3oXOhwiNmoeJaLIkQ,5648
-atoti_query/query_session.py,sha256=jJ2VVdSDl0UV_AUPmLaggnFP32jVEwUriUAlAMJl0yU,12502
+atoti_query/query_result.py,sha256=qwnJHS_ZWcacdhEr_5PWRCQWoWuFxzPZLjYnvIgE-6w,5803
+atoti_query/query_session.py,sha256=0h59cW72eG8qRf8ESkhBQeLIejIuMjPw1ghufbSdqwg,12492
 atoti_query/token_authentication.py,sha256=u_Dwne3B5Dz-wRmNSBMg-m1ecWv3D9HnkT2PovoQSQU,752
 atoti_query/_internal/__init__.py,sha256=MZDcH9fPOFc-LEPhri-BtOd09coIJdRJrHQCCH_LT78,150
 atoti_query/security/__init__.py,sha256=ysupEFwAXW_dwOMiVMFydrvgqd_p1PJ35YmH9__M_BY,134
 atoti_query/security/_authentication_type.py,sha256=hBZVtzbO6fKQT074X7dDPqYKzNqBfU4tqpL0c9G3Hbg,94
 atoti_query/security/_column_key.py,sha256=Y_O2JBMGPjueJ00Yl2mZJUKwgYLzr3uaBjDbPoEla64,28
 atoti_query/security/_constants.py,sha256=H_iZzhd4aEsxO161XeyCgiQSEHHEzJbKzO5WQ9cf-wg,371
-atoti_query/security/_content_client.py,sha256=RHYA4rwSu8IOJqw89J2xaT_iyh87vyolqkBQa6AVTtU,2997
-atoti_query/security/_restriction.py,sha256=Kb5AMSbICLPW-aea5HJGubSSjN_0NcPr6-TssA7wIt4,258
-atoti_query/security/_restriction_from_mapping.py,sha256=NPIcvic2xo4g2uri5A0EHFIp_go21cyAxodfEeXGnfg,728
-atoti_query/security/_restriction_to_dict.py,sha256=--MxzA1XGMedkvR9agQ16C2oKwfUXn3d6vjYtFlJRHY,1411
+atoti_query/security/_content_client.py,sha256=t9EsTzXp9lbeQ0xz5jSKE1s95ZPGzAV4tJU6PKcke1c,3096
+atoti_query/security/_restriction.py,sha256=aee7CgwoMfCe2BCzCzlVd47jjFDezcYaAVcBWh9ADuM,256
+atoti_query/security/_restriction_from_mapping.py,sha256=wteF1bxU9_F7sKc2qg-4g-vS1hDFGpkPmd60SsLcdnw,784
+atoti_query/security/_restriction_to_dict.py,sha256=k7vexM6tM1NA491lsvh6a48NEayDKnQz6-ax0gCQmK0,1443
 atoti_query/security/_restrictions.py,sha256=5xDXZiNrz1rfAkd6uai0SOVGNGMaaguXCuYfH0eZHMg,1162
 atoti_query/security/_roles.py,sha256=-70bIhdtSQnTwDMvoxf_XFOfaz2dTl2JOJ8fEqmrFwo,5094
 atoti_query/security/_service.py,sha256=UCJIDZEP-41gk262CEsczGkw6aYBVzKOqrikOiJLB84,6003
 atoti_query/security/basic_security.py,sha256=G95wDk62IdBbyJhjiM0OC8uGMNheTfTPfaDD-dwAO4c,4375
 atoti_query/security/default_roles.py,sha256=ZzeDqDs0hFHkz-5FrrpI0-sksuAVFS22TnMmNbZg2ak,1041
 atoti_query/security/individual_roles.py,sha256=P-cgn5neUPHMn5mf3KO8SVpfRSb-aRPBwLyfdSY02Ic,4174
 atoti_query/security/kerberos_security.py,sha256=SuUMXIuGnzb35nD0nHd0wnpmKgPJ__xf5JvEmUTnyGM,730
 atoti_query/security/ldap_security.py,sha256=37e5MuWYGUOl3uggaxtyVePXptOd88bqWRwuGAQ_49I,1934
 atoti_query/security/oidc_security.py,sha256=dE_bSwqVGUrkEs7eLxbVWHtH6HSL7mti8Fz_t3G2a4U,2459
 atoti_query/security/role_mapping.py,sha256=HXsEKEpJqKRDEMD_Y3HhSL5cqUvc0yFszQQ0hOCOows,3839
 atoti_query/security/security.py,sha256=7KLl9HU2YiNBU3hFNJwZFqSKB16zgTKKfWMDXPJhcdE,12217
-atoti_query-0.8.1.dist-info/METADATA,sha256=v5eOll4oaVL4BR5UQkcLhVvfxusmBaYnHz5m2-kqrJI,913
-atoti_query-0.8.1.dist-info/WHEEL,sha256=-xFWYjBwxwp_eg2T02KSILmYxFgZAplP6Hjbi2nYCnQ,109
-atoti_query-0.8.1.dist-info/top_level.txt,sha256=wyZL-Ia80k5wcrEvOrU6A20dbpqueW_6Lt3PfPv8lFo,12
-atoti_query-0.8.1.dist-info/RECORD,,
+atoti_query-0.8.2.dist-info/METADATA,sha256=OYqWxEjK7pKQDbfRzEVYpQxC8nkV7QIO_MbfggO6weY,913
+atoti_query-0.8.2.dist-info/WHEEL,sha256=8ngoJnqny485_Zhidm3gUHNLPQTUIjfhFb7Qoa0d3wA,109
+atoti_query-0.8.2.dist-info/top_level.txt,sha256=wyZL-Ia80k5wcrEvOrU6A20dbpqueW_6Lt3PfPv8lFo,12
+atoti_query-0.8.2.dist-info/RECORD,,
```

