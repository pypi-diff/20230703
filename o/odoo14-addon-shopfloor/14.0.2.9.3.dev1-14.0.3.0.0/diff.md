# Comparing `tmp/odoo14_addon_shopfloor-14.0.2.9.3.dev1-py3-none-any.whl.zip` & `tmp/odoo14_addon_shopfloor-14.0.3.0.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,168 +1,188 @@
-Zip file size: 742988 bytes, number of entries: 166
--rw-r--r--  2.0 unx     4649 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/README.rst
--rw-r--r--  2.0 unx       91 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/__init__.py
--rw-r--r--  2.0 unx     2180 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/__manifest__.py
--rw-r--r--  2.0 unx      253 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/utils.py
--rw-r--r--  2.0 unx      370 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/actions/__init__.py
--rw-r--r--  2.0 unx     9413 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/actions/change_package_lot.py
--rw-r--r--  2.0 unx     1438 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/actions/completion_info.py
--rw-r--r--  2.0 unx     9216 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/actions/data.py
--rw-r--r--  2.0 unx     5214 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/actions/data_detail.py
--rw-r--r--  2.0 unx     5275 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/actions/inventory.py
--rw-r--r--  2.0 unx     3110 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/actions/location_content_transfer_sorter.py
--rw-r--r--  2.0 unx    20435 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/actions/message.py
--rw-r--r--  2.0 unx     3802 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/actions/move_line_search.py
--rw-r--r--  2.0 unx     2046 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/actions/packaging.py
--rw-r--r--  2.0 unx     1232 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/actions/savepoint.py
--rw-r--r--  2.0 unx     7133 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/actions/schema.py
--rw-r--r--  2.0 unx     3195 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/actions/schema_detail.py
--rw-r--r--  2.0 unx     2776 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/actions/search.py
--rw-r--r--  2.0 unx     4279 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/actions/stock.py
--rw-r--r--  2.0 unx      173 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/components/__init__.py
--rw-r--r--  2.0 unx      747 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/components/scan_handler_location.py
--rw-r--r--  2.0 unx      723 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/components/scan_handler_lot.py
--rw-r--r--  2.0 unx      746 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/components/scan_handler_package.py
--rw-r--r--  2.0 unx      742 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/components/scan_handler_product.py
--rw-r--r--  2.0 unx      743 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/components/scan_handler_transfer.py
--rw-r--r--  2.0 unx     1958 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/data/shopfloor_scenario_data.xml
--rw-r--r--  2.0 unx      420 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/demo/shopfloor_app_demo.xml
--rw-r--r--  2.0 unx     2938 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/demo/shopfloor_menu_demo.xml
--rw-r--r--  2.0 unx      253 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/demo/shopfloor_profile_demo.xml
--rw-r--r--  2.0 unx     4931 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/demo/stock_picking_type_demo.xml
--rw-r--r--  2.0 unx     7030 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/docs/cluster_picking_diag_seq.plantuml
--rw-r--r--  2.0 unx   279898 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/docs/cluster_picking_diag_seq.png
--rw-r--r--  2.0 unx     1734 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/docs/delivery_diag_seq.plantuml
--rw-r--r--  2.0 unx    73563 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/docs/delivery_diag_seq.png
--rw-r--r--  2.0 unx     3297 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/docs/oca_logo.png
--rw-r--r--  2.0 unx      910 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/docs/single_pack_transfer_diag_seq.plantuml
--rw-r--r--  2.0 unx    29489 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/docs/single_pack_transfer_diag_seq.png
--rw-r--r--  2.0 unx     3527 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/docs/zone_picking_diag_seq.plantuml
--rw-r--r--  2.0 unx   185581 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/docs/zone_picking_diag_seq.png
--rw-r--r--  2.0 unx    44327 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/i18n/ca.po
--rw-r--r--  2.0 unx    60056 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/i18n/es_AR.po
--rw-r--r--  2.0 unx    43118 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/i18n/pt_BR.po
--rw-r--r--  2.0 unx    43111 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/i18n/shopfloor.pot
--rw-r--r--  2.0 unx      409 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/migrations/14.0.1.0.0/pre-migration.py
--rw-r--r--  2.0 unx     1243 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/migrations/14.0.2.0.0/post-migration.py
--rw-r--r--  2.0 unx      616 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/migrations/14.0.2.3.0/pre-migration.py
--rw-r--r--  2.0 unx      398 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/models/__init__.py
--rw-r--r--  2.0 unx     1503 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/models/priority_postpone_mixin.py
--rw-r--r--  2.0 unx      292 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/models/shopfloor_app.py
--rw-r--r--  2.0 unx    12249 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/models/shopfloor_menu.py
--rw-r--r--  2.0 unx      808 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/models/stock_inventory.py
--rw-r--r--  2.0 unx     3141 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/models/stock_location.py
--rw-r--r--  2.0 unx     4749 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/models/stock_move.py
--rw-r--r--  2.0 unx    12520 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/models/stock_move_line.py
--rw-r--r--  2.0 unx     2150 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/models/stock_package_level.py
--rw-r--r--  2.0 unx     4868 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/models/stock_picking.py
--rw-r--r--  2.0 unx     1466 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/models/stock_picking_batch.py
--rw-r--r--  2.0 unx      935 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/models/stock_picking_type.py
--rw-r--r--  2.0 unx      872 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/models/stock_quant.py
--rw-r--r--  2.0 unx     3579 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/models/stock_quant_package.py
--rw-r--r--  2.0 unx      496 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/readme/CONTRIBUTORS.rst
--rw-r--r--  2.0 unx       65 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/readme/CREDITS.rst
--rw-r--r--  2.0 unx      485 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/readme/DESCRIPTION.rst
--rw-r--r--  2.0 unx       47 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/readme/HISTORY.rst
--rw-r--r--  2.0 unx      179 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/readme/ROADMAP.rst
--rw-r--r--  2.0 unx      308 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/readme/USAGE.rst
--rw-r--r--  2.0 unx      578 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/security/groups.xml
--rw-r--r--  2.0 unx      303 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/services/__init__.py
--rw-r--r--  2.0 unx    60460 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/services/checkout.py
--rw-r--r--  2.0 unx    60202 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/services/cluster_picking.py
--rw-r--r--  2.0 unx    31453 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/services/delivery.py
--rw-r--r--  2.0 unx    46357 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/services/location_content_transfer.py
--rw-r--r--  2.0 unx     2225 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/services/menu.py
--rw-r--r--  2.0 unx     4649 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/services/picking_batch.py
--rw-r--r--  2.0 unx     4157 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/services/service.py
--rw-r--r--  2.0 unx    15020 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/services/single_pack_transfer.py
--rw-r--r--  2.0 unx    69066 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/services/zone_picking.py
--rw-r--r--  2.0 unx       27 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/services/forms/__init__.py
--rw-r--r--  2.0 unx     2626 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/services/forms/picking_form.py
--rw-r--r--  2.0 unx     9455 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/static/description/icon.png
--rw-r--r--  2.0 unx    16036 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/static/description/index.html
--rw-r--r--  2.0 unx     3036 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/__init__.py
--rw-r--r--  2.0 unx    11192 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/common.py
--rw-r--r--  2.0 unx      941 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/models.py
--rw-r--r--  2.0 unx    47256 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_actions_change_package_lot.py
--rw-r--r--  2.0 unx    12570 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_actions_data.py
--rw-r--r--  2.0 unx     8282 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_actions_data_base.py
--rw-r--r--  2.0 unx    10952 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_actions_data_detail.py
--rw-r--r--  2.0 unx     4057 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_actions_search.py
--rw-r--r--  2.0 unx     1462 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_checkout_base.py
--rw-r--r--  2.0 unx     5361 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_checkout_cancel_line.py
--rw-r--r--  2.0 unx     6015 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_checkout_change_packaging.py
--rw-r--r--  2.0 unx     4469 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_checkout_done.py
--rw-r--r--  2.0 unx     4425 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_checkout_list_delivery_packaging.py
--rw-r--r--  2.0 unx     9818 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_checkout_list_package.py
--rw-r--r--  2.0 unx     2443 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_checkout_new_package.py
--rw-r--r--  2.0 unx     2941 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_checkout_no_package.py
--rw-r--r--  2.0 unx     7439 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_checkout_scan.py
--rw-r--r--  2.0 unx    12651 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_checkout_scan_line.py
--rw-r--r--  2.0 unx      854 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_checkout_scan_line_base.py
--rw-r--r--  2.0 unx    16936 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_checkout_scan_package_action.py
--rw-r--r--  2.0 unx     2792 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_checkout_select.py
--rw-r--r--  2.0 unx     4983 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_checkout_select_line.py
--rw-r--r--  2.0 unx     2257 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_checkout_select_package_base.py
--rw-r--r--  2.0 unx     9541 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_checkout_set_qty.py
--rw-r--r--  2.0 unx     2312 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_checkout_summary.py
--rw-r--r--  2.0 unx     2736 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_cluster_picking_base.py
--rw-r--r--  2.0 unx     4038 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_cluster_picking_batch.py
--rw-r--r--  2.0 unx     4079 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_cluster_picking_change_pack_lot.py
--rw-r--r--  2.0 unx     3608 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_cluster_picking_is_zero.py
--rw-r--r--  2.0 unx    14241 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_cluster_picking_scan_destination.py
--rw-r--r--  2.0 unx    16122 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_cluster_picking_scan_line.py
--rw-r--r--  2.0 unx    15156 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_cluster_picking_select.py
--rw-r--r--  2.0 unx     3540 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_cluster_picking_skip.py
--rw-r--r--  2.0 unx    17018 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_cluster_picking_stock_issue.py
--rw-r--r--  2.0 unx    35857 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_cluster_picking_unload.py
--rw-r--r--  2.0 unx     4269 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_delivery_base.py
--rw-r--r--  2.0 unx     4184 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_delivery_done.py
--rw-r--r--  2.0 unx     1637 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_delivery_list_stock_picking.py
--rw-r--r--  2.0 unx     4749 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_delivery_reset_qty_done_line.py
--rw-r--r--  2.0 unx     4298 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_delivery_reset_qty_done_pack.py
--rw-r--r--  2.0 unx    14969 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_delivery_scan_deliver.py
--rw-r--r--  2.0 unx     1262 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_delivery_select.py
--rw-r--r--  2.0 unx     3463 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_delivery_set_qty_done_line.py
--rw-r--r--  2.0 unx     5359 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_delivery_set_qty_done_pack.py
--rw-r--r--  2.0 unx     6237 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_delivery_sublocation.py
--rw-r--r--  2.0 unx     4573 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_location_content_transfer_base.py
--rw-r--r--  2.0 unx    23928 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_location_content_transfer_mix.py
--rw-r--r--  2.0 unx     5821 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_location_content_transfer_putaway.py
--rw-r--r--  2.0 unx    13357 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_location_content_transfer_set_destination_all.py
--rw-r--r--  2.0 unx    35661 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_location_content_transfer_set_destination_package_or_line.py
--rw-r--r--  2.0 unx    30834 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_location_content_transfer_single.py
--rw-r--r--  2.0 unx    14435 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_location_content_transfer_start.py
--rw-r--r--  2.0 unx     9171 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_menu_base.py
--rw-r--r--  2.0 unx     2110 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_menu_counters.py
--rw-r--r--  2.0 unx      771 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_misc.py
--rw-r--r--  2.0 unx     3440 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_move_action_assign.py
--rw-r--r--  2.0 unx      712 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_openapi.py
--rw-r--r--  2.0 unx     2355 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_picking_form.py
--rw-r--r--  2.0 unx     1680 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_scan_anything.py
--rw-r--r--  2.0 unx    38877 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_single_pack_transfer.py
--rw-r--r--  2.0 unx     1221 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_single_pack_transfer_base.py
--rw-r--r--  2.0 unx     4397 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_single_pack_transfer_putaway.py
--rw-r--r--  2.0 unx     8847 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_stock_split.py
--rw-r--r--  2.0 unx     1389 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_user.py
--rw-r--r--  2.0 unx    18392 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_zone_picking_base.py
--rw-r--r--  2.0 unx     5302 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_zone_picking_change_pack_lot.py
--rw-r--r--  2.0 unx    25460 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_zone_picking_select_line.py
--rw-r--r--  2.0 unx      870 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_zone_picking_select_picking_type.py
--rw-r--r--  2.0 unx    21795 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_zone_picking_set_line_destination.py
--rw-r--r--  2.0 unx     7942 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_zone_picking_set_line_destination_pick_pack.py
--rw-r--r--  2.0 unx     7170 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_zone_picking_start.py
--rw-r--r--  2.0 unx     6236 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_zone_picking_stock_issue.py
--rw-r--r--  2.0 unx    13049 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_zone_picking_unload_all.py
--rw-r--r--  2.0 unx     4357 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_zone_picking_unload_buffer_lines.py
--rw-r--r--  2.0 unx    13548 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_zone_picking_unload_set_destination.py
--rw-r--r--  2.0 unx     4374 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_zone_picking_unload_single.py
--rw-r--r--  2.0 unx     2514 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/tests/test_zone_picking_zero_check.py
--rw-r--r--  2.0 unx     4674 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/views/shopfloor_menu.xml
--rw-r--r--  2.0 unx      829 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/views/stock_location.xml
--rw-r--r--  2.0 unx     1295 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/views/stock_move_line.xml
--rw-r--r--  2.0 unx      793 b- defN 22-Oct-31 05:19 odoo/addons/shopfloor/views/stock_picking_type.xml
--rw-r--r--  2.0 unx     5806 b- defN 22-Oct-31 05:20 odoo14_addon_shopfloor-14.0.2.9.3.dev1.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 22-Oct-31 05:20 odoo14_addon_shopfloor-14.0.2.9.3.dev1.dist-info/WHEEL
--rw-r--r--  2.0 unx        5 b- defN 22-Oct-31 05:20 odoo14_addon_shopfloor-14.0.2.9.3.dev1.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx    18064 b- defN 22-Oct-31 05:20 odoo14_addon_shopfloor-14.0.2.9.3.dev1.dist-info/RECORD
-166 files, 1980067 bytes uncompressed, 713036 bytes compressed:  64.0%
+Zip file size: 958379 bytes, number of entries: 186
+-rw-r--r--  2.0 unx     5050 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/README.rst
+-rw-r--r--  2.0 unx       91 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/__init__.py
+-rw-r--r--  2.0 unx     2214 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/__manifest__.py
+-rw-r--r--  2.0 unx      197 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/exceptions.py
+-rw-r--r--  2.0 unx      375 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/utils.py
+-rw-r--r--  2.0 unx      400 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/actions/__init__.py
+-rw-r--r--  2.0 unx     9413 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/actions/change_package_lot.py
+-rw-r--r--  2.0 unx     1438 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/actions/completion_info.py
+-rw-r--r--  2.0 unx    11435 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/actions/data.py
+-rw-r--r--  2.0 unx     5505 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/actions/data_detail.py
+-rw-r--r--  2.0 unx     5275 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/actions/inventory.py
+-rw-r--r--  2.0 unx     3110 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/actions/location_content_transfer_sorter.py
+-rw-r--r--  2.0 unx    26106 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/actions/message.py
+-rw-r--r--  2.0 unx     4089 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/actions/move_line_search.py
+-rw-r--r--  2.0 unx     2046 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/actions/packaging.py
+-rw-r--r--  2.0 unx     1232 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/actions/savepoint.py
+-rw-r--r--  2.0 unx     8025 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/actions/schema.py
+-rw-r--r--  2.0 unx     3195 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/actions/schema_detail.py
+-rw-r--r--  2.0 unx     6443 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/actions/search.py
+-rw-r--r--  2.0 unx    10142 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/actions/stock.py
+-rw-r--r--  2.0 unx     2720 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/actions/stock_unreserve.py
+-rw-r--r--  2.0 unx      173 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/components/__init__.py
+-rw-r--r--  2.0 unx      825 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/components/scan_handler_location.py
+-rw-r--r--  2.0 unx      807 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/components/scan_handler_lot.py
+-rw-r--r--  2.0 unx      829 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/components/scan_handler_package.py
+-rw-r--r--  2.0 unx      833 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/components/scan_handler_product.py
+-rw-r--r--  2.0 unx      820 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/components/scan_handler_transfer.py
+-rw-r--r--  2.0 unx     2306 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/data/shopfloor_scenario_data.xml
+-rw-r--r--  2.0 unx      420 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/demo/shopfloor_app_demo.xml
+-rw-r--r--  2.0 unx     2938 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/demo/shopfloor_menu_demo.xml
+-rw-r--r--  2.0 unx      253 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/demo/shopfloor_profile_demo.xml
+-rw-r--r--  2.0 unx     4931 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/demo/stock_picking_type_demo.xml
+-rw-r--r--  2.0 unx     1725 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/docs/checkout_diag_seq.plantuml
+-rw-r--r--  2.0 unx    92254 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/docs/checkout_diag_seq.png
+-rw-r--r--  2.0 unx     7030 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/docs/cluster_picking_diag_seq.plantuml
+-rw-r--r--  2.0 unx   279898 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/docs/cluster_picking_diag_seq.png
+-rw-r--r--  2.0 unx     1734 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/docs/delivery_diag_seq.plantuml
+-rw-r--r--  2.0 unx    73563 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/docs/delivery_diag_seq.png
+-rw-r--r--  2.0 unx     2372 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/docs/location_content_transfer_diag_seq.plantuml
+-rw-r--r--  2.0 unx   117002 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/docs/location_content_transfer_diag_seq.png
+-rw-r--r--  2.0 unx     3297 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/docs/oca_logo.png
+-rw-r--r--  2.0 unx      910 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/docs/single_pack_transfer_diag_seq.plantuml
+-rw-r--r--  2.0 unx    29489 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/docs/single_pack_transfer_diag_seq.png
+-rw-r--r--  2.0 unx     3527 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/docs/zone_picking_diag_seq.plantuml
+-rw-r--r--  2.0 unx   185581 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/docs/zone_picking_diag_seq.png
+-rw-r--r--  2.0 unx    52155 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/i18n/ca.po
+-rw-r--r--  2.0 unx    50944 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/i18n/de.po
+-rw-r--r--  2.0 unx    71001 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/i18n/es_AR.po
+-rw-r--r--  2.0 unx    50946 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/i18n/pt_BR.po
+-rw-r--r--  2.0 unx    52151 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/i18n/shopfloor.pot
+-rw-r--r--  2.0 unx      409 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/migrations/14.0.1.0.0/pre-migration.py
+-rw-r--r--  2.0 unx     1243 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/migrations/14.0.2.0.0/post-migration.py
+-rw-r--r--  2.0 unx      616 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/migrations/14.0.2.3.0/pre-migration.py
+-rw-r--r--  2.0 unx      398 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/models/__init__.py
+-rw-r--r--  2.0 unx     1503 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/models/priority_postpone_mixin.py
+-rw-r--r--  2.0 unx      292 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/models/shopfloor_app.py
+-rw-r--r--  2.0 unx    16868 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/models/shopfloor_menu.py
+-rw-r--r--  2.0 unx      808 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/models/stock_inventory.py
+-rw-r--r--  2.0 unx     3141 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/models/stock_location.py
+-rw-r--r--  2.0 unx     4749 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/models/stock_move.py
+-rw-r--r--  2.0 unx    12818 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/models/stock_move_line.py
+-rw-r--r--  2.0 unx     2150 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/models/stock_package_level.py
+-rw-r--r--  2.0 unx     4868 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/models/stock_picking.py
+-rw-r--r--  2.0 unx     1466 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/models/stock_picking_batch.py
+-rw-r--r--  2.0 unx      935 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/models/stock_picking_type.py
+-rw-r--r--  2.0 unx      872 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/models/stock_quant.py
+-rw-r--r--  2.0 unx     3579 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/models/stock_quant_package.py
+-rw-r--r--  2.0 unx      608 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/readme/CONTRIBUTORS.rst
+-rw-r--r--  2.0 unx       65 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/readme/CREDITS.rst
+-rw-r--r--  2.0 unx      774 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/readme/DESCRIPTION.rst
+-rw-r--r--  2.0 unx       47 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/readme/HISTORY.rst
+-rw-r--r--  2.0 unx      179 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/readme/ROADMAP.rst
+-rw-r--r--  2.0 unx      308 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/readme/USAGE.rst
+-rw-r--r--  2.0 unx      578 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/security/groups.xml
+-rw-r--r--  2.0 unx      303 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/services/__init__.py
+-rw-r--r--  2.0 unx    69715 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/services/checkout.py
+-rw-r--r--  2.0 unx    67251 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/services/cluster_picking.py
+-rw-r--r--  2.0 unx    32632 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/services/delivery.py
+-rw-r--r--  2.0 unx    49967 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/services/location_content_transfer.py
+-rw-r--r--  2.0 unx     2225 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/services/menu.py
+-rw-r--r--  2.0 unx     4649 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/services/picking_batch.py
+-rw-r--r--  2.0 unx     4179 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/services/service.py
+-rw-r--r--  2.0 unx    15096 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/services/single_pack_transfer.py
+-rw-r--r--  2.0 unx    79620 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/services/zone_picking.py
+-rw-r--r--  2.0 unx       27 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/services/forms/__init__.py
+-rw-r--r--  2.0 unx     2626 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/services/forms/picking_form.py
+-rw-r--r--  2.0 unx     9455 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/static/description/icon.png
+-rw-r--r--  2.0 unx    16736 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/static/description/index.html
+-rw-r--r--  2.0 unx     3722 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/__init__.py
+-rw-r--r--  2.0 unx    11332 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/common.py
+-rw-r--r--  2.0 unx      941 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/models.py
+-rw-r--r--  2.0 unx    47256 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_actions_change_package_lot.py
+-rw-r--r--  2.0 unx    14616 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_actions_data.py
+-rw-r--r--  2.0 unx     8282 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_actions_data_base.py
+-rw-r--r--  2.0 unx    12723 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_actions_data_detail.py
+-rw-r--r--  2.0 unx     9374 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_actions_search.py
+-rw-r--r--  2.0 unx     1907 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_actions_stock.py
+-rw-r--r--  2.0 unx     3385 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_checkout_auto_post.py
+-rw-r--r--  2.0 unx     2491 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_checkout_base.py
+-rw-r--r--  2.0 unx     5339 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_checkout_cancel_line.py
+-rw-r--r--  2.0 unx     6015 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_checkout_change_packaging.py
+-rw-r--r--  2.0 unx     5074 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_checkout_done.py
+-rw-r--r--  2.0 unx     4425 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_checkout_list_delivery_packaging.py
+-rw-r--r--  2.0 unx    12293 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_checkout_list_package.py
+-rw-r--r--  2.0 unx     3415 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_checkout_new_package.py
+-rw-r--r--  2.0 unx     3609 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_checkout_no_package.py
+-rw-r--r--  2.0 unx     7428 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_checkout_scan.py
+-rw-r--r--  2.0 unx    15354 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_checkout_scan_line.py
+-rw-r--r--  2.0 unx      976 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_checkout_scan_line_base.py
+-rw-r--r--  2.0 unx     3895 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_checkout_scan_line_no_prefill_qty.py
+-rw-r--r--  2.0 unx    16925 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_checkout_scan_package_action.py
+-rw-r--r--  2.0 unx     3773 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_checkout_scan_package_action_no_prefill_qty.py
+-rw-r--r--  2.0 unx     2781 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_checkout_select.py
+-rw-r--r--  2.0 unx     4972 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_checkout_select_line.py
+-rw-r--r--  2.0 unx     2392 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_checkout_select_package_base.py
+-rw-r--r--  2.0 unx     9523 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_checkout_set_qty.py
+-rw-r--r--  2.0 unx     2312 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_checkout_summary.py
+-rw-r--r--  2.0 unx     2908 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_cluster_picking_base.py
+-rw-r--r--  2.0 unx     4038 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_cluster_picking_batch.py
+-rw-r--r--  2.0 unx     4122 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_cluster_picking_change_pack_lot.py
+-rw-r--r--  2.0 unx     3608 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_cluster_picking_is_zero.py
+-rw-r--r--  2.0 unx    14336 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_cluster_picking_scan_destination.py
+-rw-r--r--  2.0 unx     4237 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_cluster_picking_scan_destination_no_prefill_qty.py
+-rw-r--r--  2.0 unx    15443 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_cluster_picking_scan_line.py
+-rw-r--r--  2.0 unx     4406 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_cluster_picking_scan_line_location_or_pack_first.py
+-rw-r--r--  2.0 unx     2904 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_cluster_picking_scan_line_no_prefill_qty.py
+-rw-r--r--  2.0 unx    15208 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_cluster_picking_select.py
+-rw-r--r--  2.0 unx     3540 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_cluster_picking_skip.py
+-rw-r--r--  2.0 unx    17018 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_cluster_picking_stock_issue.py
+-rw-r--r--  2.0 unx    35857 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_cluster_picking_unload.py
+-rw-r--r--  2.0 unx     4966 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_delivery_base.py
+-rw-r--r--  2.0 unx     4184 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_delivery_done.py
+-rw-r--r--  2.0 unx     1637 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_delivery_list_stock_picking.py
+-rw-r--r--  2.0 unx     4749 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_delivery_reset_qty_done_line.py
+-rw-r--r--  2.0 unx     4298 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_delivery_reset_qty_done_pack.py
+-rw-r--r--  2.0 unx    23213 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_delivery_scan_deliver.py
+-rw-r--r--  2.0 unx     1262 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_delivery_select.py
+-rw-r--r--  2.0 unx     3463 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_delivery_set_qty_done_line.py
+-rw-r--r--  2.0 unx     5359 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_delivery_set_qty_done_pack.py
+-rw-r--r--  2.0 unx     6295 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_delivery_sublocation.py
+-rw-r--r--  2.0 unx     4603 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_location_content_transfer_base.py
+-rw-r--r--  2.0 unx     4686 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_location_content_transfer_get_work.py
+-rw-r--r--  2.0 unx    23928 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_location_content_transfer_mix.py
+-rw-r--r--  2.0 unx     5837 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_location_content_transfer_putaway.py
+-rw-r--r--  2.0 unx     1489 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_location_content_transfer_scan_location.py
+-rw-r--r--  2.0 unx    13419 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_location_content_transfer_set_destination_all.py
+-rw-r--r--  2.0 unx    35661 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_location_content_transfer_set_destination_package_or_line.py
+-rw-r--r--  2.0 unx    30834 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_location_content_transfer_single.py
+-rw-r--r--  2.0 unx    14443 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_location_content_transfer_start.py
+-rw-r--r--  2.0 unx     9171 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_menu_base.py
+-rw-r--r--  2.0 unx     2110 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_menu_counters.py
+-rw-r--r--  2.0 unx      771 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_misc.py
+-rw-r--r--  2.0 unx     3440 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_move_action_assign.py
+-rw-r--r--  2.0 unx      712 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_openapi.py
+-rw-r--r--  2.0 unx     2355 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_picking_form.py
+-rw-r--r--  2.0 unx     1824 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_scan_anything.py
+-rw-r--r--  2.0 unx    38881 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_single_pack_transfer.py
+-rw-r--r--  2.0 unx     1221 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_single_pack_transfer_base.py
+-rw-r--r--  2.0 unx     4397 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_single_pack_transfer_putaway.py
+-rw-r--r--  2.0 unx     8847 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_stock_split.py
+-rw-r--r--  2.0 unx     1389 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_user.py
+-rw-r--r--  2.0 unx    19095 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_zone_picking_base.py
+-rw-r--r--  2.0 unx     5302 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_zone_picking_change_pack_lot.py
+-rw-r--r--  2.0 unx    28427 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_zone_picking_select_line.py
+-rw-r--r--  2.0 unx     8162 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_zone_picking_select_line_first_scan_location.py
+-rw-r--r--  2.0 unx     7937 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_zone_picking_select_line_first_scan_location.py.bak
+-rw-r--r--  2.0 unx     3816 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_zone_picking_select_line_no_prefill_qty.py
+-rw-r--r--  2.0 unx      870 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_zone_picking_select_picking_type.py
+-rw-r--r--  2.0 unx    24140 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_zone_picking_set_line_destination.py
+-rw-r--r--  2.0 unx     5188 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_zone_picking_set_line_destination_no_prefill_qty.py
+-rw-r--r--  2.0 unx     8275 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_zone_picking_set_line_destination_pick_pack.py
+-rw-r--r--  2.0 unx     7170 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_zone_picking_start.py
+-rw-r--r--  2.0 unx     6236 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_zone_picking_stock_issue.py
+-rw-r--r--  2.0 unx    13049 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_zone_picking_unload_all.py
+-rw-r--r--  2.0 unx     4357 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_zone_picking_unload_buffer_lines.py
+-rw-r--r--  2.0 unx    13548 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_zone_picking_unload_set_destination.py
+-rw-r--r--  2.0 unx     4374 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_zone_picking_unload_single.py
+-rw-r--r--  2.0 unx     2514 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/tests/test_zone_picking_zero_check.py
+-rw-r--r--  2.0 unx     7548 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/views/shopfloor_menu.xml
+-rw-r--r--  2.0 unx      829 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/views/stock_location.xml
+-rw-r--r--  2.0 unx     1984 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/views/stock_move_line.xml
+-rw-r--r--  2.0 unx      793 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor/views/stock_picking_type.xml
+-rw-r--r--  2.0 unx     6253 b- defN 23-Jul-03 07:50 odoo14_addon_shopfloor-14.0.3.0.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-03 07:50 odoo14_addon_shopfloor-14.0.3.0.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        5 b- defN 23-Jul-03 07:50 odoo14_addon_shopfloor-14.0.3.0.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx    20503 b- defN 23-Jul-03 07:50 odoo14_addon_shopfloor-14.0.3.0.0.dist-info/RECORD
+186 files, 2437036 bytes uncompressed, 924321 bytes compressed:  62.1%
```

## zipnote {}

```diff
@@ -3,14 +3,17 @@
 
 Filename: odoo/addons/shopfloor/__init__.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/__manifest__.py
 Comment: 
 
+Filename: odoo/addons/shopfloor/exceptions.py
+Comment: 
+
 Filename: odoo/addons/shopfloor/utils.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/actions/__init__.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/actions/change_package_lot.py
@@ -51,14 +54,17 @@
 
 Filename: odoo/addons/shopfloor/actions/search.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/actions/stock.py
 Comment: 
 
+Filename: odoo/addons/shopfloor/actions/stock_unreserve.py
+Comment: 
+
 Filename: odoo/addons/shopfloor/components/__init__.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/components/scan_handler_location.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/components/scan_handler_lot.py
@@ -84,26 +90,38 @@
 
 Filename: odoo/addons/shopfloor/demo/shopfloor_profile_demo.xml
 Comment: 
 
 Filename: odoo/addons/shopfloor/demo/stock_picking_type_demo.xml
 Comment: 
 
+Filename: odoo/addons/shopfloor/docs/checkout_diag_seq.plantuml
+Comment: 
+
+Filename: odoo/addons/shopfloor/docs/checkout_diag_seq.png
+Comment: 
+
 Filename: odoo/addons/shopfloor/docs/cluster_picking_diag_seq.plantuml
 Comment: 
 
 Filename: odoo/addons/shopfloor/docs/cluster_picking_diag_seq.png
 Comment: 
 
 Filename: odoo/addons/shopfloor/docs/delivery_diag_seq.plantuml
 Comment: 
 
 Filename: odoo/addons/shopfloor/docs/delivery_diag_seq.png
 Comment: 
 
+Filename: odoo/addons/shopfloor/docs/location_content_transfer_diag_seq.plantuml
+Comment: 
+
+Filename: odoo/addons/shopfloor/docs/location_content_transfer_diag_seq.png
+Comment: 
+
 Filename: odoo/addons/shopfloor/docs/oca_logo.png
 Comment: 
 
 Filename: odoo/addons/shopfloor/docs/single_pack_transfer_diag_seq.plantuml
 Comment: 
 
 Filename: odoo/addons/shopfloor/docs/single_pack_transfer_diag_seq.png
@@ -114,14 +132,17 @@
 
 Filename: odoo/addons/shopfloor/docs/zone_picking_diag_seq.png
 Comment: 
 
 Filename: odoo/addons/shopfloor/i18n/ca.po
 Comment: 
 
+Filename: odoo/addons/shopfloor/i18n/de.po
+Comment: 
+
 Filename: odoo/addons/shopfloor/i18n/es_AR.po
 Comment: 
 
 Filename: odoo/addons/shopfloor/i18n/pt_BR.po
 Comment: 
 
 Filename: odoo/addons/shopfloor/i18n/shopfloor.pot
@@ -261,14 +282,20 @@
 
 Filename: odoo/addons/shopfloor/tests/test_actions_data_detail.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/tests/test_actions_search.py
 Comment: 
 
+Filename: odoo/addons/shopfloor/tests/test_actions_stock.py
+Comment: 
+
+Filename: odoo/addons/shopfloor/tests/test_checkout_auto_post.py
+Comment: 
+
 Filename: odoo/addons/shopfloor/tests/test_checkout_base.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/tests/test_checkout_cancel_line.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/tests/test_checkout_change_packaging.py
@@ -294,17 +321,23 @@
 
 Filename: odoo/addons/shopfloor/tests/test_checkout_scan_line.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/tests/test_checkout_scan_line_base.py
 Comment: 
 
+Filename: odoo/addons/shopfloor/tests/test_checkout_scan_line_no_prefill_qty.py
+Comment: 
+
 Filename: odoo/addons/shopfloor/tests/test_checkout_scan_package_action.py
 Comment: 
 
+Filename: odoo/addons/shopfloor/tests/test_checkout_scan_package_action_no_prefill_qty.py
+Comment: 
+
 Filename: odoo/addons/shopfloor/tests/test_checkout_select.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/tests/test_checkout_select_line.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/tests/test_checkout_select_package_base.py
@@ -327,17 +360,26 @@
 
 Filename: odoo/addons/shopfloor/tests/test_cluster_picking_is_zero.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/tests/test_cluster_picking_scan_destination.py
 Comment: 
 
+Filename: odoo/addons/shopfloor/tests/test_cluster_picking_scan_destination_no_prefill_qty.py
+Comment: 
+
 Filename: odoo/addons/shopfloor/tests/test_cluster_picking_scan_line.py
 Comment: 
 
+Filename: odoo/addons/shopfloor/tests/test_cluster_picking_scan_line_location_or_pack_first.py
+Comment: 
+
+Filename: odoo/addons/shopfloor/tests/test_cluster_picking_scan_line_no_prefill_qty.py
+Comment: 
+
 Filename: odoo/addons/shopfloor/tests/test_cluster_picking_select.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/tests/test_cluster_picking_skip.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/tests/test_cluster_picking_stock_issue.py
@@ -375,20 +417,26 @@
 
 Filename: odoo/addons/shopfloor/tests/test_delivery_sublocation.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/tests/test_location_content_transfer_base.py
 Comment: 
 
+Filename: odoo/addons/shopfloor/tests/test_location_content_transfer_get_work.py
+Comment: 
+
 Filename: odoo/addons/shopfloor/tests/test_location_content_transfer_mix.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/tests/test_location_content_transfer_putaway.py
 Comment: 
 
+Filename: odoo/addons/shopfloor/tests/test_location_content_transfer_scan_location.py
+Comment: 
+
 Filename: odoo/addons/shopfloor/tests/test_location_content_transfer_set_destination_all.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/tests/test_location_content_transfer_set_destination_package_or_line.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/tests/test_location_content_transfer_single.py
@@ -438,20 +486,32 @@
 
 Filename: odoo/addons/shopfloor/tests/test_zone_picking_change_pack_lot.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/tests/test_zone_picking_select_line.py
 Comment: 
 
+Filename: odoo/addons/shopfloor/tests/test_zone_picking_select_line_first_scan_location.py
+Comment: 
+
+Filename: odoo/addons/shopfloor/tests/test_zone_picking_select_line_first_scan_location.py.bak
+Comment: 
+
+Filename: odoo/addons/shopfloor/tests/test_zone_picking_select_line_no_prefill_qty.py
+Comment: 
+
 Filename: odoo/addons/shopfloor/tests/test_zone_picking_select_picking_type.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/tests/test_zone_picking_set_line_destination.py
 Comment: 
 
+Filename: odoo/addons/shopfloor/tests/test_zone_picking_set_line_destination_no_prefill_qty.py
+Comment: 
+
 Filename: odoo/addons/shopfloor/tests/test_zone_picking_set_line_destination_pick_pack.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/tests/test_zone_picking_start.py
 Comment: 
 
 Filename: odoo/addons/shopfloor/tests/test_zone_picking_stock_issue.py
@@ -480,20 +540,20 @@
 
 Filename: odoo/addons/shopfloor/views/stock_move_line.xml
 Comment: 
 
 Filename: odoo/addons/shopfloor/views/stock_picking_type.xml
 Comment: 
 
-Filename: odoo14_addon_shopfloor-14.0.2.9.3.dev1.dist-info/METADATA
+Filename: odoo14_addon_shopfloor-14.0.3.0.0.dist-info/METADATA
 Comment: 
 
-Filename: odoo14_addon_shopfloor-14.0.2.9.3.dev1.dist-info/WHEEL
+Filename: odoo14_addon_shopfloor-14.0.3.0.0.dist-info/WHEEL
 Comment: 
 
-Filename: odoo14_addon_shopfloor-14.0.2.9.3.dev1.dist-info/top_level.txt
+Filename: odoo14_addon_shopfloor-14.0.3.0.0.dist-info/top_level.txt
 Comment: 
 
-Filename: odoo14_addon_shopfloor-14.0.2.9.3.dev1.dist-info/RECORD
+Filename: odoo14_addon_shopfloor-14.0.3.0.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## odoo/addons/shopfloor/README.rst

```diff
@@ -36,14 +36,17 @@
 * Location Content Transfer
 * Single Pack Transfer
 
 This module provides REST APIs to support the scenarios. It needs a frontend
 to consume the backend APIs and provide screens for users on barcode devices.
 A default front-end application is provided by ``shopfloor_mobile``.
 
+| Note: if you want to enable a new scenario on an existing application, you must trigger the registry sync on the shopfloor.app in a post_init_hook or a post-migrate script.
+| See an example `here <https://github.com/OCA/wms/pull/520/commits/bccdfd445a9bc943998c4848f183a076e8459a98>`_.
+
 **Table of contents**
 
 .. contents::
    :local:
 
 Usage
 =====
@@ -98,14 +101,16 @@
 * Simone Orsi <simahawk@gmail.com>
 * Sébastien Alix <sebastien.alix@camptocamp.com>
 * Alexandre Fayolle <alexandre.fayolle@camptocamp.com>
 * Benoit Guillot <benoit.guillot@akretion.com>
 * Thierry Ducrest <thierry.ducrest@camptocamp.com>
 * Raphaël Reverdy <raphael.reverdy@akretion.com>
 * Jacques-Etienne Baudoux <je@bcim.be>
+* Juan Miguel Sánchez Arce <juan.sanchez@camptocamp.com>
+* Michael Tietz (MT Software) <mtietz@mt-software.de>
 
 Design
 ~~~~~~
 
 * Joël Grand-Guillaume <joel.grandguillaume@camptocamp.com>
 * Jacques-Etienne Baudoux <je@bcim.be>
```

## odoo/addons/shopfloor/__manifest__.py

```diff
@@ -2,15 +2,15 @@
 # Copyright 2020 Akretion (http://www.akretion.com)
 # Copyright 2020 BCIM
 # License AGPL-3.0 or later (http://www.gnu.org/licenses/agpl.html).
 
 {
     "name": "Shopfloor",
     "summary": "manage warehouse operations with barcode scanners",
-    "version": "14.0.2.9.2",
+    "version": "14.0.3.0.0",
     "development_status": "Beta",
     "category": "Inventory",
     "website": "https://github.com/OCA/wms",
     "author": "Camptocamp, BCIM, Akretion, Odoo Community Association (OCA)",
     "maintainers": ["guewen", "simahawk", "sebalix"],
     "license": "AGPL-3",
     "application": True,
@@ -23,14 +23,15 @@
         "base_sparse_field",
         #  OCA / stock-logistics-warehouse
         "stock_helper",
         "stock_picking_completion_info",
         #  OCA / stock-logistics-workflow
         "stock_quant_package_dimension",
         "stock_quant_package_product_packaging",
+        "stock_picking_progress",
         # TODO: used for manuf info on prod detail.
         # This must be an optional dep
         "product_manufacturer",
         # TODO: used for prod lot expire detail info.
         # This must be an optional dep
         "product_expiry",
         # TODO: used for package.package_storage_type_id detail info.
```

## odoo/addons/shopfloor/utils.py

```diff
@@ -1,10 +1,13 @@
 # Copyright 2020 Camptocamp SA (http://www.camptocamp.com)
 # License AGPL-3.0 or later (http://www.gnu.org/licenses/agpl.html).
 
 
 def to_float(val):
     if isinstance(val, float):
         return val
-    if val:
+    if isinstance(val, int):
         return float(val)
+    if isinstance(val, str):
+        if val.replace(".", "", 1).isdigit():
+            return float(val)
     return None
```

## odoo/addons/shopfloor/actions/__init__.py

```diff
@@ -7,8 +7,9 @@
 from . import location_content_transfer_sorter
 from . import message
 from . import search
 from . import inventory
 from . import savepoint
 from . import move_line_search
 from . import stock
+from . import stock_unreserve
 from . import packaging
```

## odoo/addons/shopfloor/actions/data.py

```diff
@@ -7,39 +7,70 @@
 
 
 class DataAction(Component):
     _inherit = "shopfloor.data.action"
 
     @ensure_model("stock.location")
     def location(self, record, **kw):
-        return self._jsonify(
-            record.with_context(location=record.id), self._location_parser, **kw
-        )
+        parser = self._location_parser
+        data = self._jsonify(record.with_context(location=record.id), parser, **kw)
+        if "with_operation_progress" in kw:
+            operation_progress = self._get_location_operations_progress(record)
+            data.update({"operation_progress": operation_progress})
+        return data
 
     def locations(self, record, **kw):
         return self.location(record, multi=True)
 
+    def _get_location_operations_progress(self, location):
+        lines = self.env["stock.move.line"].search(
+            [
+                ("location_id", "=", location.id),
+                ("state", "in", ["partially_available", "assigned"]),
+                ("picking_id.state", "=", "assigned"),
+            ]
+        )
+        # operations_to_do = number of total operations that are pending for this location.
+        # operations_done = number of operations already done.
+        # A line with an assigned package counts as 1 operation.
+        operations_to_do = 0
+        operations_done = 0
+        for line in lines:
+            operations_done += line.qty_done if not line.package_id else 1
+            operations_to_do += line.product_uom_qty if not line.package_id else 1
+        return {
+            "done": operations_done,
+            "to_do": operations_to_do,
+        }
+
     @property
     def _location_parser(self):
         return [
             "id",
             "name",
             # Fallback to name if barcode is not valued.
             ("barcode", lambda rec, fname: rec[fname] if rec[fname] else rec.name),
         ]
 
     @ensure_model("stock.picking")
     def picking(self, record, **kw):
-        return self._jsonify(record, self._picking_parser, **kw)
+        parser = self._picking_parser
+        # progress is a heavy computed field,
+        # and it may reduce performance significatively
+        # when dealing with a large number of pickings.
+        # Thus, we make it optional.
+        if "with_progress" in kw:
+            parser.append("progress")
+        return self._jsonify(record, parser, **kw)
 
     def pickings(self, record, **kw):
         return self.picking(record, multi=True)
 
     @property
-    def _picking_parser(self):
+    def _picking_parser(self, **kw):
         return [
             "id",
             "name",
             "origin",
             "note",
             ("partner_id:partner", self._partner_parser),
             ("carrier_id:carrier", self._simple_record_parser()),
@@ -60,16 +91,18 @@
         """
         parser = self._package_parser
         if with_packaging:
             parser += self._package_packaging_parser
         data = self._jsonify(record, parser, **kw)
         # handle special cases
         if data and picking:
-            # TODO: exclude canceled and done?
-            lines = picking.move_line_ids.filtered(lambda l: l.package_id == record)
+            lines = picking.move_line_ids.filtered(
+                lambda l: l.result_package_id == record
+                and l.state in ["partially_available", "assigned", "done"]
+            )
             data.update({"move_line_count": len(lines)})
         return data
 
     def packages(self, records, picking=None, **kw):
         return [self.package(rec, picking=picking, **kw) for rec in records]
 
     @property
@@ -127,15 +160,15 @@
         return self._jsonify(record, self._lot_parser, **kw)
 
     def lots(self, record, **kw):
         return self.lot(record, multi=True)
 
     @property
     def _lot_parser(self):
-        return self._simple_record_parser() + ["ref"]
+        return self._simple_record_parser() + ["ref", "expiration_date"]
 
     @ensure_model("stock.move.line")
     def move_line(self, record, with_picking=False, **kw):
         record = record.with_context(location=record.location_id.id)
         parser = self._move_line_parser
         if with_picking:
             parser += [("picking_id:picking", self._picking_parser)]
@@ -172,14 +205,37 @@
             ("lot_id:lot", self._lot_parser),
             ("location_id:location_src", self._location_parser),
             ("location_dest_id:location_dest", self._location_parser),
             (
                 "move_id:priority",
                 lambda rec, fname: rec.move_id.priority or "",
             ),
+            "progress",
+        ]
+
+    @ensure_model("stock.move")
+    def move(self, record, **kw):
+        record = record.with_context(location=record.location_id.id)
+        parser = self._move_parser
+        return self._jsonify(record, parser)
+
+    def moves(self, records, **kw):
+        return [self.move(rec, **kw) for rec in records]
+
+    @property
+    def _move_parser(self):
+        return [
+            "id",
+            "quantity_done",
+            "product_uom_qty:quantity",
+            ("product_id:product", self._product_parser),
+            ("location_id:location_src", self._location_parser),
+            ("location_dest_id:location_dest", self._location_parser),
+            "priority",
+            "progress",
         ]
 
     @ensure_model("stock.package_level")
     def package_level(self, record, **kw):
         return self._jsonify(record, self._package_level_parser)
 
     def package_levels(self, records, **kw):
```

## odoo/addons/shopfloor/actions/data_detail.py

```diff
@@ -28,15 +28,22 @@
                 "reserved_move_line_ids:reserved_move_lines",
                 lambda record, fname: self.move_lines(record[fname]),
             ),
         ]
 
     @ensure_model("stock.picking")
     def picking_detail(self, record, **kw):
-        return self._jsonify(record, self._picking_detail_parser, **kw)
+        parser = self._picking_detail_parser
+        # progress is a heavy computed field,
+        # and it may reduce performance significatively
+        # when dealing with a large number of pickings.
+        # Thus, we make it optional.
+        if "with_progress" in kw:
+            parser.append("progress")
+        return self._jsonify(record, parser, **kw)
 
     def pickings_detail(self, record, **kw):
         return self.picking_detail(record, multi=True)
 
     @property
     def _picking_detail_parser(self):
         return self._picking_parser + [
```

## odoo/addons/shopfloor/actions/message.py

```diff
@@ -1,21 +1,28 @@
 # Copyright 2020 Camptocamp SA (http://www.camptocamp.com)
+# Copyright 2023 Michael Tietz (MT Software) <mtietz@mt-software.de>
 # License AGPL-3.0 or later (http://www.gnu.org/licenses/agpl.html).
 import logging
 
 from odoo import _
 
 from odoo.addons.component.core import Component
 
 _logger = logging.getLogger(__name__)
 
 
 class MessageAction(Component):
     _inherit = "shopfloor.message.action"
 
+    def no_operation_found(self):
+        return {
+            "message_type": "error",
+            "body": _("No operation found for this menu and profile."),
+        }
+
     def no_picking_type(self):
         return {
             "message_type": "error",
             "body": _("No operation type found for this menu and profile."),
         }
 
     def several_picking_types(self):
@@ -45,14 +52,22 @@
             "body": _("You cannot work on a package (%s) outside of locations: %s")
             % (
                 barcode,
                 ", ".join(picking_types.mapped("default_location_src_id.name")),
             ),
         }
 
+    def location_requires_package(self):
+        return {
+            "message_type": "warning",
+            "body": _(
+                "This location requires packages. Please scan a destination package."
+            ),
+        }
+
     def already_running_ask_confirmation(self):
         return {
             "message_type": "warning",
             "body": _("Operation's already running. Would you like to take it over?"),
         }
 
     def scan_destination(self):
@@ -167,14 +182,17 @@
             "message_type": "success",
             "body": _("The pack has been moved, you can scan a new pack."),
         }
 
     def already_done(self):
         return {"message_type": "info", "body": _("Operation already processed.")}
 
+    def move_already_done(self):
+        return {"message_type": "warning", "body": _("Move already processed.")}
+
     def confirm_canceled_scan_next_pack(self):
         return {
             "message_type": "success",
             "body": _("Canceled, you can scan a new pack."),
         }
 
     def no_pack_in_location(self, location):
@@ -213,14 +231,15 @@
 
     def _wrong_record_msg(self, model_name):
         return {
             "product.product": _("Wrong product."),
             "stock.production.lot": _("Wrong lot."),
             "stock.location": _("Wrong location."),
             "stock.quant.package": _("Wrong pack."),
+            "product.packaging": _("Wrong packaging."),
         }.get(model_name, _("Wrong."))
 
     def wrong_record(self, record):
         return {"message_type": "error", "body": self._wrong_record_msg(record._name)}
 
     def no_lot_for_barcode(self, barcode):
         return {
@@ -349,41 +368,127 @@
 
     def line_has_package_scan_package(self):
         return {
             "message_type": "warning",
             "body": _("This line has a package, please select the package instead."),
         }
 
+    def scan_the_location_first(self):
+        return {
+            "message_type": "warning",
+            "body": _("Please scan the location first."),
+        }
+
+    def scan_the_package(self):
+        return {
+            "message_type": "warning",
+            "body": _("Please scan the package."),
+        }
+
     def product_multiple_packages_scan_package(self):
         return {
             "message_type": "warning",
             "body": _(
                 _("This product is part of multiple packages, please scan a package.")
             ),
         }
 
+    def source_document_multiple_pickings_scan_package(self):
+        return {
+            "message_type": "warning",
+            "body": _(
+                _(
+                    "This source document is part of multiple transfers, please scan a package."
+                )
+            ),
+        }
+
     def product_mixed_package_scan_package(self):
         return {
             "message_type": "warning",
             "body": _(
                 "This product is part of a package with other products, "
                 "please scan a package."
             ),
         }
 
+    def product_not_unitary_in_package_scan_package(self):
+        return {
+            "message_type": "warning",
+            "body": _("This product is part of a package, please scan a package."),
+        }
+
     def product_not_found(self):
         return {
             "message_type": "error",
             "body": _("This product does not exist anymore."),
         }
 
     def product_not_found_in_pickings(self):
         return {
             "message_type": "warning",
-            "body": _("No product found among current transfers."),
+            "body": _("No transfer found for this product."),
+        }
+
+    def x_not_found_or_already_in_dest_package(self, message_code):
+        return {
+            "message_type": "warning",
+            "body": _(
+                "{} not found in the current transfer or already in a package.".format(
+                    message_code
+                )
+            ),
+        }
+
+    def packaging_not_found_in_picking(self):
+        return {
+            "message_type": "warning",
+            "body": _("Packaging not found in the current transfer."),
+        }
+
+    def expiration_date_missing(self):
+        return {
+            "message_type": "error",
+            "body": _("Missing expiration date."),
+        }
+
+    def multiple_picks_found_select_manually(self):
+        return {
+            "message_type": "error",
+            "body": _("Several transfers found, please select a transfer manually."),
+        }
+
+    def no_transfer_for_packaging(self):
+        return {
+            "message_type": "error",
+            "body": _("No transfer found for the scanned packaging."),
+        }
+
+    def no_transfer_for_lot(self):
+        return {
+            "message_type": "error",
+            "body": _("No transfer found for the scanned lot."),
+        }
+
+    def create_new_pack_ask_confirmation(self, barcode):
+        return {
+            "message_type": "warning",
+            "body": _("Create new PACK {}? Scan it again to confirm.").format(barcode),
+        }
+
+    def place_in_location_ask_confirmation(self, location_name):
+        return {
+            "message_type": "warning",
+            "body": _("Place it in {}?").format(location_name),
+        }
+
+    def product_not_found_in_current_picking(self):
+        return {
+            "message_type": "error",
+            "body": _("Product is not in the current transfer."),
         }
 
     def lot_mixed_package_scan_package(self):
         return {
             "message_type": "warning",
             "body": _(
                 "This lot is part of a package with other products, "
@@ -393,24 +498,18 @@
 
     def lot_multiple_packages_scan_package(self):
         return {
             "message_type": "warning",
             "body": _("This lot is part of multiple packages, please scan a package."),
         }
 
-    def lot_not_found(self):
-        return {
-            "message_type": "error",
-            "body": _("This lot does not exist anymore."),
-        }
-
     def lot_not_found_in_pickings(self):
         return {
             "message_type": "warning",
-            "body": _("No lot found among current transfers."),
+            "body": _("No transfer found for this lot."),
         }
 
     def batch_transfer_complete(self):
         return {
             "message_type": "success",
             "body": _("Batch Transfer complete"),
         }
@@ -462,14 +561,23 @@
             "message_type": "warning",
             "body": _(
                 "Lot {lot} for product {product} found in multiple locations. "
                 "Scan your location first."
             ).format(lot=lot.name, product=lot.product_id.name),
         }
 
+    def no_default_location_on_picking_type(self):
+        return {
+            "message_type": "error",
+            "body": _(
+                "Operation types for this menu are missing "
+                "default source and destination locations."
+            ),
+        }
+
     def location_src_set_to_sublocation(self, location_src):
         return {
             "message_type": "success",
             "body": _("Working location changed to {}").format(location_src.name),
         }
 
     def picking_already_started_in_location(self, pickings):
@@ -491,22 +599,57 @@
             "message_type": "warning",
             "body": _(
                 "Not all lines have been processed with full quantity. "
                 "Do you confirm partial operation?"
             ),
         }
 
+    def move_already_returned(self):
+        return {
+            "message_type": "error",
+            "body": _("The product/packaging you selected has already been returned."),
+        }
+
+    def return_line_invalid_qty(self):
+        return {
+            "message_type": "error",
+            "body": _("You cannot return more quantity than what was initially sent."),
+        }
+
     def transfer_no_qty_done(self):
         return {
             "message_type": "warning",
             "body": _(
                 "No quantity has been processed, unable to complete the transfer."
             ),
         }
 
+    def picking_zero_quantity(self):
+        return {
+            "message_type": "error",
+            "body": _("The picked quantity must be a value above zero."),
+        }
+
+    def selected_lines_qty_done_higher_than_allowed(self):
+        return {
+            "message_type": "warning",
+            "body": _(
+                "The quantity scanned for one or more lines cannot be "
+                "higher than the maximum allowed."
+            ),
+        }
+
+    def line_scanned_qty_done_higher_than_allowed(self):
+        return {
+            "message_type": "warning",
+            "body": _(
+                "Please note that the scanned quantity is higher than the maximum allowed."
+            ),
+        }
+
     def recovered_previous_session(self):
         return {
             "message_type": "info",
             "body": _("Recovered previous session."),
         }
 
     def no_lines_to_process(self):
@@ -517,14 +660,26 @@
 
     def location_empty(self, location):
         return {
             "message_type": "error",
             "body": _("Location {} empty").format(location.name),
         }
 
+    def location_empty_scan_package(self, location):
+        return {
+            "message_type": "warning",
+            "body": _("Location empty. Try scanning a package"),
+        }
+
+    def location_not_found(self):
+        return {
+            "message_type": "error",
+            "body": _("This location does not exist."),
+        }
+
     def unable_to_pick_more(self, quantity):
         return {
             "message_type": "error",
             "body": _("You must not pick more than {} units.").format(quantity),
         }
 
     def lot_replaced_by_lot(self, old_lot, new_lot):
@@ -641,7 +796,35 @@
         return {
             "message_type": "error",
             "body": _(
                 "Pick + Pack mode ON: the picking {0.name} has no carrier set. "
                 "The system couldn't pack goods automatically."
             ).format(picking),
         }
+
+    def no_work_found(self):
+        return {
+            "message_type": "warning",
+            "body": _("No available work could be found."),
+        }
+
+    def confirm_put_all_goods_in_delivery_package(self, packaging_type):
+        return {
+            "message_type": "warning",
+            "body": _(
+                "Delivery package type scanned: %(name)s. "
+                "Scan again to place all goods in the same package."
+            )
+            % dict(name=packaging_type.name),
+        }
+
+    def location_contains_only_packages_scan_one(self):
+        return {
+            "message_type": "warning",
+            "body": _("This location only contains packages, please scan one of them."),
+        }
+
+    def no_line_to_pack(self):
+        return {
+            "message_type": "warning",
+            "body": _("No line to pack found."),
+        }
```

## odoo/addons/shopfloor/actions/move_line_search.py

```diff
@@ -25,27 +25,29 @@
         locations,
         picking_type=None,
         package=None,
         product=None,
         lot=None,
         match_user=False,
         picking_ready=True,
+        # When True, adds the package in the domain even if the package is False
+        enforce_empty_package=False,
     ):
         domain = [
             ("location_id", "child_of", locations.ids),
             ("qty_done", "=", 0),
             ("state", "in", ("assigned", "partially_available")),
         ]
         if picking_type:
             # auto_join in place for this field
             domain += [("picking_id.picking_type_id", "=", picking_type.id)]
         elif self.picking_types:
             domain += [("picking_id.picking_type_id", "in", self.picking_types.ids)]
-        if package:
-            domain += [("package_id", "=", package.id)]
+        if package or package is not None and enforce_empty_package:
+            domain += [("package_id", "=", package.id if package else False)]
         if product:
             domain += [("product_id", "=", product.id)]
         if lot:
             domain += [("lot_id", "=", lot.id)]
         if match_user:
             domain += [
                 "|",
@@ -63,25 +65,27 @@
         package=None,
         product=None,
         lot=None,
         order="priority",
         match_user=False,
         sort_keys_func=None,
         picking_ready=True,
+        enforce_empty_package=False,
     ):
         """Find lines that potentially need work in given locations."""
         move_lines = self.env["stock.move.line"].search(
             self._search_move_lines_by_location_domain(
                 locations,
                 picking_type,
                 package,
                 product,
                 lot,
                 match_user=match_user,
                 picking_ready=picking_ready,
+                enforce_empty_package=enforce_empty_package,
             )
         )
         sort_keys_func = sort_keys_func or self._sort_key_move_lines(order)
         move_lines = move_lines.sorted(sort_keys_func)
         return move_lines
 
     @staticmethod
```

## odoo/addons/shopfloor/actions/schema.py

```diff
@@ -21,14 +21,15 @@
             },
             "bulk_line_count": {"type": "integer", "nullable": True, "required": True},
             "weight": {"required": True, "nullable": True, "type": "float"},
             "partner": self._schema_dict_of(self._simple_record()),
             "carrier": self._schema_dict_of(self._simple_record(), required=False),
             "ship_carrier": self._schema_dict_of(self._simple_record(), required=False),
             "scheduled_date": {"type": "string", "nullable": False, "required": True},
+            "progress": {"type": "float", "nullable": True},
         }
 
     def move_line(self, with_packaging=False, with_picking=False):
         schema = {
             "id": {"type": "integer", "required": True},
             "qty_done": {"type": "float", "required": True},
             "quantity": {"type": "float", "required": True},
@@ -44,23 +45,30 @@
             ),
             "package_dest": self._schema_dict_of(
                 self.package(with_packaging=with_packaging), required=False
             ),
             "location_src": self._schema_dict_of(self.location()),
             "location_dest": self._schema_dict_of(self.location()),
             "priority": {"type": "string", "nullable": True, "required": False},
+            "progress": {"type": "float", "nullable": True},
         }
         if with_picking:
             schema["picking"] = self._schema_dict_of(self.picking())
         return schema
 
     def move(self):
         return {
             "id": {"required": True, "type": "integer"},
             "priority": {"type": "string", "required": False, "nullable": True},
+            "quantity_done": {"type": "float", "required": True},
+            "quantity": {"type": "float", "required": True},
+            "product": self._schema_dict_of(self.product()),
+            "location_src": self._schema_dict_of(self.location()),
+            "location_dest": self._schema_dict_of(self.location()),
+            "progress": {"type": "float", "nullable": True},
         }
 
     def product(self):
         return {
             "id": {"required": True, "type": "integer"},
             "name": {"type": "string", "nullable": False, "required": True},
             "display_name": {"type": "string", "nullable": False, "required": True},
@@ -89,21 +97,30 @@
         return schema
 
     def lot(self):
         return {
             "id": {"required": True, "type": "integer"},
             "name": {"type": "string", "nullable": False, "required": True},
             "ref": {"type": "string", "nullable": True, "required": False},
+            "expiration_date": {"type": "string", "nullable": True, "required": False},
         }
 
     def location(self):
         return {
             "id": {"required": True, "type": "integer"},
             "name": {"type": "string", "nullable": False, "required": True},
             "barcode": {"type": "string", "nullable": True, "required": False},
+            "operation_progress": {
+                "type": "dict",
+                "required": False,
+                "schema": {
+                    "done": {"type": "float", "required": False},
+                    "to_do": {"type": "float", "required": False},
+                },
+            },
         }
 
     def packaging(self):
         return {
             "id": {"required": True, "type": "integer"},
             "name": {"type": "string", "nullable": False, "required": True},
             "code": {"type": "string", "nullable": True, "required": True},
```

## odoo/addons/shopfloor/actions/search.py

```diff
@@ -1,22 +1,96 @@
 # Copyright 2020 Camptocamp SA (http://www.camptocamp.com)
 # License AGPL-3.0 or later (http://www.gnu.org/licenses/agpl.html).
+
+from odoo.osv.expression import AND
+
 from odoo.addons.component.core import Component
 
 
+class SearchResult:
+
+    __slots__ = ("record", "type", "code")
+
+    def __init__(self, **kw) -> None:
+        for k in self.__slots__:
+            setattr(self, k, kw.get(k))
+
+    def __repr__(self) -> str:
+        return f"<{self.__class__.__name__}: type={self.type} code={self.code}>"
+
+    def __bool__(self):
+        return self.type != "none" or bool(self.record)
+
+    def __eq__(self, other):
+        for k in self.__slots__:
+            if not hasattr(other, k):
+                return False
+            if getattr(other, k) != getattr(self, k):
+                return False
+        return True
+
+    @property
+    def records(self):
+        """In some cases we expect more than one records (eg: location limit > 1) or lots"""
+        return self.record if len(self.record) > 1 else None
+
+
 class SearchAction(Component):
     """Provide methods to search records from scanner
 
     The methods should be used in Service Components, so a search will always
     have the same result in all scenarios.
     """
 
     _inherit = "shopfloor.search.action"
 
-    # TODO: these methods shall be probably replaced by scan anything handlers
+    @property
+    def _barcode_type_handler(self):
+        return {
+            "product": self.product_from_scan,
+            "package": self.package_from_scan,
+            "picking": self.picking_from_scan,
+            "location": self.location_from_scan,
+            "location_dest": self.location_from_scan,
+            "lot": self.lot_from_scan,
+            "serial": self.lot_from_scan,
+            "packaging": self.packaging_from_scan,
+            "delivery_packaging": self.generic_packaging_from_scan,
+            "origin_move": self.origin_move_from_scan,
+        }
+
+    def _make_search_result(self, **kwargs):
+        """Build a 'SearchResult' object describing the record found.
+
+        If no record has been found, the SearchResult object will have
+        its 'type' defined to "none".
+        """
+        return SearchResult(**kwargs)
+
+    def find(self, barcode, types=None, handler_kw=None):
+        """Find Odoo record matching given `barcode`.
+
+        Plain barcodes
+        """
+        barcode = barcode or ""
+        return self.generic_find(barcode, types=types, handler_kw=handler_kw)
+
+    def generic_find(self, barcode, types=None, handler_kw=None):
+        handler_kw = handler_kw or {}
+        _types = types or self._barcode_type_handler.keys()
+        # TODO: decide the best default order in case we don't pass `types`
+        for btype in _types:
+            handler = self._barcode_type_handler.get(btype)
+            if not handler:
+                continue
+            record = handler(barcode, **handler_kw.get(btype, {}))
+            if record:
+                return self._make_search_result(record=record, code=barcode, type=btype)
+
+        return self._make_search_result(type="none")
 
     def location_from_scan(self, barcode, limit=1):
         model = self.env["stock.location"]
         if not barcode:
             return model.browse()
         # First search location by barcode
         res = model.search([("barcode", "=", barcode)], limit=limit)
@@ -27,29 +101,48 @@
 
     def package_from_scan(self, barcode):
         model = self.env["stock.quant.package"]
         if not barcode:
             return model.browse()
         return model.search([("name", "=", barcode)], limit=1)
 
-    def picking_from_scan(self, barcode):
+    def picking_from_scan(self, barcode, use_origin=False):
         model = self.env["stock.picking"]
         if not barcode:
             return model.browse()
-        return model.search([("name", "=", barcode)], limit=1)
+        picking = model.search([("name", "=", barcode)], limit=1)
+        # We need to split the domain in two different searches
+        # as there might be a case where
+        # the name of a picking is the same as the origin of another picking
+        # (e.g. in a backorder) and we need to make sure
+        # the name search takes priority.
+        if picking:
+            return picking
+        if use_origin:
+            source_document_domain = [
+                # We could have the same origin for multiple transfers
+                # but we're interested only in the "assigned" ones.
+                ("origin", "=", barcode),
+                ("state", "=", "assigned"),
+            ]
+            return model.search(source_document_domain)
+        return model.browse()
 
-    def product_from_scan(self, barcode, use_packaging=True):
+    def product_from_scan(self, barcode):
         model = self.env["product.product"]
         if not barcode:
             return model.browse()
-        product = model.search([("barcode", "=", barcode)], limit=1)
-        if not product and use_packaging:
-            packaging = self.packaging_from_scan(barcode)
-            product = packaging.product_id
-        return product
+        return model.search(
+            [
+                "|",
+                ("barcode", "=", barcode),
+                ("default_code", "=", barcode),
+            ],
+            limit=1,
+        )
 
     def lot_from_scan(self, barcode, products=None, limit=1):
         model = self.env["stock.production.lot"]
         if not barcode:
             return model.browse()
         domain = [
             ("company_id", "=", self.env.company.id),
@@ -70,7 +163,19 @@
     def generic_packaging_from_scan(self, barcode):
         model = self.env["product.packaging"]
         if not barcode:
             return model.browse()
         return model.search(
             [("barcode", "=", barcode), ("product_id", "=", False)], limit=1
         )
+
+    def origin_move_from_scan(self, barcode, extra_domain=None):
+        model = self.env["stock.move"]
+        outgoing_move_domain = [
+            # We could have the same origin for multiple transfers
+            # but we're interested only in the "done" ones.
+            ("origin", "=", barcode),
+            ("state", "=", "done"),
+        ]
+        if extra_domain:
+            outgoing_move_domain = AND([outgoing_move_domain, extra_domain])
+        return model.search(outgoing_move_domain)
```

## odoo/addons/shopfloor/actions/stock.py

```diff
@@ -1,24 +1,127 @@
 # Copyright 2020 Camptocamp SA (http://www.camptocamp.com)
 # License AGPL-3.0 or later (http://www.gnu.org/licenses/agpl.html).
+from odoo import _, fields
+from odoo.tools.float_utils import float_round
+
 from odoo.addons.component.core import Component
 
+from ..exceptions import ConcurentWorkOnTransfer
+
 
 class StockAction(Component):
     """Provide methods to work with stock operations."""
 
     _name = "shopfloor.stock.action"
     _inherit = "shopfloor.process.action"
     _usage = "stock"
 
+    def _create_return_move__get_max_qty(self, origin_move):
+        """Returns the max returneable qty."""
+        # The max returnable qty is the sent qty minus the already returned qties
+        quantity = origin_move.product_qty
+        for move in origin_move.move_dest_ids:
+            if (
+                move.origin_returned_move_id
+                and move.origin_returned_move_id != origin_move
+            ):
+                continue
+            if move.state in ("partially_available", "assigned"):
+                quantity -= sum(move.move_line_ids.mapped("product_qty"))
+            elif move.state in ("done"):
+                quantity -= move.product_qty
+        return float_round(
+            quantity, precision_rounding=origin_move.product_id.uom_id.rounding
+        )
+
+    def _create_return_move__get_vals(self, return_picking, origin_move):
+        product = origin_move.product_id
+        return_type = return_picking.picking_type_id
+        return {
+            "product_id": product.id,
+            "product_uom": product.uom_id.id,
+            "picking_id": return_picking.id,
+            "state": "draft",
+            "date": fields.Datetime.now(),
+            "location_id": return_picking.location_id.id,
+            "location_dest_id": return_picking.location_dest_id.id,
+            "picking_type_id": return_type.id,
+            "warehouse_id": return_type.warehouse_id.id,
+            "origin_returned_move_id": origin_move.id,
+            "procure_method": "make_to_stock",
+        }
+
+    def _create_return_move__link_to_origin(self, return_move, origin_move):
+        move_orig_to_link = origin_move.move_dest_ids.mapped("returned_move_ids")
+        move_orig_to_link |= origin_move
+        origin_move_dest = origin_move.move_dest_ids.filtered(
+            lambda m: m.state not in ("cancel")
+        )
+        move_orig_to_link |= origin_move_dest.move_orig_ids.filtered(
+            lambda m: m.state not in ("cancel")
+        )
+        move_dest_to_link = origin_move.move_orig_ids.mapped("returned_move_ids")
+        move_dest_orig = origin_move.returned_move_ids.move_orig_ids.filtered(
+            lambda m: m.state not in ("cancel")
+        )
+        move_dest_to_link |= move_dest_orig.move_dest_ids.filtered(
+            lambda m: m.state not in ("cancel")
+        )
+        write_vals = {
+            "move_orig_ids": [(4, m.id) for m in move_orig_to_link],
+            "move_dest_ids": [(4, m.id) for m in move_dest_to_link],
+        }
+        return_move.write(write_vals)
+
+    def create_return_move(self, return_picking, origin_moves):
+        """Creates a return move for a given return picking / move"""
+        # Logic has been copied from
+        # odoo_src/addons/stock/wizard/stock_picking_return.py
+        for origin_move in origin_moves:
+            # If max qty <= 0, it means that everything has been returned already.
+            # Try with the next one from the recordset.
+            max_qty = self._create_return_move__get_max_qty(origin_move)
+            if max_qty > 0:
+                return_move_vals = self._create_return_move__get_vals(
+                    return_picking, origin_move
+                )
+                return_move_vals.update(product_uom_qty=max_qty)
+                return_move = origin_move.copy(return_move_vals)
+                self._create_return_move__link_to_origin(return_move, origin_move)
+                return return_move
+
+    def _create_return_picking__get_vals(self, return_types, origin):
+        return_type = fields.first(return_types)
+        return {
+            "move_lines": [],
+            "picking_type_id": return_type.id,
+            "state": "draft",
+            "origin": origin,
+            "location_id": return_type.default_location_src_id.id,
+            "location_dest_id": return_type.default_location_dest_id.id,
+            "is_shopfloor_created": True,
+        }
+
+    def create_return_picking(self, picking, return_types, origin):
+        # Logic has been copied from
+        # odoo_src/addons/stock/wizard/stock_picking_return.py
+        return_values = self._create_return_picking__get_vals(return_types, origin)
+        return picking.copy(return_values)
+
     def mark_move_line_as_picked(
-        self, move_lines, quantity=None, package=None, user=None
+        self, move_lines, quantity=None, package=None, user=None, check_user=False
     ):
         """Set the qty_done and extract lines in new order"""
         user = user or self.env.user
+        if check_user:
+            picking_users = move_lines.picking_id.user_id
+            if not all(pick_user == user for pick_user in picking_users):
+                raise ConcurentWorkOnTransfer(
+                    _("Someone is already working on these transfers")
+                )
         for line in move_lines:
             qty_done = quantity if quantity is not None else line.product_uom_qty
             line.qty_done = qty_done
             line._split_partial_quantity()
             data = {
                 "shopfloor_user_id": user.id,
             }
@@ -31,14 +134,41 @@
             {
                 "user_id": user.id,
                 "printed": True,
             }
         )
         move_lines.picking_id.filtered(lambda p: p.user_id != user).user_id = user.id
 
+    def unmark_move_line_as_picked(self, move_lines):
+        """Reverse the change from `mark_move_line_as_picked`."""
+        move_lines.write(
+            {
+                "shopfloor_user_id": False,
+                "qty_done": 0,
+                "result_package_id": False,
+            }
+        )
+        pickings = move_lines.picking_id
+        for picking in pickings:
+            lines_still_assigned = picking.move_line_ids.filtered(
+                lambda l: l.shopfloor_user_id
+            )
+            if lines_still_assigned:
+                # Because there is other lines in the picking still assigned
+                # The picking has to be split
+                unmark_lines = picking.move_line_ids & move_lines
+                unmark_lines._extract_in_split_order(default={"user_id": False})
+            else:
+                pickings.write(
+                    {
+                        "user_id": False,
+                        "printed": False,
+                    }
+                )
+
     def validate_moves(self, moves):
         """Validate moves in different ways depending on several criterias:
 
         - moves to process are all the moves of the related transfer:
             the current transfer is validated
         - moves to process are a subset of available moves in the picking:
             the moves are put in a new transfer which is validated, the current
@@ -46,15 +176,19 @@
         - moves to process are exactly the assigned moves of the related transfer:
             the transfer is validated as usual, creating a backorder.
         """
         moves.split_unavailable_qty()
         for picking in moves.picking_id:
             moves_todo = picking.move_lines & moves
             if self._check_backorder(picking, moves_todo):
+                existing_backorders = picking.backorder_ids
                 picking._action_done()
+                new_backorders = picking.backorder_ids - existing_backorders
+                if new_backorders:
+                    new_backorders.write({"user_id": False})
             else:
                 moves_todo.extract_and_action_done()
 
     def _check_backorder(self, picking, moves):
         """Check if the `picking` has to be validated as usual to create a backorder.
 
         We want to create a normal backorder if:
```

## odoo/addons/shopfloor/components/scan_handler_location.py

```diff
@@ -11,15 +11,16 @@
 
     _name = "shopfloor.scan.location.handler"
     _inherit = "shopfloor.scan.anything.handler"
 
     record_type = "location"
 
     def search(self, identifier):
-        return self._search.location_from_scan(identifier)
+        res = self._search.find(identifier, types=("location",))
+        return res.record if res.record else self.env["stock.location"]
 
     @property
     def converter(self):
         return self._data_detail.location_detail
 
     def schema(self):
         return self._schema_detail.location_detail()
```

## odoo/addons/shopfloor/components/scan_handler_lot.py

```diff
@@ -11,15 +11,16 @@
 
     _name = "shopfloor.scan.lot.handler"
     _inherit = "shopfloor.scan.anything.handler"
 
     record_type = "lot"
 
     def search(self, identifier):
-        return self._search.lot_from_scan(identifier)
+        res = self._search.find(identifier, types=("lot",))
+        return res.record if res.record else self.env["stock.production.lot"]
 
     @property
     def converter(self):
         return self._data_detail.lot_detail
 
     def schema(self):
         return self._schema_detail.lot_detail()
```

## odoo/addons/shopfloor/components/scan_handler_package.py

```diff
@@ -11,15 +11,16 @@
 
     _name = "shopfloor.scan.package.handler"
     _inherit = "shopfloor.scan.anything.handler"
 
     record_type = "package"
 
     def search(self, identifier):
-        return self._search.package_from_scan(identifier)
+        res = self._search.find(identifier, types=("package",))
+        return res.record if res.record else self.env["stock.quant.package"]
 
     @property
     def converter(self):
         return self._data_detail.package_detail
 
     def schema(self):
         return self._schema_detail.package_detail()
```

## odoo/addons/shopfloor/components/scan_handler_product.py

```diff
@@ -11,15 +11,16 @@
 
     _name = "shopfloor.scan.product.handler"
     _inherit = "shopfloor.scan.anything.handler"
 
     record_type = "product"
 
     def search(self, identifier):
-        return self._search.product_from_scan(identifier)
+        res = self._search.find(identifier, types=("product", "packaging"))
+        return res.record if res.record else self.env["product.product"]
 
     @property
     def converter(self):
         return self._data_detail.product_detail
 
     def schema(self):
         return self._schema_detail.product_detail()
```

## odoo/addons/shopfloor/components/scan_handler_transfer.py

```diff
@@ -11,15 +11,16 @@
 
     _name = "shopfloor.scan.transfer.handler"
     _inherit = "shopfloor.scan.anything.handler"
 
     record_type = "transfer"
 
     def search(self, identifier):
-        return self._search.picking_from_scan(identifier)
+        res = self._search.find(identifier, types=("picking",))
+        return res.record if res.record else self.env["stock.picking"]
 
     @property
     def converter(self):
         return self._data_detail.picking_detail
 
     def schema(self):
         return self._schema_detail.picking_detail()
```

## odoo/addons/shopfloor/data/shopfloor_scenario_data.xml

### odoo/addons/shopfloor/data/shopfloor_scenario_data.xml

```diff
@@ -12,28 +12,37 @@
   </record>
   <record id="scenario_zone_picking" model="shopfloor.scenario">
     <field name="name">Zone Picking</field>
     <field name="key">zone_picking</field>
     <field name="options_edit">{
     &quot;pick_pack_same_time&quot;: true,
     &quot;unload_package_at_destination&quot;: true,
-    &quot;multiple_move_single_pack&quot;: true
+    &quot;multiple_move_single_pack&quot;: true,
+    &quot;no_prefill_qty&quot;: true,
+    &quot;scan_location_or_pack_first&quot;: true
 }</field>
   </record>
   <record id="scenario_cluster_picking" model="shopfloor.scenario">
     <field name="name">Cluster Picking</field>
     <field name="key">cluster_picking</field>
     <field name="options_edit">{
     &quot;unload_package_at_destination&quot;: true,
-    &quot;multiple_move_single_pack&quot;: true
+    &quot;multiple_move_single_pack&quot;: true,
+    &quot;no_prefill_qty&quot;: true,
+    &quot;scan_location_or_pack_first&quot;: true
 }</field>
   </record>
   <record id="scenario_checkout" model="shopfloor.scenario">
     <field name="name">Checkout</field>
     <field name="key">checkout</field>
+    <field name="options_edit">{
+    &quot;no_prefill_qty&quot;: true,
+    &quot;show_oneline_package_content&quot;: true,
+    &quot;auto_post_line&quot;: true
+}</field>
   </record>
   <record id="scenario_delivery" model="shopfloor.scenario">
     <field name="name">Delivery</field>
     <field name="key">delivery</field>
     <field name="options_edit">{
     &quot;must_move_entire_pack&quot;: true,
     &quot;allow_prepackaged_product&quot;: true
@@ -41,11 +50,13 @@
   </record>
   <record id="scenario_location_content_transfer" model="shopfloor.scenario">
     <field name="name">Location content transfer</field>
     <field name="key">location_content_transfer</field>
     <field name="options_edit">{
     &quot;allow_create_moves&quot;: true,
     &quot;allow_unreserve_other_moves&quot;: true,
-    &quot;allow_ignore_no_putaway_available&quot;: true
+    &quot;allow_ignore_no_putaway_available&quot;: true,
+    &quot;allow_get_work&quot;: true,
+    &quot;no_prefill_qty&quot;: true
 }</field>
   </record>
 </odoo>
```

## odoo/addons/shopfloor/i18n/ca.po

```diff
@@ -25,23 +25,42 @@
 "\n"
 "* if a location is scanned, a new delivery package is created;\n"
 "* if a package is scanned, the package is validated against the carrier\n"
 "* in both cases, if the picking has no carrier the operation fails.\",\n"
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__no_prefill_qty
+msgid ""
+"\n"
+"We assume the picker will take the suggested quantities.\n"
+"With this option, the operator will have to enter the quantity manually or\n"
+"by scanning a product or product packaging EAN to increase the quantity\n"
+"(i.e. +1 Unit or +1 Box)\n"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__multiple_move_single_pack
 msgid ""
 "\n"
 "When picking a move,\n"
 "allow to set a destination package that was already used for the other "
 "lines.\n"
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__auto_post_line
+msgid ""
+"\n"
+"When setting result pack & destination,\n"
+"automatically post the corresponding line\n"
+"if this option is checked.\n"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__unload_package_at_destination
 msgid ""
 "\n"
 "With this option, the lines you process by putting on a package during the\n"
 "picking process will be put as bulk products at the final destination "
 "location.\n"
 "\n"
@@ -52,22 +71,14 @@
 "Incompatible with: \"Pick and pack at the same time\"\n"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/models/shopfloor_menu.py:0
 #, python-format
 msgid ""
-"'Multiple moves same destination package' is mandatory when 'Pick and pack "
-"at the same time' is set."
-msgstr ""
-
-#. module: shopfloor
-#: code:addons/shopfloor/models/shopfloor_menu.py:0
-#, python-format
-msgid ""
 "'Pick and pack at the same time' is incompatible with 'Multiple moves same "
 "destination package'."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/models/shopfloor_menu.py:0
 #, python-format
@@ -106,35 +117,60 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "All packages processed."
 msgstr "Processats tots els paquets."
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_alternative_destination_is_possible
+msgid "Allow Alternative Destination Is Possible"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_force_reservation_is_possible
 msgid "Allow Force Reservation Is Possible"
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_get_work_is_possible
+msgid "Allow Get Work Is Possible"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_move_create
 msgid "Allow Move Creation"
 msgstr "Permetre creació de moviment"
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_unreserve_other_moves
 msgid "Allow to process reserved quantities"
 msgstr "Permetre processar quantitats reservades"
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_alternative_destination
+msgid "Allow to scan alternative destination locations"
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Are you sure?"
 msgstr "Esteu segur?"
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__auto_post_line_is_possible
+msgid "Auto Post Line Is Possible"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__auto_post_line
+msgid "Automatically post line"
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Barcode does not match with {}."
 msgstr "Codi de barres no coincideix amb {}."
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
@@ -227,14 +263,20 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/inventory.py:0
 #, python-format
 msgid "Control stock issue in location {} for {}"
 msgstr "Error de control d'estoc a la ubicació {} a {}"
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Create new PACK {}? Scan it again to confirm."
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/models/shopfloor_menu.py:0
 #, python-format
 msgid "Creation of moves is not allowed for menu {}."
 msgstr "La creació de moviments no està permesa pel menú {}."
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_move_line__date_planned
@@ -245,14 +287,32 @@
 #: model:shopfloor.menu,name:shopfloor.shopfloor_menu_demo_delivery
 #: model:shopfloor.scenario,name:shopfloor.scenario_delivery
 #: model:stock.picking.type,name:shopfloor.picking_type_delivery_demo
 msgid "Delivery"
 msgstr "Lliurament"
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid ""
+"Delivery package type scanned: %(name)s. Scan again to place all goods in "
+"the same package."
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__disable_full_bin_action_is_possible
+msgid "Disable Full Bin Action Is Possible"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__disable_full_bin_action
+msgid "Disable full bin action"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_app__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_priority_postpone_mixin__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_inventory__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_location__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_move__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_move_line__display_name
@@ -262,14 +322,24 @@
 #: model:ir.model.fields,field_description:shopfloor.field_stock_picking_type__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_quant__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_quant_package__display_name
 msgid "Display Name"
 msgstr "Nom a mostrar"
 
 #. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__show_oneline_package_content
+msgid "Display the content of package if it contains 1 line only"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__no_prefill_qty
+msgid "Do not pre-fill quantity to pick"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,help:shopfloor.field_stock_picking_type__shopfloor_zero_check
 msgid ""
 "For Shopfloor scenarios using it (Cluster Picking, Zone Picking, Discrete "
 "order Picking), the zero check step will be activated when a location "
 "becomes empty after a move."
 msgstr ""
 
@@ -400,14 +470,20 @@
 #: model:shopfloor.scenario,name:shopfloor.scenario_location_content_transfer
 msgid "Location content transfer"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "Location empty. Try scanning a package"
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "Location not allowed here."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Location {} empty"
@@ -453,14 +529,20 @@
 
 #. module: shopfloor
 #: model:ir.model,name:shopfloor.model_shopfloor_menu
 msgid "Menu displayed in the scanner application"
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Missing expiration date."
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__move_create_is_possible
 msgid "Move Create Is Possible"
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_quant_package__move_line_ids
 msgid "Move Line"
@@ -469,14 +551,20 @@
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_picking__move_line_count
 #: model:ir.model.fields,field_description:shopfloor.field_stock_picking_batch__move_line_count
 msgid "Move Line Count"
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Move already processed."
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/models/stock_move_line.py:0
 #, python-format
 msgid "Move lines processed have to share the same source location."
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__multiple_move_single_pack_is_possible
@@ -492,35 +580,46 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "New move lines cannot be assigned: canceled."
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__no_prefill_qty_is_possible
+msgid "No Prefill Qty Is Possible"
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "No available work could be found."
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "No delivery package type available."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No lines to process."
+msgid "No line to pack found."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No location found for this barcode."
+msgid "No lines to process."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No lot found among current transfers."
+msgid "No location found for this barcode."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "No lot found for {}"
 msgstr ""
@@ -530,14 +629,20 @@
 #, python-format
 msgid "No more work to do, please create a new batch transfer"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "No operation found for this menu and profile."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "No operation type found for this menu and profile."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/services/service.py:0
 #, python-format
 msgid "No operation types configured on menu {}."
@@ -554,67 +659,77 @@
 #, python-format
 msgid "No pending operation for package %s."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No product found among current transfers."
+msgid "No product found for {}"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No product found for {}"
+msgid "No product found in {}"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No product found in {}"
+msgid "No putaway destination is available."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No putaway destination is available."
+msgid "No quantity has been processed, unable to complete the transfer."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No quantity has been processed, unable to complete the transfer."
+msgid "No transfer found for the scanned lot."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No valid package to select."
+msgid "No transfer found for the scanned packaging."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No value"
+msgid "No transfer found for this lot."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid ""
-"Not all lines have been processed with full quantity. Do you confirm partial "
-"operation?"
+msgid "No transfer found for this product."
 msgstr ""
 
 #. module: shopfloor
-#: code:addons/shopfloor/services/checkout.py:0
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "No valid package to select."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "No value"
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid ""
-"Not allowed to pack more than the quantity, the value has been changed to "
-"the maximum."
+"Not all lines have been processed with full quantity. Do you confirm partial "
+"operation?"
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__picking_type_ids
 msgid "Operation Types"
 msgstr ""
 
@@ -747,14 +862,20 @@
 #, python-format
 msgid "Packaging changed on package {}"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "Packaging not found in the current transfer."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid ""
 "Pick + Pack mode ON: the picking {0.name} has no carrier set. The system "
 "couldn't pack goods automatically."
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__pick_pack_same_time_is_possible
@@ -796,19 +917,44 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Picking type {} complete."
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Place it in {}?"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_quant_package__planned_move_line_ids
 msgid "Planned Move Line"
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid ""
+"Please note that the scanned quantity is higher than the maximum allowed."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Please scan the location first."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Please scan the package."
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__prepackaged_product_is_possible
 msgid "Prepackaged Product Is Possible"
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_prepackaged_product
 msgid "Process as pre-packaged"
@@ -822,15 +968,15 @@
 
 #. module: shopfloor
 #: model:ir.model,name:shopfloor.model_stock_move_line
 msgid "Product Moves (Stock Move Line)"
 msgstr ""
 
 #. module: shopfloor
-#: code:addons/shopfloor/services/checkout.py:0
+#: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Product is not in the current transfer."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
@@ -892,14 +1038,19 @@
 #. module: shopfloor
 #: model_terms:ir.ui.view,arch_db:shopfloor.view_stock_move_line_detailed_operation_tree
 msgid "SF Priority"
 msgstr ""
 
 #. module: shopfloor
 #: model_terms:ir.ui.view,arch_db:shopfloor.view_stock_move_line_detailed_operation_tree
+msgid "SF User"
+msgstr ""
+
+#. module: shopfloor
+#: model_terms:ir.ui.view,arch_db:shopfloor.view_stock_move_line_detailed_operation_tree
 msgid "SF checkout done"
 msgstr ""
 
 #. module: shopfloor
 #: model_terms:ir.ui.view,arch_db:shopfloor.view_stock_move_line_detailed_operation_tree
 msgid "SF unloaded"
 msgstr ""
@@ -907,14 +1058,24 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Same package {} is already assigned."
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__scan_location_or_pack_first_is_possible
+msgid "Scan Location Or Pack First Is Possible"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__scan_location_or_pack_first
+msgid "Scan first location or pack"
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Scan the destination location"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/services/location_content_transfer.py:0
@@ -990,14 +1151,20 @@
 #: code:addons/shopfloor/services/checkout.py:0
 #, python-format
 msgid ""
 "Several transfers found, please scan a package or select a transfer manually."
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Several transfers found, please select a transfer manually."
+msgstr ""
+
+#. module: shopfloor
 #: model_terms:ir.ui.view,arch_db:shopfloor.view_location_form
 #: model_terms:ir.ui.view,arch_db:shopfloor.view_picking_type_form
 msgid "Shopfloor"
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_move_line__shopfloor_checkout_done
@@ -1045,14 +1212,29 @@
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_quant_package__shopfloor_weight
 msgid "Shopfloor weight (kg)"
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_get_work
+msgid "Show Get Work on start"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__show_oneline_package_content_is_possible
+msgid "Show Oneline Package Content Is Possible"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__show_oneline_package_content
+msgid "Show one-line package content"
+msgstr ""
+
+#. module: shopfloor
 #: model:shopfloor.scenario,name:shopfloor.scenario_single_pack_transfer
 msgid "Single Pack Transfer"
 msgstr ""
 
 #. module: shopfloor
 #: model:shopfloor.menu,name:shopfloor.shopfloor_menu_demo_single_pallet_transfer
 #: model:stock.picking.type,name:shopfloor.picking_type_single_pallet_transfer_demo
@@ -1064,14 +1246,20 @@
 msgid ""
 "Some scenario may create move(s) when a product or package is scanned and no "
 "move already exists. Any new move is created in the selected operation type, "
 "so it can be active only when one type is selected."
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/stock.py:0
+#, python-format
+msgid "Someone is already working on these transfers"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_location__source_move_line_ids
 msgid "Source Move Line"
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_move_line__package_id
 msgid "Source Package"
@@ -1182,26 +1370,40 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "The package %s doesn't exist"
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "The picked quantity must be a value above zero."
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,help:shopfloor.field_stock_location__shopfloor_picking_sequence
 msgid ""
 "The picking done in Shopfloor scenarios will respect this order. The "
 "sequence is a char so it can be composed of fields such as 'corridor-rack-"
 "side-level'. Pay attention to the padding ('09' is before '19', '9' is not). "
 "It is recommended to use an Export then an Import to populate this field "
 "using a spreadsheet."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid ""
+"The quantity scanned for one or more lines cannot be higher than the maximum "
+"allowed."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "The record you were working on does not exist anymore."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/models/stock_move.py:0
 #, python-format
 msgid "The split order {} has been created."
@@ -1235,15 +1437,27 @@
 #, python-format
 msgid "This location content can't be moved at once."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "This lot does not exist anymore."
+msgid "This location does not exist."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "This location only contains packages, please scan one of them."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "This location requires packages. Please scan a destination package."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid ""
 "This lot is part of a package with other products, please scan a package."
@@ -1279,20 +1493,33 @@
 msgid ""
 "This product is part of a package with other products, please scan a package."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "This product is part of a package, please scan a package."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "This product is part of multiple packages, please scan a package."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid ""
+"This source document is part of multiple transfers, please scan a package."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "This transfer does not exist or is not available anymore."
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_picking__total_weight
 #: model:ir.model.fields,field_description:shopfloor.field_stock_picking_batch__total_weight
 msgid "Total Weight"
@@ -1346,14 +1573,24 @@
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__unreserve_other_moves_is_possible
 msgid "Unreserve Other Moves Is Possible"
 msgstr ""
 
 #. module: shopfloor
+#: model:shopfloor.profile,name:shopfloor.profile_demo_2
+msgid "WH delivery"
+msgstr ""
+
+#. module: shopfloor
+#: model:shopfloor.profile,name:shopfloor.profile_demo_1
+msgid "WH worker"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields.selection,name:shopfloor.selection__shopfloor_app__category__wms
 msgid "WMS"
 msgstr ""
 
 #. module: shopfloor
 #: model:shopfloor.app,short_name:shopfloor.app_demo
 msgid "WMS (demo)"
@@ -1364,14 +1601,39 @@
 msgid ""
 "When active, what you scan (typically a product packaging EAN) will be ship "
 "'as-is' and the operation will be validated triggering a backorder creation "
 "with the remaining lines."
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__allow_get_work
+msgid ""
+"When enabled the user will have the option to ask for a task to work on."
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__allow_alternative_destination
+msgid ""
+"When enabled the user will have the option to scan destination locations "
+"other than the expected ones (ask for confirmation)."
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__disable_full_bin_action
+msgid "When picking, prevent unloading the whole bin when full."
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__scan_location_or_pack_first
+msgid ""
+"When selecting work, force the user to first scan a location or pack,then "
+"the product or lot."
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Working location changed to {}"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/services/cluster_picking.py:0
@@ -1396,14 +1658,20 @@
 #, python-format
 msgid "Wrong pack."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "Wrong packaging."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "Wrong product."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Wrong."
@@ -1473,14 +1741,20 @@
 #, python-format
 msgid "{} is not a valid destination package."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "{} not found in the current transfer or already in a package."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "{} {} put in {}"
 msgstr ""
 
 #~ msgid ""
 #~ "Created from backorder <a href=# data-oe-model=stock.picking data-oe-id="
 #~ "%d>%s</a>."
 #~ msgstr ""
```

## odoo/addons/shopfloor/i18n/es_AR.po

```diff
@@ -2,15 +2,15 @@
 # This file contains the translation of the following modules:
 # 	* shopfloor
 #
 msgid ""
 msgstr ""
 "Project-Id-Version: Odoo Server 13.0\n"
 "Report-Msgid-Bugs-To: \n"
-"PO-Revision-Date: 2022-10-30 06:44+0000\n"
+"PO-Revision-Date: 2023-03-12 20:14+0000\n"
 "Last-Translator: Ignacio Buioli <ibuioli@gmail.com>\n"
 "Language-Team: none\n"
 "Language: es_AR\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: \n"
 "Plural-Forms: nplurals=2; plural=n != 1;\n"
@@ -34,27 +34,51 @@
 "\n"
 "* si se escanea una ubicación, se crea un nuevo paquete de entrega;\n"
 "* si se escanea un paquete, el paquete se valida con el transportista\n"
 "* en ambos casos, si el picking no tiene transportista la operación falla. "
 "\",\n"
 
 #. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__no_prefill_qty
+msgid ""
+"\n"
+"We assume the picker will take the suggested quantities.\n"
+"With this option, the operator will have to enter the quantity manually or\n"
+"by scanning a product or product packaging EAN to increase the quantity\n"
+"(i.e. +1 Unit or +1 Box)\n"
+msgstr ""
+"\n"
+"Asumimos que el recolector tomará las cantidades sugeridas.\n"
+"Con esta opción, el operador deberá ingresar la cantidad manualmente o\n"
+"escaneando un producto o embalaje de producto EAN para aumentar la cantidad\n"
+"(es decir, +1 Unidad o +1 Caja)\n"
+
+#. module: shopfloor
 #: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__multiple_move_single_pack
 msgid ""
 "\n"
 "When picking a move,\n"
 "allow to set a destination package that was already used for the other "
 "lines.\n"
 msgstr ""
 "\n"
 "Al elegir un movimiento,\n"
 "permite establecer un paquete de destino que ya se utilizó para las otras "
 "líneas.\n"
 
 #. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__auto_post_line
+msgid ""
+"\n"
+"When setting result pack & destination,\n"
+"automatically post the corresponding line\n"
+"if this option is checked.\n"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__unload_package_at_destination
 msgid ""
 "\n"
 "With this option, the lines you process by putting on a package during the\n"
 "picking process will be put as bulk products at the final destination "
 "location.\n"
 "\n"
@@ -75,24 +99,14 @@
 "\n"
 "Incompatible con: \"Recoger y empaquetar al mismo tiempo\"\n"
 
 #. module: shopfloor
 #: code:addons/shopfloor/models/shopfloor_menu.py:0
 #, python-format
 msgid ""
-"'Multiple moves same destination package' is mandatory when 'Pick and pack "
-"at the same time' is set."
-msgstr ""
-"'Múltiples movimientos en el mismo paquete de destino' es obligatorio cuando "
-"'Recoger y empaquetar al mismo tiempo' está configurado."
-
-#. module: shopfloor
-#: code:addons/shopfloor/models/shopfloor_menu.py:0
-#, python-format
-msgid ""
 "'Pick and pack at the same time' is incompatible with 'Multiple moves same "
 "destination package'."
 msgstr ""
 "'Recoger y empaquetar al mismo tiempo' es incompatible con 'Múltiples "
 "movimientos en el mismo paquete de destino'."
 
 #. module: shopfloor
@@ -135,35 +149,60 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "All packages processed."
 msgstr "Todos los paquetes procesados."
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_alternative_destination_is_possible
+msgid "Allow Alternative Destination Is Possible"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_force_reservation_is_possible
 msgid "Allow Force Reservation Is Possible"
 msgstr "Permitir Forzar Reserva es Posible"
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_get_work_is_possible
+msgid "Allow Get Work Is Possible"
+msgstr "Permitir Conseguir Trabajo Es Posible"
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_move_create
 msgid "Allow Move Creation"
 msgstr "Permitir Creación de Movimiento"
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_unreserve_other_moves
 msgid "Allow to process reserved quantities"
 msgstr "Permitir procesar cantidades reservadas"
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_alternative_destination
+msgid "Allow to scan alternative destination locations"
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Are you sure?"
 msgstr "¿Está seguro?"
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__auto_post_line_is_possible
+msgid "Auto Post Line Is Possible"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__auto_post_line
+msgid "Automatically post line"
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Barcode does not match with {}."
 msgstr "Código de barras no coincide con {}."
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
@@ -256,14 +295,20 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/inventory.py:0
 #, python-format
 msgid "Control stock issue in location {} for {}"
 msgstr "Error en control de inventario en ubicación {} para {}"
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Create new PACK {}? Scan it again to confirm."
+msgstr "Crear un nuevo PAQUETE {}? Escanee nuevamente para confirmar."
+
+#. module: shopfloor
 #: code:addons/shopfloor/models/shopfloor_menu.py:0
 #, python-format
 msgid "Creation of moves is not allowed for menu {}."
 msgstr "La creación de movimientos no está permitida para el menú {}."
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_move_line__date_planned
@@ -274,14 +319,34 @@
 #: model:shopfloor.menu,name:shopfloor.shopfloor_menu_demo_delivery
 #: model:shopfloor.scenario,name:shopfloor.scenario_delivery
 #: model:stock.picking.type,name:shopfloor.picking_type_delivery_demo
 msgid "Delivery"
 msgstr "Entrega"
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid ""
+"Delivery package type scanned: %(name)s. Scan again to place all goods in "
+"the same package."
+msgstr ""
+"Tipo de paquete de entrega escaneado: %(name)s. Escanee nuevamente para "
+"colocar todos los productos en el mismo paquete."
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__disable_full_bin_action_is_possible
+msgid "Disable Full Bin Action Is Possible"
+msgstr "Es Posible Deshabilitar la Acción de Contenedor Lleno"
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__disable_full_bin_action
+msgid "Disable full bin action"
+msgstr "Deshabilitar Acción de Contenedor Lleno"
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_app__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_priority_postpone_mixin__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_inventory__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_location__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_move__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_move_line__display_name
@@ -291,14 +356,24 @@
 #: model:ir.model.fields,field_description:shopfloor.field_stock_picking_type__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_quant__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_quant_package__display_name
 msgid "Display Name"
 msgstr "Mostrar Nombre"
 
 #. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__show_oneline_package_content
+msgid "Display the content of package if it contains 1 line only"
+msgstr "Mostrar el contenido del paquete si contiene solo 1 línea"
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__no_prefill_qty
+msgid "Do not pre-fill quantity to pick"
+msgstr "No pre-rellenar la cantidad a recoger"
+
+#. module: shopfloor
 #: model:ir.model.fields,help:shopfloor.field_stock_picking_type__shopfloor_zero_check
 msgid ""
 "For Shopfloor scenarios using it (Cluster Picking, Zone Picking, Discrete "
 "order Picking), the zero check step will be activated when a location "
 "becomes empty after a move."
 msgstr ""
 "Para los escenarios del Taller que lo utilizan (Selección de grupos, "
@@ -437,14 +512,20 @@
 #: model:shopfloor.scenario,name:shopfloor.scenario_location_content_transfer
 msgid "Location content transfer"
 msgstr "Transferencia de contenido de ubicación"
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "Location empty. Try scanning a package"
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "Location not allowed here."
 msgstr "La Ubicación no está permitida aquí."
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Location {} empty"
@@ -492,14 +573,20 @@
 
 #. module: shopfloor
 #: model:ir.model,name:shopfloor.model_shopfloor_menu
 msgid "Menu displayed in the scanner application"
 msgstr "Menú mostrado en la aplicación de escaner"
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Missing expiration date."
+msgstr "Falta la fecha de vencimiento."
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__move_create_is_possible
 msgid "Move Create Is Possible"
 msgstr "Crear Movimiento es Posible"
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_quant_package__move_line_ids
 msgid "Move Line"
@@ -508,14 +595,20 @@
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_picking__move_line_count
 #: model:ir.model.fields,field_description:shopfloor.field_stock_picking_batch__move_line_count
 msgid "Move Line Count"
 msgstr "Cuenta de Línea de Movimiento"
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Move already processed."
+msgstr "El Movimiento ya ha sido procesado."
+
+#. module: shopfloor
 #: code:addons/shopfloor/models/stock_move_line.py:0
 #, python-format
 msgid "Move lines processed have to share the same source location."
 msgstr ""
 "Movimiento de líneas procesadas tienen que compartir la misma ubicación."
 
 #. module: shopfloor
@@ -532,36 +625,47 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "New move lines cannot be assigned: canceled."
 msgstr "Los nuevos movimientos de líneas no puede ser asignados: cancelados."
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__no_prefill_qty_is_possible
+msgid "No Prefill Qty Is Possible"
+msgstr "No Prerellenar la Cantidad Es Posible"
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "No available work could be found."
+msgstr "Ningún trabajo disponible ha sido encontrado."
+
+#. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "No delivery package type available."
 msgstr "No hay un tipo de paquete de entrega disponible."
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No lines to process."
-msgstr "No hay líneas para procesar."
+msgid "No line to pack found."
+msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No location found for this barcode."
-msgstr "No se encontró ubicación para este código de barras."
+msgid "No lines to process."
+msgstr "No hay líneas para procesar."
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No lot found among current transfers."
-msgstr "No se encontró lote perteneciente a transferencias actuales."
+msgid "No location found for this barcode."
+msgstr "No se encontró ubicación para este código de barras."
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "No lot found for {}"
 msgstr "No se encontró lote para {}"
 
@@ -570,14 +674,20 @@
 #, python-format
 msgid "No more work to do, please create a new batch transfer"
 msgstr "No más trabajo por hacer, cree una nueva transferencia por lotes"
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "No operation found for this menu and profile."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "No operation type found for this menu and profile."
 msgstr "No se ha encontrado ningún tipo de operación para este menú y perfil."
 
 #. module: shopfloor
 #: code:addons/shopfloor/services/service.py:0
 #, python-format
 msgid "No operation types configured on menu {}."
@@ -594,21 +704,14 @@
 #, python-format
 msgid "No pending operation for package %s."
 msgstr "No hay operación pendiente para el paquete %s."
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No product found among current transfers."
-msgstr ""
-"No se ha encontrado ningún producto perteneciente a la transferencia actual."
-
-#. module: shopfloor
-#: code:addons/shopfloor/actions/message.py:0
-#, python-format
 msgid "No product found for {}"
 msgstr "No se encontró producto para {}"
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "No product found in {}"
@@ -627,14 +730,38 @@
 msgstr ""
 "No se ha procesado ninguna cantidad, no se ha podido completar la "
 "transferencia."
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "No transfer found for the scanned lot."
+msgstr "No se encontraron transferencias para el lote escaneado."
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "No transfer found for the scanned packaging."
+msgstr "No se ha encontrado ninguna transferencia para el paquete escaneado."
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "No transfer found for this lot."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "No transfer found for this product."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "No valid package to select."
 msgstr "No hay paquete válido para seleccionar."
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "No value"
@@ -647,23 +774,14 @@
 "Not all lines have been processed with full quantity. Do you confirm partial "
 "operation?"
 msgstr ""
 "No todas las líneas se han procesado con la cantidad completa. ¿Confirma "
 "operación parcial?"
 
 #. module: shopfloor
-#: code:addons/shopfloor/services/checkout.py:0
-#, python-format
-msgid ""
-"Not allowed to pack more than the quantity, the value has been changed to "
-"the maximum."
-msgstr ""
-"No se permite empacar más de la cantidad, el valor se ha cambiado al máximo."
-
-#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__picking_type_ids
 msgid "Operation Types"
 msgstr "Tipos de Operación"
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
@@ -797,14 +915,20 @@
 #, python-format
 msgid "Packaging changed on package {}"
 msgstr "El Empaquetado cambió en el paquete {}"
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "Packaging not found in the current transfer."
+msgstr "Paquete no encontrado en la transferencia actual."
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid ""
 "Pick + Pack mode ON: the picking {0.name} has no carrier set. The system "
 "couldn't pack goods automatically."
 msgstr ""
 "Modo Pick + Pack ACTIVADO: el picking {0.name} no tiene un transportista "
 "configurado. El sistema no podrá empaquetar mercadería automáticamente."
 
@@ -850,19 +974,44 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Picking type {} complete."
 msgstr "Tipo de Entrega {} completo."
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Place it in {}?"
+msgstr "¿Colocarlo en {}?"
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_quant_package__planned_move_line_ids
 msgid "Planned Move Line"
 msgstr "Línea de Movimiento Planificada"
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid ""
+"Please note that the scanned quantity is higher than the maximum allowed."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Please scan the location first."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Please scan the package."
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__prepackaged_product_is_possible
 msgid "Prepackaged Product Is Possible"
 msgstr "Producto PreEmpaquetado Es Posible"
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_prepackaged_product
 msgid "Process as pre-packaged"
@@ -876,15 +1025,15 @@
 
 #. module: shopfloor
 #: model:ir.model,name:shopfloor.model_stock_move_line
 msgid "Product Moves (Stock Move Line)"
 msgstr "Movimientos de Producto (Stock Move Line)"
 
 #. module: shopfloor
-#: code:addons/shopfloor/services/checkout.py:0
+#: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Product is not in the current transfer."
 msgstr "El Producto no está en la transferencia actual."
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
@@ -949,14 +1098,19 @@
 #. module: shopfloor
 #: model_terms:ir.ui.view,arch_db:shopfloor.view_stock_move_line_detailed_operation_tree
 msgid "SF Priority"
 msgstr "Prioridad del Taller"
 
 #. module: shopfloor
 #: model_terms:ir.ui.view,arch_db:shopfloor.view_stock_move_line_detailed_operation_tree
+msgid "SF User"
+msgstr "Usuario SF"
+
+#. module: shopfloor
+#: model_terms:ir.ui.view,arch_db:shopfloor.view_stock_move_line_detailed_operation_tree
 msgid "SF checkout done"
 msgstr "Checkout del Taller Hecho"
 
 #. module: shopfloor
 #: model_terms:ir.ui.view,arch_db:shopfloor.view_stock_move_line_detailed_operation_tree
 msgid "SF unloaded"
 msgstr "Taller Descargado"
@@ -964,14 +1118,24 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Same package {} is already assigned."
 msgstr "El mismo paquete {} ya está asignado."
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__scan_location_or_pack_first_is_possible
+msgid "Scan Location Or Pack First Is Possible"
+msgstr "Escanear Ubicación O Paquete Primero es Posible"
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__scan_location_or_pack_first
+msgid "Scan first location or pack"
+msgstr "Escanear ubicación o paquete primero"
+
+#. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Scan the destination location"
 msgstr "Escanear la ubicación de destino"
 
 #. module: shopfloor
 #: code:addons/shopfloor/services/location_content_transfer.py:0
@@ -1058,14 +1222,22 @@
 msgid ""
 "Several transfers found, please scan a package or select a transfer manually."
 msgstr ""
 "Se han encontrado varias transferencias, escanee un paquete o seleccione una "
 "transferencia manualmente."
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Several transfers found, please select a transfer manually."
+msgstr ""
+"Demasiadas transferencias encontradas, seleccione una transferencia "
+"manualmente."
+
+#. module: shopfloor
 #: model_terms:ir.ui.view,arch_db:shopfloor.view_location_form
 #: model_terms:ir.ui.view,arch_db:shopfloor.view_picking_type_form
 msgid "Shopfloor"
 msgstr "Taller"
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_move_line__shopfloor_checkout_done
@@ -1113,14 +1285,29 @@
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_quant_package__shopfloor_weight
 msgid "Shopfloor weight (kg)"
 msgstr "Peso del taller (kg)"
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_get_work
+msgid "Show Get Work on start"
+msgstr "Mostrar Obtener Trabajo en el inicio"
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__show_oneline_package_content_is_possible
+msgid "Show Oneline Package Content Is Possible"
+msgstr "Mostrar Paquetes de Una Línea Es Posible"
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__show_oneline_package_content
+msgid "Show one-line package content"
+msgstr "Mostrar contenido de paquete de una-línea"
+
+#. module: shopfloor
 #: model:shopfloor.scenario,name:shopfloor.scenario_single_pack_transfer
 msgid "Single Pack Transfer"
 msgstr "Transferencia de Paquete Individual"
 
 #. module: shopfloor
 #: model:shopfloor.menu,name:shopfloor.shopfloor_menu_demo_single_pallet_transfer
 #: model:stock.picking.type,name:shopfloor.picking_type_single_pallet_transfer_demo
@@ -1136,14 +1323,20 @@
 msgstr ""
 "Algunos escenarios pueden crear movimientos cuando se escanea un producto o "
 "paquete cuando no existe ningún movimiento. Cualquier movimiento nuevo se "
 "crea en el tipo de operación seleccionado, por lo que solo puede estar "
 "activo cuando se selecciona un tipo."
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/stock.py:0
+#, python-format
+msgid "Someone is already working on these transfers"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_location__source_move_line_ids
 msgid "Source Move Line"
 msgstr "Recurso del Movimiento de Línea"
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_move_line__package_id
 msgid "Source Package"
@@ -1261,14 +1454,20 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "The package %s doesn't exist"
 msgstr "El paquete %s no existe"
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "The picked quantity must be a value above zero."
+msgstr "La cantidad seleccionada debe ser un valor por encima de cero."
+
+#. module: shopfloor
 #: model:ir.model.fields,help:shopfloor.field_stock_location__shopfloor_picking_sequence
 msgid ""
 "The picking done in Shopfloor scenarios will respect this order. The "
 "sequence is a char so it can be composed of fields such as 'corridor-rack-"
 "side-level'. Pay attention to the padding ('09' is before '19', '9' is not). "
 "It is recommended to use an Export then an Import to populate this field "
 "using a spreadsheet."
@@ -1278,14 +1477,22 @@
 "'corredor-rack-side-level'. Preste atención al relleno ('09' es antes de "
 "'19', '9' no). Se recomienda usar Exportar y luego Importar para completar "
 "este campo usando una hoja de cálculo."
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid ""
+"The quantity scanned for one or more lines cannot be higher than the maximum "
+"allowed."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "The record you were working on does not exist anymore."
 msgstr "El registro en el que estaba trabajando ya no existe."
 
 #. module: shopfloor
 #: code:addons/shopfloor/models/stock_move.py:0
 #, python-format
 msgid "The split order {} has been created."
@@ -1319,16 +1526,28 @@
 #, python-format
 msgid "This location content can't be moved at once."
 msgstr "El contenido de esta ubicación no se puede mover a la vez."
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "This lot does not exist anymore."
-msgstr "Este lote ya no existe."
+msgid "This location does not exist."
+msgstr "Esta ubicación no existe."
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "This location only contains packages, please scan one of them."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "This location requires packages. Please scan a destination package."
+msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid ""
 "This lot is part of a package with other products, please scan a package."
 msgstr ""
@@ -1365,20 +1584,35 @@
 "This product is part of a package with other products, please scan a package."
 msgstr ""
 "Este producto es parte de un paquete con otros productos, escanee un paquete."
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "This product is part of a package, please scan a package."
+msgstr "Este producto es parte de un paquete, escanée un paquete."
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "This product is part of multiple packages, please scan a package."
 msgstr "Este producto es parte de varios paquetes, escanee un paquete."
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid ""
+"This source document is part of multiple transfers, please scan a package."
+msgstr ""
+"Este documento de origen es parte de múltiples transferencias, escanee un "
+"paquete."
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "This transfer does not exist or is not available anymore."
 msgstr "Esta transferencia no existe o ya no está disponible."
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_picking__total_weight
 #: model:ir.model.fields,field_description:shopfloor.field_stock_picking_batch__total_weight
 msgid "Total Weight"
@@ -1432,14 +1666,24 @@
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__unreserve_other_moves_is_possible
 msgid "Unreserve Other Moves Is Possible"
 msgstr "Es posible Anular la Reserva de Otros Movimientos"
 
 #. module: shopfloor
+#: model:shopfloor.profile,name:shopfloor.profile_demo_2
+msgid "WH delivery"
+msgstr "Entrega WH"
+
+#. module: shopfloor
+#: model:shopfloor.profile,name:shopfloor.profile_demo_1
+msgid "WH worker"
+msgstr "Trabajador WH"
+
+#. module: shopfloor
 #: model:ir.model.fields.selection,name:shopfloor.selection__shopfloor_app__category__wms
 msgid "WMS"
 msgstr "WMS"
 
 #. module: shopfloor
 #: model:shopfloor.app,short_name:shopfloor.app_demo
 msgid "WMS (demo)"
@@ -1453,14 +1697,44 @@
 "with the remaining lines."
 msgstr ""
 "Cuando está activo, lo que escanea (generalmente un EAN de empaque de "
 "producto) se enviará 'tal cual' y la operación se validará activando la "
 "creación de un pedido pendiente con las líneas restantes."
 
 #. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__allow_get_work
+msgid ""
+"When enabled the user will have the option to ask for a task to work on."
+msgstr ""
+"Cuando está habilitado el usuario tendrá la opción de solicitar una tarea "
+"para trabajar."
+
+#. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__allow_alternative_destination
+msgid ""
+"When enabled the user will have the option to scan destination locations "
+"other than the expected ones (ask for confirmation)."
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__disable_full_bin_action
+msgid "When picking, prevent unloading the whole bin when full."
+msgstr ""
+"Al hacer el picking, evite descargar todo el contenedor cuando esté lleno."
+
+#. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__scan_location_or_pack_first
+msgid ""
+"When selecting work, force the user to first scan a location or pack,then "
+"the product or lot."
+msgstr ""
+"Cuando seleccione un trabajo, fuerza al usuario a escanear primero una "
+"ubicación o paquete, después el producto o lote."
+
+#. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Working location changed to {}"
 msgstr "Ubicación de trabajo cambiada a {}"
 
 #. module: shopfloor
 #: code:addons/shopfloor/services/cluster_picking.py:0
@@ -1485,14 +1759,20 @@
 #, python-format
 msgid "Wrong pack."
 msgstr "Paquete equivocado."
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "Wrong packaging."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "Wrong product."
 msgstr "Producto equivocado."
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Wrong."
@@ -1566,17 +1846,71 @@
 #, python-format
 msgid "{} is not a valid destination package."
 msgstr "{} no es un paquete de destino válido."
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "{} not found in the current transfer or already in a package."
+msgstr "{} no encontrado en la transferencia actual o ya está en un paquete."
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "{} {} put in {}"
 msgstr "{} {} poner en {}"
 
+#, python-format
+#~ msgid "No line to pack found"
+#~ msgstr "No se encontró ninguna línea para empaquetar"
+
+#, python-format
+#~ msgid ""
+#~ "'Multiple moves same destination package' is mandatory when 'Pick and "
+#~ "pack at the same time' is set."
+#~ msgstr ""
+#~ "'Múltiples movimientos en el mismo paquete de destino' es obligatorio "
+#~ "cuando 'Recoger y empaquetar al mismo tiempo' está configurado."
+
+#, python-format
+#~ msgid ""
+#~ "Not allowed to pack more than the quantity, the value has been changed to "
+#~ "the maximum."
+#~ msgstr ""
+#~ "No se permite empacar más de la cantidad, el valor se ha cambiado al "
+#~ "máximo."
+
+#, python-format
+#~ msgid "No lot found among current transfers."
+#~ msgstr "No se encontró lote perteneciente a transferencias actuales."
+
+#, python-format
+#~ msgid "No product found among current transfers."
+#~ msgstr ""
+#~ "No se ha encontrado ningún producto perteneciente a la transferencia "
+#~ "actual."
+
+#, python-format
+#~ msgid "Product not found in the current transfer."
+#~ msgstr "Producto no encontrado en la transferencia actual."
+
+#, python-format
+#~ msgid "This lot does not exist anymore."
+#~ msgstr "Este lote ya no existe."
+
+#, python-format
+#~ msgid "Packaging not found in the current transfer or already in a package."
+#~ msgstr ""
+#~ "Paquete no encontrado en la transferencia actual o ya en un paquete."
+
+#, python-format
+#~ msgid "Product not found in the current transfer or already in a package."
+#~ msgstr ""
+#~ "Producto no encontrado en la transferencia actual o ya en un paquete."
+
 #~ msgid ""
 #~ "Created from backorder <a href=# data-oe-model=stock.picking data-oe-id="
 #~ "%d>%s</a>."
 #~ msgstr ""
 #~ "Creado desde pedido pendiente <a href=# data-oe-model=stock.picking data-"
 #~ "oe-id=%d>%s</a>."
```

## odoo/addons/shopfloor/i18n/pt_BR.po

```diff
@@ -23,23 +23,42 @@
 "\n"
 "* if a location is scanned, a new delivery package is created;\n"
 "* if a package is scanned, the package is validated against the carrier\n"
 "* in both cases, if the picking has no carrier the operation fails.\",\n"
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__no_prefill_qty
+msgid ""
+"\n"
+"We assume the picker will take the suggested quantities.\n"
+"With this option, the operator will have to enter the quantity manually or\n"
+"by scanning a product or product packaging EAN to increase the quantity\n"
+"(i.e. +1 Unit or +1 Box)\n"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__multiple_move_single_pack
 msgid ""
 "\n"
 "When picking a move,\n"
 "allow to set a destination package that was already used for the other "
 "lines.\n"
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__auto_post_line
+msgid ""
+"\n"
+"When setting result pack & destination,\n"
+"automatically post the corresponding line\n"
+"if this option is checked.\n"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__unload_package_at_destination
 msgid ""
 "\n"
 "With this option, the lines you process by putting on a package during the\n"
 "picking process will be put as bulk products at the final destination "
 "location.\n"
 "\n"
@@ -50,22 +69,14 @@
 "Incompatible with: \"Pick and pack at the same time\"\n"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/models/shopfloor_menu.py:0
 #, python-format
 msgid ""
-"'Multiple moves same destination package' is mandatory when 'Pick and pack "
-"at the same time' is set."
-msgstr ""
-
-#. module: shopfloor
-#: code:addons/shopfloor/models/shopfloor_menu.py:0
-#, python-format
-msgid ""
 "'Pick and pack at the same time' is incompatible with 'Multiple moves same "
 "destination package'."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/models/shopfloor_menu.py:0
 #, python-format
@@ -104,35 +115,60 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "All packages processed."
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_alternative_destination_is_possible
+msgid "Allow Alternative Destination Is Possible"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_force_reservation_is_possible
 msgid "Allow Force Reservation Is Possible"
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_get_work_is_possible
+msgid "Allow Get Work Is Possible"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_move_create
 msgid "Allow Move Creation"
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_unreserve_other_moves
 msgid "Allow to process reserved quantities"
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_alternative_destination
+msgid "Allow to scan alternative destination locations"
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Are you sure?"
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__auto_post_line_is_possible
+msgid "Auto Post Line Is Possible"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__auto_post_line
+msgid "Automatically post line"
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Barcode does not match with {}."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
@@ -225,14 +261,20 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/inventory.py:0
 #, python-format
 msgid "Control stock issue in location {} for {}"
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Create new PACK {}? Scan it again to confirm."
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/models/shopfloor_menu.py:0
 #, python-format
 msgid "Creation of moves is not allowed for menu {}."
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_move_line__date_planned
@@ -243,14 +285,32 @@
 #: model:shopfloor.menu,name:shopfloor.shopfloor_menu_demo_delivery
 #: model:shopfloor.scenario,name:shopfloor.scenario_delivery
 #: model:stock.picking.type,name:shopfloor.picking_type_delivery_demo
 msgid "Delivery"
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid ""
+"Delivery package type scanned: %(name)s. Scan again to place all goods in "
+"the same package."
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__disable_full_bin_action_is_possible
+msgid "Disable Full Bin Action Is Possible"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__disable_full_bin_action
+msgid "Disable full bin action"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_app__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_priority_postpone_mixin__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_inventory__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_location__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_move__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_move_line__display_name
@@ -260,14 +320,24 @@
 #: model:ir.model.fields,field_description:shopfloor.field_stock_picking_type__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_quant__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_quant_package__display_name
 msgid "Display Name"
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__show_oneline_package_content
+msgid "Display the content of package if it contains 1 line only"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__no_prefill_qty
+msgid "Do not pre-fill quantity to pick"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,help:shopfloor.field_stock_picking_type__shopfloor_zero_check
 msgid ""
 "For Shopfloor scenarios using it (Cluster Picking, Zone Picking, Discrete "
 "order Picking), the zero check step will be activated when a location "
 "becomes empty after a move."
 msgstr ""
 
@@ -396,14 +466,20 @@
 #: model:shopfloor.scenario,name:shopfloor.scenario_location_content_transfer
 msgid "Location content transfer"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "Location empty. Try scanning a package"
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "Location not allowed here."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Location {} empty"
@@ -449,14 +525,20 @@
 
 #. module: shopfloor
 #: model:ir.model,name:shopfloor.model_shopfloor_menu
 msgid "Menu displayed in the scanner application"
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Missing expiration date."
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__move_create_is_possible
 msgid "Move Create Is Possible"
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_quant_package__move_line_ids
 msgid "Move Line"
@@ -465,14 +547,20 @@
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_picking__move_line_count
 #: model:ir.model.fields,field_description:shopfloor.field_stock_picking_batch__move_line_count
 msgid "Move Line Count"
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Move already processed."
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/models/stock_move_line.py:0
 #, python-format
 msgid "Move lines processed have to share the same source location."
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__multiple_move_single_pack_is_possible
@@ -488,35 +576,46 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "New move lines cannot be assigned: canceled."
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__no_prefill_qty_is_possible
+msgid "No Prefill Qty Is Possible"
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "No available work could be found."
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "No delivery package type available."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No lines to process."
+msgid "No line to pack found."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No location found for this barcode."
+msgid "No lines to process."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No lot found among current transfers."
+msgid "No location found for this barcode."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "No lot found for {}"
 msgstr ""
@@ -526,14 +625,20 @@
 #, python-format
 msgid "No more work to do, please create a new batch transfer"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "No operation found for this menu and profile."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "No operation type found for this menu and profile."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/services/service.py:0
 #, python-format
 msgid "No operation types configured on menu {}."
@@ -550,67 +655,77 @@
 #, python-format
 msgid "No pending operation for package %s."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No product found among current transfers."
+msgid "No product found for {}"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No product found for {}"
+msgid "No product found in {}"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No product found in {}"
+msgid "No putaway destination is available."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No putaway destination is available."
+msgid "No quantity has been processed, unable to complete the transfer."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No quantity has been processed, unable to complete the transfer."
+msgid "No transfer found for the scanned lot."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No valid package to select."
+msgid "No transfer found for the scanned packaging."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No value"
+msgid "No transfer found for this lot."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid ""
-"Not all lines have been processed with full quantity. Do you confirm partial "
-"operation?"
+msgid "No transfer found for this product."
 msgstr ""
 
 #. module: shopfloor
-#: code:addons/shopfloor/services/checkout.py:0
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "No valid package to select."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "No value"
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid ""
-"Not allowed to pack more than the quantity, the value has been changed to "
-"the maximum."
+"Not all lines have been processed with full quantity. Do you confirm partial "
+"operation?"
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__picking_type_ids
 msgid "Operation Types"
 msgstr ""
 
@@ -743,14 +858,20 @@
 #, python-format
 msgid "Packaging changed on package {}"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "Packaging not found in the current transfer."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid ""
 "Pick + Pack mode ON: the picking {0.name} has no carrier set. The system "
 "couldn't pack goods automatically."
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__pick_pack_same_time_is_possible
@@ -792,19 +913,44 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Picking type {} complete."
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Place it in {}?"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_quant_package__planned_move_line_ids
 msgid "Planned Move Line"
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid ""
+"Please note that the scanned quantity is higher than the maximum allowed."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Please scan the location first."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Please scan the package."
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__prepackaged_product_is_possible
 msgid "Prepackaged Product Is Possible"
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_prepackaged_product
 msgid "Process as pre-packaged"
@@ -818,15 +964,15 @@
 
 #. module: shopfloor
 #: model:ir.model,name:shopfloor.model_stock_move_line
 msgid "Product Moves (Stock Move Line)"
 msgstr ""
 
 #. module: shopfloor
-#: code:addons/shopfloor/services/checkout.py:0
+#: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Product is not in the current transfer."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
@@ -888,14 +1034,19 @@
 #. module: shopfloor
 #: model_terms:ir.ui.view,arch_db:shopfloor.view_stock_move_line_detailed_operation_tree
 msgid "SF Priority"
 msgstr ""
 
 #. module: shopfloor
 #: model_terms:ir.ui.view,arch_db:shopfloor.view_stock_move_line_detailed_operation_tree
+msgid "SF User"
+msgstr ""
+
+#. module: shopfloor
+#: model_terms:ir.ui.view,arch_db:shopfloor.view_stock_move_line_detailed_operation_tree
 msgid "SF checkout done"
 msgstr ""
 
 #. module: shopfloor
 #: model_terms:ir.ui.view,arch_db:shopfloor.view_stock_move_line_detailed_operation_tree
 msgid "SF unloaded"
 msgstr ""
@@ -903,14 +1054,24 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Same package {} is already assigned."
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__scan_location_or_pack_first_is_possible
+msgid "Scan Location Or Pack First Is Possible"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__scan_location_or_pack_first
+msgid "Scan first location or pack"
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Scan the destination location"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/services/location_content_transfer.py:0
@@ -986,14 +1147,20 @@
 #: code:addons/shopfloor/services/checkout.py:0
 #, python-format
 msgid ""
 "Several transfers found, please scan a package or select a transfer manually."
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Several transfers found, please select a transfer manually."
+msgstr ""
+
+#. module: shopfloor
 #: model_terms:ir.ui.view,arch_db:shopfloor.view_location_form
 #: model_terms:ir.ui.view,arch_db:shopfloor.view_picking_type_form
 msgid "Shopfloor"
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_move_line__shopfloor_checkout_done
@@ -1041,14 +1208,29 @@
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_quant_package__shopfloor_weight
 msgid "Shopfloor weight (kg)"
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_get_work
+msgid "Show Get Work on start"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__show_oneline_package_content_is_possible
+msgid "Show Oneline Package Content Is Possible"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__show_oneline_package_content
+msgid "Show one-line package content"
+msgstr ""
+
+#. module: shopfloor
 #: model:shopfloor.scenario,name:shopfloor.scenario_single_pack_transfer
 msgid "Single Pack Transfer"
 msgstr ""
 
 #. module: shopfloor
 #: model:shopfloor.menu,name:shopfloor.shopfloor_menu_demo_single_pallet_transfer
 #: model:stock.picking.type,name:shopfloor.picking_type_single_pallet_transfer_demo
@@ -1060,14 +1242,20 @@
 msgid ""
 "Some scenario may create move(s) when a product or package is scanned and no "
 "move already exists. Any new move is created in the selected operation type, "
 "so it can be active only when one type is selected."
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/stock.py:0
+#, python-format
+msgid "Someone is already working on these transfers"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_location__source_move_line_ids
 msgid "Source Move Line"
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_move_line__package_id
 msgid "Source Package"
@@ -1178,26 +1366,40 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "The package %s doesn't exist"
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "The picked quantity must be a value above zero."
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,help:shopfloor.field_stock_location__shopfloor_picking_sequence
 msgid ""
 "The picking done in Shopfloor scenarios will respect this order. The "
 "sequence is a char so it can be composed of fields such as 'corridor-rack-"
 "side-level'. Pay attention to the padding ('09' is before '19', '9' is not). "
 "It is recommended to use an Export then an Import to populate this field "
 "using a spreadsheet."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid ""
+"The quantity scanned for one or more lines cannot be higher than the maximum "
+"allowed."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "The record you were working on does not exist anymore."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/models/stock_move.py:0
 #, python-format
 msgid "The split order {} has been created."
@@ -1231,15 +1433,27 @@
 #, python-format
 msgid "This location content can't be moved at once."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "This lot does not exist anymore."
+msgid "This location does not exist."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "This location only contains packages, please scan one of them."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "This location requires packages. Please scan a destination package."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid ""
 "This lot is part of a package with other products, please scan a package."
@@ -1275,20 +1489,33 @@
 msgid ""
 "This product is part of a package with other products, please scan a package."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "This product is part of a package, please scan a package."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "This product is part of multiple packages, please scan a package."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid ""
+"This source document is part of multiple transfers, please scan a package."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "This transfer does not exist or is not available anymore."
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_picking__total_weight
 #: model:ir.model.fields,field_description:shopfloor.field_stock_picking_batch__total_weight
 msgid "Total Weight"
@@ -1342,14 +1569,24 @@
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__unreserve_other_moves_is_possible
 msgid "Unreserve Other Moves Is Possible"
 msgstr ""
 
 #. module: shopfloor
+#: model:shopfloor.profile,name:shopfloor.profile_demo_2
+msgid "WH delivery"
+msgstr ""
+
+#. module: shopfloor
+#: model:shopfloor.profile,name:shopfloor.profile_demo_1
+msgid "WH worker"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields.selection,name:shopfloor.selection__shopfloor_app__category__wms
 msgid "WMS"
 msgstr ""
 
 #. module: shopfloor
 #: model:shopfloor.app,short_name:shopfloor.app_demo
 msgid "WMS (demo)"
@@ -1360,14 +1597,39 @@
 msgid ""
 "When active, what you scan (typically a product packaging EAN) will be ship "
 "'as-is' and the operation will be validated triggering a backorder creation "
 "with the remaining lines."
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__allow_get_work
+msgid ""
+"When enabled the user will have the option to ask for a task to work on."
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__allow_alternative_destination
+msgid ""
+"When enabled the user will have the option to scan destination locations "
+"other than the expected ones (ask for confirmation)."
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__disable_full_bin_action
+msgid "When picking, prevent unloading the whole bin when full."
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__scan_location_or_pack_first
+msgid ""
+"When selecting work, force the user to first scan a location or pack,then "
+"the product or lot."
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Working location changed to {}"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/services/cluster_picking.py:0
@@ -1392,14 +1654,20 @@
 #, python-format
 msgid "Wrong pack."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "Wrong packaging."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "Wrong product."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Wrong."
@@ -1469,9 +1737,15 @@
 #, python-format
 msgid "{} is not a valid destination package."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "{} not found in the current transfer or already in a package."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "{} {} put in {}"
 msgstr ""
```

## odoo/addons/shopfloor/i18n/shopfloor.pot

```diff
@@ -22,22 +22,51 @@
 "\n"
 "* if a location is scanned, a new delivery package is created;\n"
 "* if a package is scanned, the package is validated against the carrier\n"
 "* in both cases, if the picking has no carrier the operation fails.\",\n"
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__no_prefill_qty
+msgid ""
+"\n"
+"We assume the picker will take the suggested quantities.\n"
+"With this option, the operator will have to enter the quantity manually or\n"
+"by scanning a product or product packaging EAN to increase the quantity\n"
+"(i.e. +1 Unit or +1 Box)\n"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__allow_return
+msgid ""
+"\n"
+"When enabled, you can receive unplanned products that are returned\n"
+"from an existing delivery matched on the origin (SO name).\n"
+"A new move will be added as a return of the delivery,\n"
+"decreasing the delivered quantity of the related SO line.\n"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__multiple_move_single_pack
 msgid ""
 "\n"
 "When picking a move,\n"
 "allow to set a destination package that was already used for the other lines.\n"
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__auto_post_line
+msgid ""
+"\n"
+"When setting result pack & destination,\n"
+"automatically post the corresponding line\n"
+"if this option is checked.\n"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__unload_package_at_destination
 msgid ""
 "\n"
 "With this option, the lines you process by putting on a package during the\n"
 "picking process will be put as bulk products at the final destination location.\n"
 "\n"
 "This is useful if your picking device is emptied at the destination location or\n"
@@ -46,22 +75,14 @@
 "Incompatible with: \"Pick and pack at the same time\"\n"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/models/shopfloor_menu.py:0
 #, python-format
 msgid ""
-"'Multiple moves same destination package' is mandatory when 'Pick and pack "
-"at the same time' is set."
-msgstr ""
-
-#. module: shopfloor
-#: code:addons/shopfloor/models/shopfloor_menu.py:0
-#, python-format
-msgid ""
 "'Pick and pack at the same time' is incompatible with 'Multiple moves same "
 "destination package'."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/models/shopfloor_menu.py:0
 #, python-format
@@ -100,35 +121,70 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "All packages processed."
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_alternative_destination_is_possible
+msgid "Allow Alternative Destination Is Possible"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_force_reservation_is_possible
 msgid "Allow Force Reservation Is Possible"
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_get_work_is_possible
+msgid "Allow Get Work Is Possible"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_move_create
 msgid "Allow Move Creation"
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_return_is_possible
+msgid "Allow Return Is Possible"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_return
+msgid "Allow create returns"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_unreserve_other_moves
 msgid "Allow to process reserved quantities"
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_alternative_destination
+msgid "Allow to scan alternative destination locations"
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Are you sure?"
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__auto_post_line_is_possible
+msgid "Auto Post Line Is Possible"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__auto_post_line
+msgid "Automatically post line"
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Barcode does not match with {}."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
@@ -221,14 +277,20 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/inventory.py:0
 #, python-format
 msgid "Control stock issue in location {} for {}"
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Create new PACK {}? Scan it again to confirm."
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/models/shopfloor_menu.py:0
 #, python-format
 msgid "Creation of moves is not allowed for menu {}."
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_move_line__date_planned
@@ -239,14 +301,32 @@
 #: model:shopfloor.menu,name:shopfloor.shopfloor_menu_demo_delivery
 #: model:shopfloor.scenario,name:shopfloor.scenario_delivery
 #: model:stock.picking.type,name:shopfloor.picking_type_delivery_demo
 msgid "Delivery"
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid ""
+"Delivery package type scanned: %(name)s. Scan again to place all goods in "
+"the same package."
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__disable_full_bin_action_is_possible
+msgid "Disable Full Bin Action Is Possible"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__disable_full_bin_action
+msgid "Disable full bin action"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_app__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_priority_postpone_mixin__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_inventory__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_location__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_move__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_move_line__display_name
@@ -256,14 +336,24 @@
 #: model:ir.model.fields,field_description:shopfloor.field_stock_picking_type__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_quant__display_name
 #: model:ir.model.fields,field_description:shopfloor.field_stock_quant_package__display_name
 msgid "Display Name"
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__show_oneline_package_content
+msgid "Display the content of package if it contains 1 line only"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__no_prefill_qty
+msgid "Do not pre-fill quantity to pick"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,help:shopfloor.field_stock_picking_type__shopfloor_zero_check
 msgid ""
 "For Shopfloor scenarios using it (Cluster Picking, Zone Picking, Discrete "
 "order Picking), the zero check step will be activated when a location "
 "becomes empty after a move."
 msgstr ""
 
@@ -393,14 +483,20 @@
 #: model:shopfloor.scenario,name:shopfloor.scenario_location_content_transfer
 msgid "Location content transfer"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "Location empty. Try scanning a package"
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "Location not allowed here."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Location {} empty"
@@ -446,14 +542,20 @@
 
 #. module: shopfloor
 #: model:ir.model,name:shopfloor.model_shopfloor_menu
 msgid "Menu displayed in the scanner application"
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Missing expiration date."
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__move_create_is_possible
 msgid "Move Create Is Possible"
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_quant_package__move_line_ids
 msgid "Move Line"
@@ -462,14 +564,20 @@
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_picking__move_line_count
 #: model:ir.model.fields,field_description:shopfloor.field_stock_picking_batch__move_line_count
 msgid "Move Line Count"
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Move already processed."
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/models/stock_move_line.py:0
 #, python-format
 msgid "Move lines processed have to share the same source location."
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__multiple_move_single_pack_is_possible
@@ -485,35 +593,46 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "New move lines cannot be assigned: canceled."
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__no_prefill_qty_is_possible
+msgid "No Prefill Qty Is Possible"
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "No available work could be found."
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "No delivery package type available."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No lines to process."
+msgid "No line to pack found."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No location found for this barcode."
+msgid "No lines to process."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No lot found among current transfers."
+msgid "No location found for this barcode."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "No lot found for {}"
 msgstr ""
@@ -523,14 +642,20 @@
 #, python-format
 msgid "No more work to do, please create a new batch transfer"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "No operation found for this menu and profile."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "No operation type found for this menu and profile."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/services/service.py:0
 #, python-format
 msgid "No operation types configured on menu {}."
@@ -547,67 +672,77 @@
 #, python-format
 msgid "No pending operation for package %s."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No product found among current transfers."
+msgid "No product found for {}"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No product found for {}"
+msgid "No product found in {}"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No product found in {}"
+msgid "No putaway destination is available."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No putaway destination is available."
+msgid "No quantity has been processed, unable to complete the transfer."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No quantity has been processed, unable to complete the transfer."
+msgid "No transfer found for the scanned lot."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No valid package to select."
+msgid "No transfer found for the scanned packaging."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "No value"
+msgid "No transfer found for this lot."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid ""
-"Not all lines have been processed with full quantity. Do you confirm partial"
-" operation?"
+msgid "No transfer found for this product."
 msgstr ""
 
 #. module: shopfloor
-#: code:addons/shopfloor/services/checkout.py:0
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "No valid package to select."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "No value"
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid ""
-"Not allowed to pack more than the quantity, the value has been changed to "
-"the maximum."
+"Not all lines have been processed with full quantity. Do you confirm partial"
+" operation?"
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__picking_type_ids
 msgid "Operation Types"
 msgstr ""
 
@@ -616,14 +751,22 @@
 #, python-format
 msgid "Operation already processed."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid ""
+"Operation types for this menu are missing default source and destination "
+"locations."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "Operation's already running. Would you like to take it over?"
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_package_level__package_id
 msgid "Package"
 msgstr ""
@@ -740,14 +883,20 @@
 #, python-format
 msgid "Packaging changed on package {}"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "Packaging not found in the current transfer."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid ""
 "Pick + Pack mode ON: the picking {0.name} has no carrier set. The system "
 "couldn't pack goods automatically."
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__pick_pack_same_time_is_possible
@@ -789,19 +938,44 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Picking type {} complete."
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Place it in {}?"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_quant_package__planned_move_line_ids
 msgid "Planned Move Line"
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid ""
+"Please note that the scanned quantity is higher than the maximum allowed."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Please scan the location first."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Please scan the package."
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__prepackaged_product_is_possible
 msgid "Prepackaged Product Is Possible"
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_prepackaged_product
 msgid "Process as pre-packaged"
@@ -815,15 +989,15 @@
 
 #. module: shopfloor
 #: model:ir.model,name:shopfloor.model_stock_move_line
 msgid "Product Moves (Stock Move Line)"
 msgstr ""
 
 #. module: shopfloor
-#: code:addons/shopfloor/services/checkout.py:0
+#: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Product is not in the current transfer."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
@@ -885,14 +1059,19 @@
 #. module: shopfloor
 #: model_terms:ir.ui.view,arch_db:shopfloor.view_stock_move_line_detailed_operation_tree
 msgid "SF Priority"
 msgstr ""
 
 #. module: shopfloor
 #: model_terms:ir.ui.view,arch_db:shopfloor.view_stock_move_line_detailed_operation_tree
+msgid "SF User"
+msgstr ""
+
+#. module: shopfloor
+#: model_terms:ir.ui.view,arch_db:shopfloor.view_stock_move_line_detailed_operation_tree
 msgid "SF checkout done"
 msgstr ""
 
 #. module: shopfloor
 #: model_terms:ir.ui.view,arch_db:shopfloor.view_stock_move_line_detailed_operation_tree
 msgid "SF unloaded"
 msgstr ""
@@ -900,14 +1079,24 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Same package {} is already assigned."
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__scan_location_or_pack_first_is_possible
+msgid "Scan Location Or Pack First Is Possible"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__scan_location_or_pack_first
+msgid "Scan first location or pack"
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Scan the destination location"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/services/location_content_transfer.py:0
@@ -985,14 +1174,20 @@
 #, python-format
 msgid ""
 "Several transfers found, please scan a package or select a transfer "
 "manually."
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "Several transfers found, please select a transfer manually."
+msgstr ""
+
+#. module: shopfloor
 #: model_terms:ir.ui.view,arch_db:shopfloor.view_location_form
 #: model_terms:ir.ui.view,arch_db:shopfloor.view_picking_type_form
 msgid "Shopfloor"
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_move_line__shopfloor_checkout_done
@@ -1040,14 +1235,29 @@
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_quant_package__shopfloor_weight
 msgid "Shopfloor weight (kg)"
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__allow_get_work
+msgid "Show Get Work on start"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__show_oneline_package_content_is_possible
+msgid "Show Oneline Package Content Is Possible"
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__show_oneline_package_content
+msgid "Show one-line package content"
+msgstr ""
+
+#. module: shopfloor
 #: model:shopfloor.scenario,name:shopfloor.scenario_single_pack_transfer
 msgid "Single Pack Transfer"
 msgstr ""
 
 #. module: shopfloor
 #: model:shopfloor.menu,name:shopfloor.shopfloor_menu_demo_single_pallet_transfer
 #: model:stock.picking.type,name:shopfloor.picking_type_single_pallet_transfer_demo
@@ -1059,14 +1269,20 @@
 msgid ""
 "Some scenario may create move(s) when a product or package is scanned and no"
 " move already exists. Any new move is created in the selected operation "
 "type, so it can be active only when one type is selected."
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/stock.py:0
+#, python-format
+msgid "Someone is already working on these transfers"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_location__source_move_line_ids
 msgid "Source Move Line"
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_move_line__package_id
 msgid "Source Package"
@@ -1177,26 +1393,46 @@
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "The package %s doesn't exist"
 msgstr ""
 
 #. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "The picked quantity must be a value above zero."
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields,help:shopfloor.field_stock_location__shopfloor_picking_sequence
 msgid ""
 "The picking done in Shopfloor scenarios will respect this order. The "
 "sequence is a char so it can be composed of fields such as 'corridor-rack-"
 "side-level'. Pay attention to the padding ('09' is before '19', '9' is not)."
 " It is recommended to use an Export then an Import to populate this field "
 "using a spreadsheet."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "The product/packaging you selected has already been returned."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid ""
+"The quantity scanned for one or more lines cannot be higher than the maximum"
+" allowed."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "The record you were working on does not exist anymore."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/models/stock_move.py:0
 #, python-format
 msgid "The split order {} has been created."
@@ -1230,15 +1466,27 @@
 #, python-format
 msgid "This location content can't be moved at once."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
-msgid "This lot does not exist anymore."
+msgid "This location does not exist."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "This location only contains packages, please scan one of them."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
+msgid "This location requires packages. Please scan a destination package."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid ""
 "This lot is part of a package with other products, please scan a package."
@@ -1275,20 +1523,33 @@
 "This product is part of a package with other products, please scan a "
 "package."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "This product is part of a package, please scan a package."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "This product is part of multiple packages, please scan a package."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid ""
+"This source document is part of multiple transfers, please scan a package."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "This transfer does not exist or is not available anymore."
 msgstr ""
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_stock_picking__total_weight
 #: model:ir.model.fields,field_description:shopfloor.field_stock_picking_batch__total_weight
 msgid "Total Weight"
@@ -1342,14 +1603,24 @@
 
 #. module: shopfloor
 #: model:ir.model.fields,field_description:shopfloor.field_shopfloor_menu__unreserve_other_moves_is_possible
 msgid "Unreserve Other Moves Is Possible"
 msgstr ""
 
 #. module: shopfloor
+#: model:shopfloor.profile,name:shopfloor.profile_demo_2
+msgid "WH delivery"
+msgstr ""
+
+#. module: shopfloor
+#: model:shopfloor.profile,name:shopfloor.profile_demo_1
+msgid "WH worker"
+msgstr ""
+
+#. module: shopfloor
 #: model:ir.model.fields.selection,name:shopfloor.selection__shopfloor_app__category__wms
 msgid "WMS"
 msgstr ""
 
 #. module: shopfloor
 #: model:shopfloor.app,short_name:shopfloor.app_demo
 msgid "WMS (demo)"
@@ -1360,14 +1631,39 @@
 msgid ""
 "When active, what you scan (typically a product packaging EAN) will be ship "
 "'as-is' and the operation will be validated triggering a backorder creation "
 "with the remaining lines."
 msgstr ""
 
 #. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__allow_get_work
+msgid ""
+"When enabled the user will have the option to ask for a task to work on."
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__allow_alternative_destination
+msgid ""
+"When enabled the user will have the option to scan destination locations "
+"other than the expected ones (ask for confirmation)."
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__disable_full_bin_action
+msgid "When picking, prevent unloading the whole bin when full."
+msgstr ""
+
+#. module: shopfloor
+#: model:ir.model.fields,help:shopfloor.field_shopfloor_menu__scan_location_or_pack_first
+msgid ""
+"When selecting work, force the user to first scan a location or pack,then "
+"the product or lot."
+msgstr ""
+
+#. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Working location changed to {}"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/services/cluster_picking.py:0
@@ -1392,14 +1688,20 @@
 #, python-format
 msgid "Wrong pack."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "Wrong packaging."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "Wrong product."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "Wrong."
@@ -1416,14 +1718,20 @@
 #, python-format
 msgid "You cannot place it here"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "You cannot return more quantity than what was initially sent."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "You cannot work on a package (%s) outside of locations: %s"
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
 msgid "You must not pick more than {} units."
@@ -1469,9 +1777,15 @@
 #, python-format
 msgid "{} is not a valid destination package."
 msgstr ""
 
 #. module: shopfloor
 #: code:addons/shopfloor/actions/message.py:0
 #, python-format
+msgid "{} not found in the current transfer or already in a package."
+msgstr ""
+
+#. module: shopfloor
+#: code:addons/shopfloor/actions/message.py:0
+#, python-format
 msgid "{} {} put in {}"
 msgstr ""
```

## odoo/addons/shopfloor/models/shopfloor_menu.py

```diff
@@ -22,14 +22,34 @@
 """
 
 MULTIPLE_MOVE_SINGLE_PACK_HELP = """
 When picking a move,
 allow to set a destination package that was already used for the other lines.
 """
 
+NO_PREFILL_QTY_HELP = """
+We assume the picker will take the suggested quantities.
+With this option, the operator will have to enter the quantity manually or
+by scanning a product or product packaging EAN to increase the quantity
+(i.e. +1 Unit or +1 Box)
+"""
+
+AUTO_POST_LINE = """
+When setting result pack & destination,
+automatically post the corresponding line
+if this option is checked.
+"""
+
+RETURN_HELP = """
+When enabled, you can receive unplanned products that are returned
+from an existing delivery matched on the origin (SO name).
+A new move will be added as a return of the delivery,
+decreasing the delivered quantity of the related SO line.
+"""
+
 
 class ShopfloorMenu(models.Model):
     _inherit = "shopfloor.menu"
 
     picking_type_ids = fields.Many2many(
         comodel_name="stock.picking.type", string="Operation Types", required=True
     )
@@ -102,49 +122,120 @@
     )
     unload_package_at_destination = fields.Boolean(
         string="Unload package at destination",
         default=False,
         help=UNLOAD_PACK_AT_DEST_HELP,
     )
 
+    disable_full_bin_action_is_possible = fields.Boolean(
+        compute="_compute_disable_full_bin_action_is_possible"
+    )
+    disable_full_bin_action = fields.Boolean(
+        string="Disable full bin action",
+        default=False,
+        # TODO: improve this desc w/ usecases.
+        help=("When picking, prevent unloading the whole bin when full."),
+    )
+
     allow_force_reservation = fields.Boolean(
         string="Force stock reservation",
         default=False,
     )
     allow_force_reservation_is_possible = fields.Boolean(
         compute="_compute_allow_force_reservation_is_possible"
     )
 
+    allow_get_work = fields.Boolean(
+        string="Show Get Work on start",
+        default=False,
+        help=(
+            "When enabled the user will have the option to ask "
+            "for a task to work on."
+        ),
+    )
+    allow_get_work_is_possible = fields.Boolean(
+        compute="_compute_allow_get_work_is_possible"
+    )
+    no_prefill_qty = fields.Boolean(
+        string="Do not pre-fill quantity to pick",
+        help=NO_PREFILL_QTY_HELP,
+        default=False,
+    )
+    no_prefill_qty_is_possible = fields.Boolean(
+        compute="_compute_no_prefill_qty_is_possible"
+    )
+    show_oneline_package_content = fields.Boolean(
+        string="Show one-line package content",
+        help="Display the content of package if it contains 1 line only",
+        default=False,
+    )
+    show_oneline_package_content_is_possible = fields.Boolean(
+        compute="_compute_show_oneline_package_content_is_possible"
+    )
+    scan_location_or_pack_first = fields.Boolean(
+        string="Scan first location or pack",
+        help=(
+            "When selecting work, force the user to first scan a location or pack,"
+            "then the product or lot."
+        ),
+    )
+    scan_location_or_pack_first_is_possible = fields.Boolean(
+        compute="_compute_scan_location_or_pack_first_is_possible"
+    )
+    allow_alternative_destination = fields.Boolean(
+        string="Allow to scan alternative destination locations",
+        help=(
+            "When enabled the user will have the option to scan "
+            "destination locations other than the expected ones "
+            "(ask for confirmation)."
+        ),
+        default=False,
+    )
+    allow_alternative_destination_is_possible = fields.Boolean(
+        compute="_compute_allow_alternative_destination_is_possible"
+    )
+    allow_return_is_possible = fields.Boolean(
+        compute="_compute_allow_return_is_possible"
+    )
+    allow_return = fields.Boolean(
+        string="Allow create returns",
+        default=False,
+        help=RETURN_HELP,
+    )
+
+    auto_post_line = fields.Boolean(
+        string="Automatically post line",
+        default=False,
+        help=AUTO_POST_LINE,
+    )
+    auto_post_line_is_possible = fields.Boolean(
+        compute="_compute_auto_post_line_is_possible"
+    )
+
     @api.onchange("unload_package_at_destination")
     def _onchange_unload_package_at_destination(self):
         # Uncheck pick_pack_same_time when unload_package_at_destination is set to True
-        # Ensure that multiple_move_single_pack is False when
-        # unload_package_at_destination is checked out
         for record in self:
             if record.unload_package_at_destination:
                 record.pick_pack_same_time = False
-            else:
-                record.multiple_move_single_pack = False
 
     @api.onchange("pick_pack_same_time")
     def _onchange_pick_pack_same_time(self):
         # pick_pack_same_time is incompatible with multiple_move_single_pack and
         # multiple_move_single_pack
         for record in self:
             if record.pick_pack_same_time:
                 record.unload_package_at_destination = False
                 record.multiple_move_single_pack = False
 
     @api.onchange("multiple_move_single_pack")
     def _onchange_multiple_move_single_pack(self):
         # multiple_move_single_pack is incompatible with pick_pack_same_time,
-        # and requires unload_package_at_destination to be set
         for record in self:
             if record.multiple_move_single_pack:
-                record.unload_package_at_destination = True
                 record.pick_pack_same_time = False
 
     @api.constrains(
         "unload_package_at_destination",
         "pick_pack_same_time",
         "multiple_move_single_pack",
     )
@@ -159,21 +250,14 @@
         elif self.pick_pack_same_time and self.multiple_move_single_pack:
             raise exceptions.UserError(
                 _(
                     "'Pick and pack at the same time' is incompatible with "
                     "'Multiple moves same destination package'."
                 )
             )
-        elif self.multiple_move_single_pack and not self.unload_package_at_destination:
-            raise exceptions.UserError(
-                _(
-                    "'Multiple moves same destination package' is mandatory when "
-                    "'Pick and pack at the same time' is set."
-                )
-            )
 
     @api.depends("scenario_id", "picking_type_ids")
     def _compute_move_create_is_possible(self):
         for menu in self:
             menu.move_create_is_possible = bool(
                 menu.scenario_id.has_option("allow_create_moves")
                 and len(menu.picking_type_ids) == 1
@@ -220,14 +304,21 @@
             )
 
     @api.onchange("unreserve_other_moves_is_possible")
     def onchange_unreserve_other_moves_is_possible(self):
         self.allow_unreserve_other_moves = self.unreserve_other_moves_is_possible
 
     @api.depends("scenario_id")
+    def _compute_disable_full_bin_action_is_possible(self):
+        for menu in self:
+            menu.disable_full_bin_action_is_possible = menu.scenario_id.has_option(
+                "disable_full_bin_action"
+            )
+
+    @api.depends("scenario_id")
     def _compute_ignore_no_putaway_available_is_possible(self):
         for menu in self:
             menu.ignore_no_putaway_available_is_possible = menu.scenario_id.has_option(
                 "allow_ignore_no_putaway_available"
             )
 
     @api.onchange("ignore_no_putaway_available_is_possible")
@@ -290,7 +381,53 @@
 
     @api.depends("scenario_id")
     def _compute_allow_force_reservation_is_possible(self):
         for menu in self:
             menu.allow_force_reservation_is_possible = menu.scenario_id.has_option(
                 "allow_force_reservation"
             )
+
+    @api.depends("scenario_id")
+    def _compute_allow_get_work_is_possible(self):
+        for menu in self:
+            menu.allow_get_work_is_possible = menu.scenario_id.has_option(
+                "allow_get_work"
+            )
+
+    @api.depends("scenario_id")
+    def _compute_no_prefill_qty_is_possible(self):
+        for menu in self:
+            menu.no_prefill_qty_is_possible = menu.scenario_id.has_option(
+                "no_prefill_qty"
+            )
+
+    @api.depends("scenario_id")
+    def _compute_show_oneline_package_content_is_possible(self):
+        for menu in self:
+            menu.show_oneline_package_content_is_possible = menu.scenario_id.has_option(
+                "show_oneline_package_content"
+            )
+
+    @api.depends("scenario_id")
+    def _compute_scan_location_or_pack_first_is_possible(self):
+        for menu in self:
+            menu.scan_location_or_pack_first_is_possible = menu.scenario_id.has_option(
+                "scan_location_or_pack_first"
+            )
+
+    @api.depends("scenario_id")
+    def _compute_auto_post_line_is_possible(self):
+        for menu in self:
+            menu.auto_post_line_is_possible = menu.scenario_id.has_option(
+                "auto_post_line"
+            )
+
+    def _compute_allow_alternative_destination_is_possible(self):
+        for menu in self:
+            menu.allow_alternative_destination_is_possible = (
+                menu.scenario_id.has_option("allow_alternative_destination")
+            )
+
+    @api.depends("scenario_id")
+    def _compute_allow_return_is_possible(self):
+        for menu in self:
+            menu.allow_return_is_possible = menu.scenario_id.has_option("allow_return")
```

## odoo/addons/shopfloor/models/stock_move.py

 * *Ordering differences only*

```diff
@@ -35,16 +35,16 @@
                 qty_to_split = sum(to_move.mapped("product_uom_qty"))
             else:
                 qty_to_split = self.product_uom_qty - sum(
                     move_lines.mapped("product_uom_qty")
                 )
             split_move_vals = self._split(qty_to_split)
             split_move = self.create(split_move_vals)
-            split_move._action_confirm(merge=False)
             split_move.move_line_ids = to_move
+            split_move._action_confirm(merge=False)
             split_move._recompute_state()
             split_move._action_assign()
             self._recompute_state()
             return split_move
         return self.browse()
 
     def split_unavailable_qty(self):
```

## odoo/addons/shopfloor/models/stock_move_line.py

```diff
@@ -162,28 +162,37 @@
         qty_lesser = compare == -1
         qty_greater = compare == 1
         if qty_greater:
             return (new_line, "greater")
         elif qty_lesser:
             if not split_partial:
                 return (new_line, "lesser")
-            # split the move line which will be processed later (maybe the user
-            # has to pick some goods from another place because the location
-            # contained less items than expected)
-            remaining = self.product_uom_qty - qty_done
-            vals = {"product_uom_qty": remaining, "qty_done": 0}
-            vals.update(split_default_vals)
-            new_line = self.copy(vals)
-            # if we didn't bypass reservation update, the quant reservation
-            # would be reduced as much as the deduced quantity, which is wrong
-            # as we only moved the quantity to a new move line
-            self.with_context(bypass_reservation_update=True).product_uom_qty = qty_done
+            new_line = self._split_partial_quantity_to_be_done(
+                qty_done, split_default_vals
+            )
             return (new_line, "lesser")
         return (new_line, "full")
 
+    def _split_partial_quantity_to_be_done(self, quantity_done, split_default_vals):
+        """Create a new move line with the remaining quantity to process."""
+        # split the move line which will be processed later (maybe the user
+        # has to pick some goods from another place because the location
+        # contained less items than expected)
+        remaining = self.product_uom_qty - quantity_done
+        vals = {"product_uom_qty": remaining, "qty_done": 0}
+        vals.update(split_default_vals)
+        new_line = self.copy(vals)
+        # if we didn't bypass reservation update, the quant reservation
+        # would be reduced as much as the deduced quantity, which is wrong
+        # as we only moved the quantity to a new move line
+        self.with_context(
+            bypass_reservation_update=True
+        ).product_uom_qty = quantity_done
+        return new_line
+
     def replace_package(self, new_package):
         """Replace a package on an assigned move line"""
         self.ensure_one()
 
         # search other move lines which should already pick the scanned package
         other_reserved_lines = self.env["stock.move.line"].search(
             [
```

## odoo/addons/shopfloor/readme/CONTRIBUTORS.rst

```diff
@@ -2,13 +2,15 @@
 * Simone Orsi <simahawk@gmail.com>
 * Sébastien Alix <sebastien.alix@camptocamp.com>
 * Alexandre Fayolle <alexandre.fayolle@camptocamp.com>
 * Benoit Guillot <benoit.guillot@akretion.com>
 * Thierry Ducrest <thierry.ducrest@camptocamp.com>
 * Raphaël Reverdy <raphael.reverdy@akretion.com>
 * Jacques-Etienne Baudoux <je@bcim.be>
+* Juan Miguel Sánchez Arce <juan.sanchez@camptocamp.com>
+* Michael Tietz (MT Software) <mtietz@mt-software.de>
 
 Design
 ~~~~~~
 
 * Joël Grand-Guillaume <joel.grandguillaume@camptocamp.com>
 * Jacques-Etienne Baudoux <je@bcim.be>
```

## odoo/addons/shopfloor/readme/DESCRIPTION.rst

```diff
@@ -8,7 +8,10 @@
 * Delivery
 * Location Content Transfer
 * Single Pack Transfer
 
 This module provides REST APIs to support the scenarios. It needs a frontend
 to consume the backend APIs and provide screens for users on barcode devices.
 A default front-end application is provided by ``shopfloor_mobile``.
+
+| Note: if you want to enable a new scenario on an existing application, you must trigger the registry sync on the shopfloor.app in a post_init_hook or a post-migrate script.
+| See an example `here <https://github.com/OCA/wms/pull/520/commits/bccdfd445a9bc943998c4848f183a076e8459a98>`_.
```

## odoo/addons/shopfloor/services/checkout.py

```diff
@@ -1,14 +1,14 @@
 # Copyright 2020-2021 Camptocamp SA (http://www.camptocamp.com)
 # Copyright 2020-2021 Jacques-Etienne Baudoux (BCIM) <je@bcim.be>
 # License AGPL-3.0 or later (http://www.gnu.org/licenses/agpl.html).
 
 from werkzeug.exceptions import BadRequest
 
-from odoo import _
+from odoo import _, fields
 
 from odoo.addons.base_rest.components.service import to_int
 from odoo.addons.component.core import Component
 
 from ..utils import to_float
 
 
@@ -36,23 +36,35 @@
     """
 
     _inherit = "base.shopfloor.process"
     _name = "shopfloor.checkout"
     _usage = "checkout"
     _description = __doc__
 
-    def _response_for_select_line(self, picking, message=None):
+    def _response_for_select_line(
+        self, picking, message=None, need_confirm_pack_all=False
+    ):
         if all(line.shopfloor_checkout_done for line in picking.move_line_ids):
             return self._response_for_summary(picking, message=message)
         return self._response(
             next_state="select_line",
-            data={"picking": self._data_for_stock_picking(picking)},
+            data=self._data_for_select_line(
+                picking, need_confirm_pack_all=need_confirm_pack_all
+            ),
             message=message,
         )
 
+    def _data_for_select_line(self, picking, need_confirm_pack_all=False):
+        return {
+            "picking": self._data_for_stock_picking(picking),
+            "group_lines_by_location": True,
+            "show_oneline_package_content": self.work.menu.show_oneline_package_content,
+            "need_confirm_pack_all": need_confirm_pack_all,
+        }
+
     def _response_for_summary(self, picking, need_confirm=False, message=None):
         return self._response(
             next_state="summary" if not need_confirm else "confirm_done",
             data={
                 "picking": self._data_for_stock_picking(picking, done=True),
                 "all_processed": not bool(self._lines_to_pack(picking)),
             },
@@ -175,90 +187,103 @@
 
         Transitions:
         * select_document: when no stock.picking could be found
         * select_line: a stock.picking is selected
         * summary: stock.picking is selected and all its lines have a
           destination pack set
         """
+        search_result = self._scan_document_find(barcode)
+        result_handler = getattr(self, "_select_document_from_" + search_result.type)
+        return result_handler(search_result.record)
+
+    def _scan_document_find(self, barcode, search_types=None):
         search = self._actions_for("search")
-        picking = search.picking_from_scan(barcode)
-        if not picking:
-            location = search.location_from_scan(barcode)
-            if location:
-                if not self.is_src_location_valid(location):
-                    return self._response_for_select_document(
-                        message=self.msg_store.location_not_allowed()
-                    )
-                lines = location.source_move_line_ids
-                pickings = lines.mapped("picking_id")
-                if len(pickings) == 1:
-                    picking = pickings
-                else:
-                    return self._response_for_select_document(
-                        message={
-                            "message_type": "error",
-                            "body": _(
-                                "Several transfers found, please scan a package"
-                                " or select a transfer manually."
-                            ),
-                        }
-                    )
-        if not picking:
-            package = search.package_from_scan(barcode)
-            if package:
-                pickings = package.move_line_ids.filtered(
-                    lambda ml: ml.state not in ("cancel", "done")
-                ).mapped("picking_id")
-                if len(pickings) > 1:
-                    # Filter only if we find several pickings to narrow the
-                    # selection to one of the good type. If we have one picking
-                    # of the wrong type, it will be caught in _select_picking
-                    # with the proper error message.
-                    # Side note: rather unlikely to have several transfers ready
-                    # and moving the same things
-                    pickings = pickings.filtered(
-                        lambda p: p.picking_type_id in self.picking_types
-                    )
-                if len(pickings) == 1:
-                    picking = pickings
-        if not picking:
-            # Try to find the product first
-            product = search.product_from_scan(barcode, use_packaging=False)
-            # TODO Filter lines on picking_type before
-            # line_domain = [
-            #     ("move_id.picking_id.picking_type_id", "in", self.picking_types.ids)
-            # ]
-            line_domain = []
-            if not product:
-                # Then, try to find a packaging matching the barcode
-                packaging = search.packaging_from_scan(barcode)
-                if packaging:
-                    # And retrieve its product
-                    product = packaging.product_id
-                    # The picking should have a move line for the product
-                    # where qty >= packaging.qty, since it doesn't makes sense
-                    # to select a move line which have less qty than the packaging
-                    line_domain.append(("product_uom_qty", ">=", packaging.qty))
-            if product:
-                line_domain.extend(
-                    [
-                        ("product_id", "=", product.id),
-                        ("state", "not in", ("cancel", "done")),
-                        ("package_id", "=", False),
-                    ]
-                )
-                lines = self.env["stock.move.line"].search(line_domain)
-                picking = self.env["stock.picking"].search(
-                    [
-                        ("id", "in", lines.move_id.picking_id.ids),
-                        ("picking_type_id", "in", self.picking_types.ids),
-                    ],
-                    order="priority desc, scheduled_date asc, id desc",
-                    limit=1,
-                )
+        search_types = (
+            "picking",
+            "location",
+            "package",
+            "product",
+            "packaging",
+        )
+        return search.find(
+            barcode,
+            types=search_types,
+        )
+
+    def _select_document_from_picking(self, picking, **kw):
+        return self._select_picking(picking, "select_document")
+
+    def _select_document_from_location(self, location, **kw):
+        if not self.is_src_location_valid(location):
+            return self._response_for_select_document(
+                message=self.msg_store.location_not_allowed()
+            )
+        lines = location.source_move_line_ids
+        pickings = lines.mapped("picking_id")
+        if len(pickings) > 1:
+            return self._response_for_select_document(
+                message={
+                    "message_type": "error",
+                    "body": _(
+                        "Several transfers found, please scan a package"
+                        " or select a transfer manually."
+                    ),
+                }
+            )
+        return self._select_picking(pickings, "select_document")
+
+    def _select_document_from_package(self, package, **kw):
+        pickings = package.move_line_ids.filtered(
+            lambda ml: ml.state not in ("cancel", "done")
+        ).mapped("picking_id")
+        if len(pickings) > 1:
+            # Filter only if we find several pickings to narrow the
+            # selection to one of the good type. If we have one picking
+            # of the wrong type, it will be caught in _select_picking
+            # with the proper error message.
+            # Side note: rather unlikely to have several transfers ready
+            # and moving the same things
+            pickings = pickings.filtered(
+                lambda p: p.picking_type_id in self.picking_types
+            )
+        if len(pickings) == 1:
+            picking = pickings
+        return self._select_picking(picking, "select_document")
+
+    def _select_document_from_product(self, product, line_domain=None, **kw):
+        line_domain = line_domain or []
+        line_domain.extend(
+            [
+                ("product_id", "=", product.id),
+                ("state", "not in", ("cancel", "done")),
+                ("package_id", "=", False),
+            ]
+        )
+        lines = self.env["stock.move.line"].search(line_domain)
+        picking = self.env["stock.picking"].search(
+            [
+                ("id", "in", lines.move_id.picking_id.ids),
+                ("picking_type_id", "in", self.picking_types.ids),
+            ],
+            order="priority desc, scheduled_date asc, id desc",
+            limit=1,
+        )
+        return self._select_picking(picking, "select_document")
+
+    def _select_document_from_packaging(self, packaging, **kw):
+        # And retrieve its product
+        product = packaging.product_id
+        # The picking should have a move line for the product
+        # where qty >= packaging.qty, since it doesn't makes sense
+        # to select a move line which have less qty than the packaging
+        line_domain = [("product_uom_qty", ">=", packaging.qty)]
+        return self._select_document_from_product(product, line_domain=line_domain)
+
+    def _select_document_from_none(self, picking, **kw):
+        """Handle result when no record is found."""
         return self._select_picking(picking, "select_document")
 
     def _select_picking(self, picking, state_for_error):
         if not picking:
             if state_for_error == "manual_selection":
                 return self._response_for_manual_selection(
                     message=self.msg_store.stock_picking_not_found()
@@ -292,26 +317,31 @@
 
     def _data_for_stock_picking(self, picking, done=False):
         data = self.data.picking(picking)
         line_picker = self._lines_checkout_done if done else self._lines_to_pack
         data.update(
             {
                 "move_lines": self._data_for_move_lines(
-                    line_picker(picking), with_packaging=done
+                    self._lines_prepare(picking, line_picker(picking)),
+                    with_packaging=done,
                 )
             }
         )
         return data
 
     def _lines_checkout_done(self, picking):
         return picking.move_line_ids.filtered(self._filter_lines_checkout_done)
 
     def _lines_to_pack(self, picking):
         return picking.move_line_ids.filtered(self._filter_lines_unpacked)
 
+    def _lines_prepare(self, picking, selected_lines):
+        """Hook to manipulate lines' ordering or anything else before sending them back."""
+        return selected_lines
+
     def _domain_for_list_stock_picking(self):
         return [
             ("state", "=", "assigned"),
             ("picking_type_id", "in", self.picking_types.ids),
         ]
 
     def _order_for_list_stock_picking(self):
@@ -348,31 +378,38 @@
         """
         picking = self.env["stock.picking"].browse(picking_id)
         message = self._check_picking_status(picking)
         if message:
             return self._response_for_manual_selection(message=message)
         return self._select_picking(picking, "manual_selection")
 
-    def _select_lines(self, lines):
-        for line in lines:
+    def _select_lines(self, lines, prefill_qty=0, related_lines=None):
+        for i, line in enumerate(lines):
             if line.shopfloor_checkout_done:
                 continue
-            line.qty_done = line.product_uom_qty
+            if self.work.menu.no_prefill_qty and i == 0:
+                # For prefill quantity we only want to increment one line
+                line.qty_done += prefill_qty
+            elif not self.work.menu.no_prefill_qty:
+                line.qty_done = line.product_uom_qty
             line.shopfloor_user_id = self.env.user
 
         picking = lines.mapped("picking_id")
         other_lines = picking.move_line_ids - lines
         self._deselect_lines(other_lines)
+        if related_lines:
+            lines += related_lines
+        return lines
 
     def _deselect_lines(self, lines):
         lines.filtered(lambda l: not l.shopfloor_checkout_done).write(
             {"qty_done": 0, "shopfloor_user_id": False}
         )
 
-    def scan_line(self, picking_id, barcode):
+    def scan_line(self, picking_id, barcode, confirm_pack_all=False):
         """Scan move lines of the stock picking
 
         It allows to select move lines of the stock picking for the next
         screen. Lines can be found either by scanning a package, a product or a
         lot.
 
         There should be no ambiguity, so for instance if a product is scanned but
@@ -381,96 +418,126 @@
 
         Once move lines are found, their ``qty_done`` is set to their reserved
         quantity.
 
         Transitions:
         * select_line: nothing could be found for the barcode
         * select_package: lines are selected, user is redirected to this
+        * summary: delivery package is scanned and all lines are done
         screen to change the qty done and destination pack if needed
         """
         picking = self.env["stock.picking"].browse(picking_id)
         message = self._check_picking_status(picking)
         if message:
             return self._response_for_select_document(message=message)
 
-        search = self._actions_for("search")
-
         selection_lines = self._lines_to_pack(picking)
         if not selection_lines:
             return self._response_for_summary(picking)
 
-        package = search.package_from_scan(barcode)
-        if package:
-            return self._select_lines_from_package(picking, selection_lines, package)
+        search_result = self._scan_line_find(picking, barcode)
+        result_handler = getattr(self, "_select_lines_from_" + search_result.type)
+        kw = {"confirm_pack_all": confirm_pack_all}
+        return result_handler(picking, selection_lines, search_result.record, **kw)
 
-        product = search.product_from_scan(barcode)
-        if product:
-            return self._select_lines_from_product(picking, selection_lines, product)
-
-        lot = search.lot_from_scan(barcode, products=picking.move_lines.product_id)
-        if lot:
-            return self._select_lines_from_lot(picking, selection_lines, lot)
+    def _scan_line_find(self, picking, barcode, search_types=None):
+        search = self._actions_for("search")
+        search_types = (
+            "package",
+            "product",
+            "packaging",
+            "lot",
+            "serial",
+            "delivery_packaging",
+        )
+        return search.find(
+            barcode,
+            types=search_types,
+            handler_kw=dict(
+                lot=dict(products=picking.move_lines.product_id),
+                serial=dict(products=picking.move_lines.product_id),
+            ),
+        )
 
+    def _select_lines_from_none(self, picking, selection_lines, record, **kw):
+        """Handle result when no record is found."""
         return self._response_for_select_line(
             picking, message=self.msg_store.barcode_not_found()
         )
 
-    def _select_lines_from_package(self, picking, selection_lines, package):
-        lines = selection_lines.filtered(lambda l: l.package_id == package)
+    def _select_lines_from_package(self, picking, selection_lines, package, **kw):
+        lines = selection_lines.filtered(
+            lambda l: l.package_id == package and not l.shopfloor_checkout_done
+        )
         if not lines:
             return self._response_for_select_line(
                 picking,
                 message={
                     "message_type": "error",
                     "body": _("Package {} is not in the current transfer.").format(
                         package.name
                     ),
                 },
             )
         self._select_lines(lines)
+        if self.work.menu.no_prefill_qty:
+            lines = picking.move_line_ids
         return self._response_for_select_package(picking, lines)
 
-    def _select_lines_from_product(self, picking, selection_lines, product):
+    def _select_lines_from_product(
+        self, picking, selection_lines, product, prefill_qty=1, **kw
+    ):
         if product.tracking in ("lot", "serial"):
             return self._response_for_select_line(
                 picking, message=self.msg_store.scan_lot_on_product_tracked_by_lot()
             )
 
         lines = selection_lines.filtered(lambda l: l.product_id == product)
         if not lines:
             return self._response_for_select_line(
-                picking,
-                message={
-                    "message_type": "error",
-                    "body": _("Product is not in the current transfer."),
-                },
+                picking, message=self.msg_store.product_not_found_in_current_picking()
             )
 
         # When products are as units outside of packages, we can select them for
         # packing, but if they are in a package, we want the user to scan the packages.
         # If the product is only in one package though, scanning the product selects
         # the package.
         packages = lines.mapped("package_id")
+        related_lines = self.env["stock.move.line"].browse()
         # Do not use mapped here: we want to see if we have more than one package,
         # but also if we have one product as a package and the same product as
         # a unit in another line. In both cases, we want the user to scan the
         # package.
         if packages and len({line.package_id for line in lines}) > 1:
             return self._response_for_select_line(
                 picking, message=self.msg_store.product_multiple_packages_scan_package()
             )
         elif packages:
             # Select all the lines of the package when we scan a product in a
             # package and we have only one.
             return self._select_lines_from_package(picking, selection_lines, packages)
+        else:
+            # There is no package on selected lines, so also select all other lines
+            # not in a package. But only the quantity on first selected lines
+            # are updated.
+            related_lines = selection_lines.filtered(
+                lambda l: not l.package_id and l.product_id != product
+            )
 
-        self._select_lines(lines)
+        lines = self._select_lines(
+            lines, prefill_qty=prefill_qty, related_lines=related_lines
+        )
         return self._response_for_select_package(picking, lines)
 
-    def _select_lines_from_lot(self, picking, selection_lines, lot):
+    def _select_lines_from_packaging(self, picking, selection_lines, packaging, **kw):
+        return self._select_lines_from_product(
+            picking, selection_lines, packaging.product_id, prefill_qty=packaging.qty
+        )
+
+    def _select_lines_from_lot(self, picking, selection_lines, lot, **kw):
         lines = selection_lines.filtered(lambda l: l.lot_id == lot)
         if not lines:
             return self._response_for_select_line(
                 picking,
                 message={
                     "message_type": "error",
                     "body": _("Lot is not in the current transfer."),
@@ -489,19 +556,64 @@
         if packages and len({line.package_id for line in lines}) > 1:
             return self._response_for_select_line(
                 picking, message=self.msg_store.lot_multiple_packages_scan_package()
             )
         elif packages:
             # Select all the lines of the package when we scan a lot in a
             # package and we have only one.
-            return self._select_lines_from_package(picking, selection_lines, packages)
+            return self._select_lines_from_package(
+                picking, selection_lines, packages, **kw
+            )
 
-        self._select_lines(lines)
+        self._select_lines(lines, prefill_qty=1)
         return self._response_for_select_package(picking, lines)
 
+    def _select_lines_from_serial(self, picking, selection_lines, lot, **kw):
+        # Search for serial number is actually the same as searching for lot (as of v14...)
+        return self._select_lines_from_lot(picking, selection_lines, lot, **kw)
+
+    def _select_lines_from_delivery_packaging(
+        self, picking, selection_lines, packaging, confirm_pack_all=False, **kw
+    ):
+        """Handle delivery packaging.
+
+
+        If a delivery pkg has been scanned:
+
+            1. validate it
+            2. ask for confirmation to place all lines left into the same package
+            3. if scanned twice for confirmation,
+               assign new package and skip `select_package` state
+
+        """
+        carrier = self._get_carrier(picking)
+        if carrier:
+            # Validate against carrier
+            is_valid = self._packaging_good_for_carrier(packaging, carrier)
+        else:
+            is_valid = True
+        if carrier and not is_valid:
+            return self._response_for_select_line(
+                picking,
+                message=self.msg_store.packaging_invalid_for_carrier(
+                    packaging, carrier
+                ),
+            )
+        if confirm_pack_all:
+            # Select all lines and pack them all w/o passing for select_package state
+            self._select_lines(selection_lines)
+            return self._create_and_assign_new_packaging(
+                picking, selection_lines, packaging=packaging
+            )
+        return self._response_for_select_line(
+            picking,
+            message=self.msg_store.confirm_put_all_goods_in_delivery_package(packaging),
+            need_confirm_pack_all=True,
+        )
+
     def _select_line_package(self, picking, selection_lines, package):
         if not package:
             return self._response_for_select_line(
                 picking, message=self.msg_store.record_not_found()
             )
         return self._select_lines_from_package(picking, selection_lines, package)
 
@@ -574,29 +686,26 @@
                     "message_type": "error",
                 }
             else:
                 new_line = self.env["stock.move.line"]
                 if qty_done > 0:
                     new_line, qty_check = move_line._split_qty_to_be_done(
                         qty_done,
-                        split_partial=True,
+                        split_partial=False,
                         result_package_id=False,
                     )
-                    if qty_check == "greater":
-                        qty_done = move_line.product_uom_qty
-                        message = {
-                            "body": _(
-                                "Not allowed to pack more than the quantity, "
-                                "the value has been changed to the maximum."
-                            ),
-                            "message_type": "warning",
-                        }
                 move_line.qty_done = qty_done
                 if new_line:
                     selected_line_ids.append(new_line.id)
+                if qty_done > move_line.product_uom_qty:
+                    return self._response_for_select_package(
+                        picking,
+                        self.env["stock.move.line"].browse(selected_line_ids).exists(),
+                        message=self.msg_store.line_scanned_qty_done_higher_than_allowed(),
+                    )
         return self._response_for_select_package(
             picking,
             self.env["stock.move.line"].browse(selected_line_ids).exists(),
             message=message,
         )
 
     def reset_line_qty(self, picking_id, selected_line_ids, move_line_id):
@@ -658,14 +767,33 @@
             return self._change_line_qty(
                 picking.id,
                 selected_lines.ids,
                 switch_lines.ids,
                 lambda l: l.product_uom_qty,
             )
 
+    def _increment_custom_qty(
+        self, picking, selected_lines, increment_lines, qty_increment
+    ):
+        """Increment the  qty_done of a move line with a custom value
+
+        The selected_line parameter is used to keep the selection of lines
+        stateless.
+
+        Transitions:
+        * select_package: goes back to this screen showing all the lines after
+          we changed the qty
+        """
+        return self._change_line_qty(
+            picking.id,
+            selected_lines.ids,
+            increment_lines.ids,
+            lambda line: line.qty_done + qty_increment,
+        )
+
     @staticmethod
     def _filter_lines_unpacked(move_line):
         return (
             move_line.qty_done == 0 or move_line.shopfloor_user_id
         ) and not move_line.shopfloor_checkout_done
 
     @staticmethod
@@ -698,31 +826,58 @@
         """
         if not self._is_package_allowed(picking, package):
             return self._response_for_select_package(
                 picking,
                 selected_lines,
                 message=self.msg_store.dest_package_not_valid(package),
             )
-        return self._put_lines_in_allowed_package(picking, selected_lines, package)
+        return self._pack_lines(picking, selected_lines, package)
 
-    def _put_lines_in_allowed_package(self, picking, selected_lines, package):
-        lines_to_pack = selected_lines.filtered(self._filter_lines_to_pack)
+    def _put_lines_in_allowed_package(self, picking, lines_to_pack, package):
+        for line in lines_to_pack:
+            if line.qty_done < line.product_uom_qty:
+                line._split_partial_quantity_to_be_done(line.qty_done, {})
         lines_to_pack.write(
             {"result_package_id": package.id, "shopfloor_checkout_done": True}
         )
-        # go back to the screen to select the next lines to pack
-        return self._response_for_select_line(
-            picking,
-            message=self.msg_store.goods_packed_in(package),
-        )
+        self._post_put_lines_in_package(lines_to_pack)
+        # Hook to this method to override the response
+        # if anything else has to be handled
+        # before auto posting the lines.
+        return {}
+
+    def _post_put_lines_in_package(self, lines_packaged):
+        """Hook to override."""
 
     def _create_and_assign_new_packaging(self, picking, selected_lines, packaging=None):
         actions = self._actions_for("packaging")
         package = actions.create_package_from_packaging(packaging=packaging)
-        return self._put_lines_in_allowed_package(picking, selected_lines, package)
+        return self._pack_lines(picking, selected_lines, package)
+
+    def _pack_lines(self, picking, selected_lines, package):
+        lines_to_pack = selected_lines.filtered(self._filter_lines_to_pack)
+        if not lines_to_pack:
+            message = self.msg_store.no_line_to_pack()
+            return self._response_for_select_line(
+                picking,
+                message=message,
+            )
+        response = self._put_lines_in_allowed_package(picking, lines_to_pack, package)
+        if response:
+            return response
+        if self.work.menu.auto_post_line:
+            # If option auto_post_line is active in the shopfloor menu,
+            # create a split order with these packed lines.
+            self._auto_post_lines(lines_to_pack)
+        message = self.msg_store.goods_packed_in(package)
+        # go back to the screen to select the next lines to pack
+        return self._response_for_select_line(
+            picking,
+            message=message,
+        )
 
     def scan_package_action(self, picking_id, selected_line_ids, barcode):
         """Scan a package, a lot, a product or a package to handle a line
 
         When a package is scanned (only delivery ones), if the package is known
         as the destination package of one of the lines or is the source package
         of a selected line, the package is set to be the destination package of
@@ -751,65 +906,116 @@
         * summary: if there is no other lines, go to the summary screen to be able
         to close the stock picking
         """
         picking = self.env["stock.picking"].browse(picking_id)
         message = self._check_picking_status(picking)
         if message:
             return self._response_for_select_document(message=message)
-        search = self._actions_for("search")
 
         selected_lines = self.env["stock.move.line"].browse(selected_line_ids).exists()
+        search_result = self._scan_package_find(picking, barcode)
+        result_handler = getattr(
+            self, "_scan_package_action_from_" + search_result.type
+        )
+        return result_handler(picking, selected_lines, search_result.record)
 
-        product = search.product_from_scan(barcode)
-        if product:
-            if product.tracking in ("lot", "serial"):
-                return self._response_for_select_package(
-                    picking,
-                    selected_lines,
-                    message=self.msg_store.scan_lot_on_product_tracked_by_lot(),
-                )
-            product_lines = selected_lines.filtered(lambda l: l.product_id == product)
-            return self._switch_line_qty_done(picking, selected_lines, product_lines)
+    def _scan_package_find(self, picking, barcode, search_types=None):
+        search = self._actions_for("search")
+        search_types = (
+            "package",
+            "product",
+            "packaging",
+            "lot",
+            "serial",
+            "delivery_packaging",
+        )
+        return search.find(
+            barcode,
+            types=search_types,
+            handler_kw=dict(
+                lot=dict(products=picking.move_lines.product_id),
+                serial=dict(products=picking.move_lines.product_id),
+            ),
+        )
 
-        lot = search.lot_from_scan(barcode, products=selected_lines.product_id)
-        if lot:
-            lot_lines = selected_lines.filtered(lambda l: l.lot_id == lot)
-            return self._switch_line_qty_done(picking, selected_lines, lot_lines)
+    def _scan_package_action_from_product(
+        self, picking, selected_lines, product, packaging=None, **kw
+    ):
+        if product.tracking in ("lot", "serial"):
+            return self._response_for_select_package(
+                picking,
+                selected_lines,
+                message=self.msg_store.scan_lot_on_product_tracked_by_lot(),
+            )
+        product_lines = selected_lines.filtered(lambda l: l.product_id == product)
+        if self.work.menu.no_prefill_qty:
+            quantity_increment = packaging.qty if packaging else 1
+            return self._increment_custom_qty(
+                picking,
+                selected_lines,
+                fields.first(product_lines),
+                quantity_increment,
+            )
+        return self._switch_line_qty_done(picking, selected_lines, product_lines)
 
-        package = search.package_from_scan(barcode)
-        if package:
-            if not package.packaging_id:
-                return self._response_for_select_package(
-                    picking,
-                    selected_lines,
-                    message=self.msg_store.dest_package_not_valid(package),
-                )
-            return self._put_lines_in_package(picking, selected_lines, package)
+    def _scan_package_action_from_packaging(
+        self, picking, selected_lines, packaging, **kw
+    ):
+        return self._scan_package_action_from_product(
+            picking, selected_lines, packaging.product_id, packaging=packaging
+        )
+
+    def _scan_package_action_from_lot(self, picking, selected_lines, lot, **kw):
+        lot_lines = selected_lines.filtered(lambda l: l.lot_id == lot)
+        if self.work.menu.no_prefill_qty:
+            return self._increment_custom_qty(
+                picking, selected_lines, fields.first(lot_lines), 1
+            )
+        return self._switch_line_qty_done(picking, selected_lines, lot_lines)
 
-        # Scan delivery packaging
-        packaging = search.generic_packaging_from_scan(barcode)
-        if packaging:
-            carrier = picking.ship_carrier_id or picking.carrier_id
+    def _scan_package_action_from_serial(self, picking, selection_lines, lot, **kw):
+        # Search for serial number is actually the same as searching for lot (as of v14...)
+        return self._scan_package_action_from_lot(picking, selection_lines, lot, **kw)
+
+    def _scan_package_action_from_package(self, picking, selected_lines, package, **kw):
+        if not package.packaging_id:
+            return self._response_for_select_package(
+                picking,
+                selected_lines,
+                message=self.msg_store.dest_package_not_valid(package),
+            )
+        return self._put_lines_in_package(picking, selected_lines, package)
+
+    def _scan_package_action_from_delivery_packaging(
+        self, picking, selected_lines, packaging, **kw
+    ):
+        carrier = self._get_carrier(picking)
+        if carrier:
             # Validate against carrier
-            if carrier and not self._packaging_good_for_carrier(packaging, carrier):
-                return self._response_for_select_package(
-                    picking,
-                    selected_lines,
-                    message=self.msg_store.packaging_invalid_for_carrier(
-                        packaging, carrier
-                    ),
-                )
-            return self._create_and_assign_new_packaging(
-                picking, selected_lines, packaging
+            is_valid = self._packaging_good_for_carrier(packaging, carrier)
+        else:
+            is_valid = True
+        if carrier and not is_valid:
+            return self._response_for_select_package(
+                picking,
+                selected_lines,
+                message=self.msg_store.packaging_invalid_for_carrier(
+                    packaging, carrier
+                ),
             )
+        return self._create_and_assign_new_packaging(picking, selected_lines, packaging)
 
+    def _scan_package_action_from_none(self, picking, selected_lines, record, **kw):
         return self._response_for_select_package(
             picking, selected_lines, message=self.msg_store.barcode_not_found()
         )
 
+    def _get_carrier(self, picking):
+        return picking.ship_carrier_id or picking.carrier_id
+
     def _packaging_good_for_carrier(self, packaging, carrier):
         actions = self._actions_for("packaging")
         return actions.packaging_valid_for_carrier(packaging, carrier)
 
     def _get_available_delivery_packaging(self, picking):
         model = self.env["product.packaging"]
         carrier = picking.ship_carrier_id or picking.carrier_id
@@ -839,14 +1045,17 @@
         delivery_packaging = self._get_available_delivery_packaging(picking)
         if not delivery_packaging:
             return self._response_for_select_package(
                 picking,
                 selected_lines,
                 message=self.msg_store.no_delivery_packaging_available(),
             )
+        response = self._check_allowed_qty_done(picking, selected_lines)
+        if response:
+            return response
         return self._response_for_select_delivery_packaging(picking, delivery_packaging)
 
     def new_package(self, picking_id, selected_line_ids, packaging_id=None):
         """Add all selected lines in a new package
 
         It creates a new package and set it as the destination package of all
         the selected lines.
@@ -884,14 +1093,17 @@
         message = self._check_picking_status(picking)
         if message:
             return self._response_for_select_document(message=message)
         selected_lines = self.env["stock.move.line"].browse(selected_line_ids).exists()
         selected_lines.write(
             {"shopfloor_checkout_done": True, "result_package_id": False}
         )
+        response = self._check_allowed_qty_done(picking, selected_lines)
+        if response:
+            return response
         return self._response_for_select_line(
             picking,
             message={
                 "message_type": "success",
                 "body": _("Product(s) processed as raw product(s)"),
             },
         )
@@ -907,24 +1119,39 @@
         * select_package: when no package is available
         """
         picking = self.env["stock.picking"].browse(picking_id)
         message = self._check_picking_status(picking)
         if message:
             return self._response_for_select_document(message=message)
         lines = self.env["stock.move.line"].browse(selected_line_ids).exists()
+        response = self._check_allowed_qty_done(picking, lines)
+        if response:
+            return response
         return self._response_for_select_dest_package(picking, lines)
 
+    def _check_allowed_qty_done(self, picking, lines):
+        for line in lines:
+            # Do not allow to proceed if the qty_done of
+            # any of the selected lines
+            # is higher than the quantity to do.
+            if line.qty_done > line.product_uom_qty:
+                return self._response_for_select_package(
+                    picking,
+                    lines,
+                    message=self.msg_store.selected_lines_qty_done_higher_than_allowed(),
+                )
+
     def _set_dest_package_from_selection(self, picking, selected_lines, package):
         if not self._is_package_allowed(picking, package):
             return self._response_for_select_dest_package(
                 picking,
                 selected_lines,
                 message=self.msg_store.dest_package_not_valid(package),
             )
-        return self._put_lines_in_allowed_package(picking, selected_lines, package)
+        return self._pack_lines(picking, selected_lines, package)
 
     def scan_dest_package(self, picking_id, selected_line_ids, barcode):
         """Scan destination package for lines
 
         Set the destination package on the selected lines with a `qty_done` if
         the package is valid. It is valid when one of:
 
@@ -976,14 +1203,21 @@
             return self._response_for_select_dest_package(
                 picking,
                 lines,
                 message=self.msg_store.record_not_found(),
             )
         return self._set_dest_package_from_selection(picking, lines, package)
 
+    def _auto_post_lines(self, selected_lines):
+        moves = self.env["stock.move"]
+        for line in selected_lines:
+            move = line.move_id.split_other_move_lines(line, intersection=True)
+            moves = moves | move
+        moves.extract_and_action_done()
+
     def summary(self, picking_id):
         """Return information for the summary screen
 
         Transitions:
         * summary
         """
         picking = self.env["stock.picking"].browse(picking_id)
@@ -1118,17 +1352,19 @@
                     picking,
                     need_confirm=True,
                     message={
                         "message_type": "warning",
                         "body": _("Remaining raw product not packed, proceed anyway?"),
                     },
                 )
-        picking._action_done()
+        stock = self._actions_for("stock")
+        lines_done = self._lines_checkout_done(picking)
+        stock.validate_moves(lines_done.move_id)
         return self._response_for_select_document(
-            message=self.msg_store.transfer_done_success(picking)
+            message=self.msg_store.transfer_done_success(lines_done.picking_id)
         )
 
 
 class ShopfloorCheckoutValidator(Component):
     """Validators for the Checkout endpoints"""
 
     _inherit = "base.shopfloor.validator"
@@ -1144,14 +1380,19 @@
     def select(self):
         return {"picking_id": {"coerce": to_int, "required": True, "type": "integer"}}
 
     def scan_line(self):
         return {
             "picking_id": {"coerce": to_int, "required": True, "type": "integer"},
             "barcode": {"required": True, "type": "string"},
+            "confirm_pack_all": {
+                "type": "boolean",
+                "nullable": True,
+                "required": False,
+            },
         }
 
     def select_line(self):
         return {
             "picking_id": {"coerce": to_int, "required": True, "type": "integer"},
             "package_id": {"coerce": to_int, "required": False, "type": "integer"},
             "move_line_id": {"coerce": to_int, "required": False, "type": "integer"},
@@ -1344,15 +1585,20 @@
                 )
             }
         )
         return {"picking": self.schemas._schema_dict_of(schema, required=True)}
 
     @property
     def _schema_stock_picking_details(self):
-        return self._schema_stock_picking()
+        return dict(
+            self._schema_stock_picking(),
+            group_lines_by_location={"type": "boolean"},
+            show_oneline_package_content={"type": "boolean"},
+            need_confirm_pack_all={"type": "boolean"},
+        )
 
     @property
     def _schema_summary(self):
         return dict(
             self._schema_stock_picking(lines_with_packaging=True),
             all_processed={"type": "boolean"},
         )
```

## odoo/addons/shopfloor/services/cluster_picking.py

```diff
@@ -1,9 +1,10 @@
 # Copyright 2020-2021 Camptocamp SA (http://www.camptocamp.com)
 # Copyright 2020-2022 Jacques-Etienne Baudoux (BCIM) <je@bcim.be>
+# Copyright 2023 Michael Tietz (MT Software) <mtietz@mt-software.de>
 # License AGPL-3.0 or later (http://www.gnu.org/licenses/agpl.html).
 from odoo import _, fields
 from odoo.osv import expression
 
 from odoo.addons.base_rest.components.service import to_bool, to_int
 from odoo.addons.component.core import Component
 
@@ -88,33 +89,41 @@
     def _response_for_manual_selection(self, batches, message=None):
         data = {
             "records": self.data.picking_batches(batches),
             "size": len(batches),
         }
         return self._response(next_state="manual_selection", data=data, message=message)
 
-    def _response_for_start_line(self, move_line, message=None, popup=None):
+    def _response_for_start_line(
+        self, move_line, message=None, popup=None, sublocation=None
+    ):
+        kw = {"sublocation": self.data.location(sublocation)} if sublocation else {}
+        data = self._data_move_line(move_line, **kw)
         return self._response(
             next_state="start_line",
-            data=self._data_move_line(move_line),
+            data=data,
             message=message,
             popup=popup,
         )
 
-    def _response_for_scan_destination(self, move_line, message=None):
-        data = self._data_move_line(move_line)
+    def _response_for_scan_destination(self, move_line, message=None, qty_done=None):
+        if qty_done is None:
+            data = self._data_move_line(move_line)
+        else:
+            data = self._data_move_line(move_line, qty_done=qty_done)
         last_picked_line = self._last_picked_line(move_line.picking_id)
         if last_picked_line:
             # suggest pack to be used for the next line
             data["package_dest"] = self.data.package(
                 last_picked_line.result_package_id.with_context(
                     picking_id=move_line.picking_id.id
                 ),
                 picking=move_line.picking_id,
             )
+            data["disable_full_bin_action"] = self.work.menu.disable_full_bin_action
         return self._response(next_state="scan_destination", data=data, message=message)
 
     def _response_for_change_pack_lot(self, move_line, message=None):
         return self._response(
             next_state="change_pack_lot",
             data=self._data_move_line(move_line),
             message=message,
@@ -393,29 +402,30 @@
         data["package_dest"] = None
         data["batch"] = self.data.picking_batch(batch)
         data["picking"] = self.data.picking(picking)
         data["postponed"] = line.shopfloor_postponed
         data["product"]["qty_available"] = product.with_context(
             location=line.location_id.id
         ).qty_available
+        data["scan_location_or_pack_first"] = self.work.menu.scan_location_or_pack_first
         data.update(kw)
         return data
 
     def unassign(self, picking_batch_id):
         """Unassign and reset to draft a started picking batch
 
         Transitions:
         * "start" to work on a new batch
         """
         batch = self.env["stock.picking.batch"].browse(picking_batch_id)
         if batch.exists():
             batch.write({"state": "draft", "user_id": False})
         return self._response_for_start()
 
-    def scan_line(self, picking_batch_id, move_line_id, barcode):
+    def scan_line(self, picking_batch_id, move_line_id, barcode, sublocation_id=None):
         """Scan a location, a pack, a product or a lots
 
         There is no side-effect, it is only to check that the operator takes
         the expected pack or product.
 
         User can scan a location if there is only pack inside. Otherwise, they
         have to precise what they want by scanning one of:
@@ -423,21 +433,31 @@
         * pack
         * product
         * lot
 
         The result must be unambigous. For instance if we scan a product but the
         product is tracked by lot, scanning the lot has to be required.
 
+        `sublocation_id` is used when the scan_location_or_pack_first option is
+        switched on and the location contains multiple products with no lot or package.
+        The user will first scan the location and then the product, the backend needs
+        to know a location has been scanned previously.
+
         Transitions:
         * start_line: with an appropriate message when user has
           to scan for the same line again
         * start_line: with the next line if the line was added to a
           pack meanwhile (race condition).
         * scan_destination: if the barcode matches.
         """
+        sublocation = (
+            self.env["stock.location"].browse(sublocation_id).exists()
+            if sublocation_id
+            else self.env["stock.location"]
+        )
         batch = self.env["stock.picking.batch"].browse(picking_batch_id)
         if not batch.exists():
             return self._response_batch_does_not_exist()
         move_line = self.env["stock.move.line"].browse(move_line_id)
         if not move_line.exists():
             return self._pick_next_line(
                 batch, message=self.msg_store.operation_not_found()
@@ -445,24 +465,31 @@
 
         search = self._actions_for("search")
 
         picking = move_line.picking_id
 
         package = search.package_from_scan(barcode)
         if package and move_line.package_id == package:
-            return self._scan_line_by_package(picking, move_line, package, batch)
+            return self._scan_line_by_package(
+                picking, move_line, package, batch, sublocation
+            )
 
-        # use the common search method so we search by packaging too
         product = search.product_from_scan(barcode)
         if product and move_line.product_id == product:
-            return self._scan_line_by_product(picking, move_line, product)
+            return self._scan_line_by_product(picking, move_line, product, sublocation)
+
+        packaging = search.packaging_from_scan(barcode)
+        if move_line.product_id == packaging.product_id:
+            return self._scan_line_by_packaging(
+                picking, move_line, packaging, sublocation
+            )
 
         lot = search.lot_from_scan(barcode, products=move_line.product_id)
         if lot and move_line.lot_id == lot:
-            return self._scan_line_by_lot(picking, move_line, lot)
+            return self._scan_line_by_lot(picking, move_line, lot, sublocation)
 
         location = search.location_from_scan(barcode)
         if location and move_line.location_id == location:
             return self._scan_line_by_location(picking, move_line, location)
 
         # Nothing matches what is expected from the move line.
         for rec in (package, product, lot, location):
@@ -470,41 +497,68 @@
                 return self._response_for_start_line(
                     move_line, message=self.msg_store.wrong_record(rec)
                 )
         return self._response_for_start_line(
             move_line, message=self.msg_store.barcode_not_found()
         )
 
-    def _scan_line_by_package(self, picking, move_line, package, batch):
-        """Package scanned, just work with it."""
-        packaging = self._actions_for("packaging")
+    def _get_prefill_qty(self, move_line, qty=0):
+        """Returns the quantity to increment depending on no_prefill_qty optione."""
+        if self.work.menu.no_prefill_qty:
+            return qty
+        return move_line.product_uom_qty
+
+    def _check_first_scan_location_or_pack_first(
+        self, move_line, sublocation=None, location_scanned=False
+    ):
+        """Restrict scanning product or lot first with option on.
+
+        When the option first scan location or pack first is on.
+        When the line being worked on has a package, asked to scan the package first.
+        When the line as a lot ask to scan the location first.
+        """
+        if not self.work.menu.scan_location_or_pack_first:
+            return None
         message = None
-        if packaging.package_has_several_products(package):
-            message = self.msg_store.several_products_in_package(package)
-        elif packaging.package_has_several_lots(package):
-            message = self.msg_store.several_lots_in_package(package)
+        if move_line.package_id:
+            message = self.msg_store.line_has_package_scan_package()
+        elif not location_scanned and not sublocation:
+            message = self.msg_store.scan_the_location_first()
         if message:
-            return self._pick_next_line(batch, message=message)
-        return self._response_for_scan_destination(move_line)
+            return self._response_for_start_line(
+                move_line,
+                message=message,
+                sublocation=location_scanned or sublocation or None,
+            )
+        return None
 
-    def _scan_line_by_product(self, picking, move_line, product):
+    def _scan_line_by_package(self, picking, move_line, package, batch, sublocation):
+        """Package scanned, just work with it."""
+        quantity = self._get_prefill_qty(move_line)
+        return self._response_for_scan_destination(move_line, qty_done=quantity)
+
+    def _scan_line_by_product(self, picking, move_line, product, sublocation):
         """Product scanned, check if we can work with it.
 
         If scanned product is part of several packages in the same location,
         we can't be sure it's the correct one, in such case, ask to scan a package.
 
         If the product is tracked by lot and there is only one lot id in the location
         not in a package. It can safely be picked up.
         """
         message = None
         location_quants = move_line.location_id.quant_ids.filtered(
             lambda quant: quant.quantity > 0 and quant.product_id == product
         )
         packages = location_quants.mapped("package_id")
 
+        response = self._check_first_scan_location_or_pack_first(move_line, sublocation)
+        if response:
+            return response
+
         if move_line.product_id.tracking == "lot":
             lots_at_location = location_quants.mapped("lot_id")
             if len(lots_at_location) > 1 or packages:
                 message = self.msg_store.scan_lot_on_product_tracked_by_lot()
         elif move_line.product_id.tracking == "serial":
             message = self.msg_store.scan_lot_on_product_tracked_by_lot()
         if message:
@@ -515,74 +569,144 @@
         # a unit in another line. In both cases, we want the user to scan the
         # package.
         if packages and len({quant.package_id for quant in location_quants}) > 1:
             return self._response_for_start_line(
                 move_line,
                 message=self.msg_store.product_multiple_packages_scan_package(),
             )
-        return self._response_for_scan_destination(move_line)
+        quantity = self._get_prefill_qty(move_line, qty=1)
+        return self._response_for_scan_destination(move_line, qty_done=quantity)
+
+    def _scan_line_by_packaging(self, picking, move_line, packaging, sublocation):
+        """Packaging scanned, check if we can work with it.
+
+        If the packaging related product is part of several packages in the same location,
+        we can't be sure it's the correct one, in such case, ask to scan a package
+        """
+        response = self._check_first_scan_location_or_pack_first(move_line, sublocation)
+        if response:
+            return response
+
+        product = packaging.product_id
+        if move_line.product_id.tracking in ("lot", "serial"):
+            return self._response_for_start_line(
+                move_line, message=self.msg_store.scan_lot_on_product_tracked_by_lot()
+            )
+        other_product_lines = picking.move_line_ids.filtered(
+            lambda l: l.product_id == product and l.location_id == move_line.location_id
+        )
+        packages = other_product_lines.mapped("package_id")
+        # Do not use mapped here: we want to see if we have more than one package,
+        # but also if we have one product as a package and the same product as
+        # a unit in another line. In both cases, we want the user to scan the
+        # package.
+        if packages and len({line.package_id for line in other_product_lines}) > 1:
+            return self._response_for_start_line(
+                move_line,
+                message=self.msg_store.product_multiple_packages_scan_package(),
+            )
+        quantity = self._get_prefill_qty(move_line, packaging.qty)
+        return self._response_for_scan_destination(move_line, qty_done=quantity)
 
-    def _scan_line_by_lot(self, picking, move_line, lot):
+    def _scan_line_by_lot(self, picking, move_line, lot, sublocation):
         """Lot scanned, check if we can work with it.
 
         If we scanned a lot and it's part of several packages, we can't be
         sure the user scanned the correct one, in such case, ask to scan a package
         """
+        response = self._check_first_scan_location_or_pack_first(move_line, sublocation)
+        if response:
+            return response
+
         location_quants = move_line.location_id.quant_ids.filtered(
             lambda quant: quant.quantity > 0 and quant.lot_id == lot
         )
         packages = location_quants.package_id
 
         # Do not use mapped here: we want to see if we have more than one
         # package, but also if we have one lot as a package and the same lot as
         # a unit in another quant. In both cases, we want the user to scan the
         # package.
         if packages and len({quant.package_id for quant in location_quants}) > 1:
             return self._response_for_start_line(
                 move_line, message=self.msg_store.lot_multiple_packages_scan_package()
             )
-        return self._response_for_scan_destination(move_line)
+        quantity = self._get_prefill_qty(move_line, 1.0)
+        return self._response_for_scan_destination(move_line, qty_done=quantity)
 
     def _scan_line_by_location(self, picking, move_line, location):
         """Location scanned, check if we can work on goods contained into it.
 
         When a user scan a location, we accept only when we knows that
         they scanned the good thing, so if in the location we have
         several lots (on a package or a product), several packages,
         several products or a mix of several products and packages, we
         ask to scan a more precise barcode.
         """
+        response = self._check_first_scan_location_or_pack_first(
+            move_line, None, location_scanned=location
+        )
+        if response:
+            return response
+
         location_quants = move_line.location_id.quant_ids.filtered(
             lambda quant: quant.quantity > 0
         )
         lots = location_quants.lot_id
         if len(lots) > 1:
             return self._response_for_start_line(
                 move_line,
                 message=self.msg_store.several_lots_in_location(move_line.location_id),
+                sublocation=location,
             )
         packages = location_quants.package_id
         products = location_quants.product_id
         if len(packages) > 1 or len(products) > 1:
             if move_line.package_id:
                 return self._response_for_start_line(
                     move_line,
                     message=self.msg_store.several_packs_in_location(
-                        move_line.location_id
+                        move_line.location_id,
                     ),
+                    sublocation=location,
                 )
             else:
                 return self._response_for_start_line(
                     move_line,
                     message=self.msg_store.several_products_in_location(
-                        move_line.location_id
+                        move_line.location_id,
                     ),
+                    sublocation=location,
                 )
+        quantity = self._get_prefill_qty(move_line)
+        return self._response_for_scan_destination(move_line, qty_done=quantity)
 
-        return self._response_for_scan_destination(move_line)
+    def _set_destination_pack_update_quantity(self, move_line, quantity, barcode):
+        """Handle the done quantity increment on set_destination end point."""
+        response = None
+        if not self.work.menu.no_prefill_qty:
+            return response
+        search = self._actions_for("search")
+        # Handle barcode of product or packaging
+        product = search.product_from_scan(barcode)
+        packaging = self.env["product.packaging"].browse()
+        if not product:
+            packaging = search.packaging_from_scan(barcode)
+            product = packaging.product_id
+        if product and move_line.product_id == product:
+            quantity += packaging.qty or 1.0
+            response = self._response_for_scan_destination(move_line, qty_done=quantity)
+            return response
+        # Handle barcode of a lot
+        lot = search.lot_from_scan(barcode)
+        if lot and move_line.lot_id == lot:
+            quantity += 1.0
+            response = self._response_for_scan_destination(move_line, qty_done=quantity)
+            return response
+        return response
 
     def scan_destination_pack(self, picking_batch_id, move_line_id, barcode, quantity):
         """Scan the destination package (bin) for a move line
 
         If the quantity picked (passed to the endpoint) is < expected quantity,
         it splits the move line.
         It changes the destination package of the move line and set the "qty done".
@@ -605,26 +729,35 @@
             return self._response_batch_does_not_exist()
         move_line = self.env["stock.move.line"].browse(move_line_id)
         if not move_line.exists():
             return self._pick_next_line(
                 batch, message=self.msg_store.operation_not_found()
             )
 
+        response = self._set_destination_pack_update_quantity(
+            move_line, quantity, barcode
+        )
+        if response:
+            return response
+
         new_line, qty_check = move_line._split_qty_to_be_done(quantity)
         if qty_check == "greater":
             return self._response_for_scan_destination(
                 move_line,
                 message=self.msg_store.unable_to_pick_more(move_line.product_uom_qty),
+                qty_done=quantity,
             )
 
         search = self._actions_for("search")
         bin_package = search.package_from_scan(barcode)
         if not bin_package:
             return self._response_for_scan_destination(
-                move_line, message=self.msg_store.bin_not_found_for_barcode(barcode)
+                move_line,
+                message=self.msg_store.bin_not_found_for_barcode(barcode),
+                qty_done=quantity,
             )
 
         # the scanned package can contain only move lines of the same picking
         different_picking = any(
             ml.picking_id != move_line.picking_id
             for ml in bin_package.planned_move_line_ids.filtered(
                 lambda x: x.state not in ("done", "cancel")
@@ -636,14 +769,15 @@
                 move_line,
                 message={
                     "message_type": "error",
                     "body": _(
                         "The destination bin {} is not empty, please take another."
                     ).format(bin_package.name),
                 },
+                qty_done=quantity,
             )
         move_line.write({"qty_done": quantity, "result_package_id": bin_package.id})
 
         zero_check = move_line.picking_id.picking_type_id.shopfloor_zero_check
         if zero_check and move_line.location_id.planned_qty_in_location_is_empty():
             return self._response_for_zero_check(batch, move_line)
 
@@ -876,15 +1010,15 @@
             ("lot_id", "=", lot.id),
             ("state", "not in", ("cancel", "done")),
             ("qty_done", "=", 0),
             ("picking_id.batch_id", "=", batch.id),
         ]
         return domain
 
-    def change_pack_lot(self, picking_batch_id, move_line_id, barcode):
+    def change_pack_lot(self, picking_batch_id, move_line_id, barcode, quantity=None):
         """Change the expected pack or the lot for a line
 
         If the expected lot is at the very bottom of the location or a stock
         error forces a user to change lot or pack, user can change the pack or
         lot of the current line.
 
         The change occurs when the pack/product/lot is normally scanned and
@@ -912,21 +1046,26 @@
         change_package_lot = self._actions_for("change.package.lot")
         lot = search.lot_from_scan(barcode, products=move_line.product_id)
         if lot:
             response = change_package_lot.change_lot(
                 move_line, lot, response_ok_func, response_error_func
             )
             if response:
+                if "scan_destination" in response["data"] and quantity is not None:
+                    response["data"]["scan_destination"]["qty_done"] = quantity
                 return response
 
         package = search.package_from_scan(barcode)
         if package:
-            return change_package_lot.change_package(
+            response = change_package_lot.change_package(
                 move_line, package, response_ok_func, response_error_func
             )
+            if "scan_destination" in response["data"] and quantity is not None:
+                response["data"]["scan_destination"]["qty_done"] = quantity
+            return response
 
         return self._response_for_change_pack_lot(
             move_line,
             message=self.msg_store.no_package_or_lot_for_barcode(barcode),
         )
 
     def set_destination_all(self, picking_batch_id, barcode, confirmation=False):
@@ -997,15 +1136,16 @@
 
     def _unload_end(self, batch, completion_info_popup=None):
         """Try to close the batch if all transfers are done.
 
         Returns to `start_line` transition if some lines could still be processed,
         otherwise try to validate all the transfers of the batch.
         """
-        if all(picking.state == "done" for picking in batch.picking_ids):
+        all_pickings = batch.picking_ids
+        if all(picking.state == "done" for picking in all_pickings):
             # do not use the 'done()' method because it does many things we
             # don't care about
             batch.state = "done"
             return self._response_for_start(
                 message=self.msg_store.batch_transfer_complete(),
                 popup=completion_info_popup,
             )
@@ -1017,21 +1157,20 @@
                 message=self.msg_store.batch_transfer_line_done(),
                 popup=completion_info_popup,
             )
         else:
             # TODO add tests for this (for instance a picking is not 'done'
             # because a move was unassigned, we want to validate the batch to
             # produce backorders)
-            batch.mapped("picking_ids")._action_done()
+            all_pickings.filtered(lambda x: x.state == "assigned")._action_done()
             batch.state = "done"
             # Unassign not validated pickings from the batch, they will be
             # processed in another batch automatically later on
-            pickings_not_done = batch.mapped("picking_ids").filtered(
-                lambda p: p.state != "done"
-            )
+            all_pickings.invalidate_cache(["state"])
+            pickings_not_done = all_pickings.filtered(lambda p: p.state != "done")
             pickings_not_done.batch_id = False
             return self._response_for_start(
                 message=self.msg_store.batch_transfer_complete(),
                 popup=completion_info_popup,
             )
 
     def unload_split(self, picking_batch_id):
@@ -1111,16 +1250,15 @@
 
         return self._unload_scan_destination_lines(
             batch, package, lines, barcode, confirmation=confirmation
         )
 
     def _lock_lines(self, lines):
         """Lock move lines"""
-        sql = "SELECT id FROM %s WHERE ID IN %%s FOR UPDATE" % lines._table
-        self.env.cr.execute(sql, (tuple(lines.ids),), log_exceptions=False)
+        self._actions_for("lock").for_update(lines)
 
     def _unload_scan_destination_lines(
         self, batch, package, lines, barcode, confirmation=False
     ):
         # Lock move lines that will be updated
         self._lock_lines(lines)
         first_line = fields.first(lines)
@@ -1185,22 +1323,28 @@
         }
 
     def scan_line(self):
         return {
             "picking_batch_id": {"coerce": to_int, "required": True, "type": "integer"},
             "move_line_id": {"coerce": to_int, "required": True, "type": "integer"},
             "barcode": {"required": True, "type": "string"},
+            "sublocation_id": {"required": False, "nullable": True, "type": "integer"},
         }
 
     def scan_destination_pack(self):
         return {
             "picking_batch_id": {"coerce": to_int, "required": True, "type": "integer"},
             "move_line_id": {"coerce": to_int, "required": True, "type": "integer"},
             "barcode": {"required": True, "type": "string"},
-            "quantity": {"coerce": to_float, "required": True, "type": "float"},
+            "quantity": {
+                "coerce": to_float,
+                "required": True,
+                "nullable": True,
+                "type": "float",
+            },
         }
 
     def prepare_unload(self):
         return {
             "picking_batch_id": {"coerce": to_int, "required": True, "type": "integer"}
         }
 
@@ -1224,14 +1368,15 @@
         }
 
     def change_pack_lot(self):
         return {
             "picking_batch_id": {"coerce": to_int, "required": True, "type": "integer"},
             "move_line_id": {"coerce": to_int, "required": True, "type": "integer"},
             "barcode": {"required": True, "type": "string"},
+            "quantity": {"required": False, "type": "float"},
         }
 
     def set_destination_all(self):
         return {
             "picking_batch_id": {"coerce": to_int, "required": True, "type": "integer"},
             "barcode": {"required": True, "type": "string"},
             "confirmation": {"type": "boolean", "nullable": True, "required": False},
@@ -1272,15 +1417,15 @@
         to the next state.
         """
         return {
             "confirm_start": self._schema_for_batch_details,
             "start_line": self._schema_for_single_line_details,
             "start": {},
             "manual_selection": self._schema_for_batch_selection,
-            "scan_destination": self._schema_for_single_line_details,
+            "scan_destination": self._schema_for_scan_destination,
             "zero_check": self._schema_for_zero_check,
             "unload_all": self._schema_for_unload_all,
             "confirm_unload_all": self._schema_for_unload_all,
             "unload_single": self._schema_for_unload_single,
             "unload_set_destination": self._schema_for_unload_single,
             "confirm_unload_set_destination": self._schema_for_unload_single,
             "change_pack_lot": self._schema_for_single_line_details,
@@ -1431,14 +1576,22 @@
         return self.schemas.picking_batch(with_pickings=True)
 
     @property
     def _schema_for_single_line_details(self):
         schema = self.schemas.move_line()
         schema["picking"] = self.schemas._schema_dict_of(self.schemas.picking())
         schema["batch"] = self.schemas._schema_dict_of(self.schemas.picking_batch())
+        schema["scan_location_or_pack_first"] = {
+            "type": "boolean",
+            "nullable": False,
+            "required": False,
+        }
+        schema["sublocation"] = self.schemas._schema_dict_of(
+            self.schemas.location(), nullable=False, required=False
+        )
         return schema
 
     @property
     def _schema_for_unload_all(self):
         schema = self.schemas.picking_batch()
         schema["location_dest"] = self.schemas._schema_dict_of(self.schemas.location())
         return schema
@@ -1458,7 +1611,13 @@
         schema["location_src"] = self.schemas._schema_dict_of(self.schemas.location())
         schema["batch"] = self.schemas._schema_dict_of(self.schemas.picking_batch())
         return schema
 
     @property
     def _schema_for_batch_selection(self):
         return self.schemas._schema_search_results_of(self.schemas.picking_batch())
+
+    @property
+    def _schema_for_scan_destination(self):
+        schema = self._schema_for_single_line_details
+        schema["disable_full_bin_action"] = {"type": "boolean"}
+        return schema
```

## odoo/addons/shopfloor/services/delivery.py

```diff
@@ -48,15 +48,19 @@
         """
         return self._response(
             next_state="deliver",
             data={
                 "picking": self.data_detail.picking_detail(picking)
                 if picking
                 else None,
-                "sublocation": self.data.location(location) if location else None,
+                "sublocation": self.data.location(
+                    location, with_operation_progress=True
+                )
+                if location
+                else None,
             },
             message=message,
         )
 
     def _response_for_manual_selection(self, pickings, message=None):
         """Transition to the 'manual_selection' state
 
@@ -122,15 +126,14 @@
         updated data (and we really want to refresh data because several
         users may work on the same transfer).
 
         Transitions:
         * deliver: always return here with the data for the last touched
         picking or no picking if the picking has been set to done
         """
-        allow_prepackaged_product = self.work.menu.allow_prepackaged_product
         location = (
             self.env["stock.location"].browse(location_id) if location_id else None
         )
         if not barcode:
             return self._response_for_deliver(location=location)
         search = self._actions_for("search")
         picking = search.picking_from_scan(barcode)
@@ -147,26 +150,21 @@
         # Validate picking anyway
         if not barcode_valid:
             package = search.package_from_scan(barcode)
             if package:
                 return self._deliver_package(picking, package, location)
 
         if not barcode_valid:
-            product = search.product_from_scan(
-                barcode, use_packaging=(not allow_prepackaged_product)
-            )
+            product = search.product_from_scan(barcode)
             if product:
-                return self._deliver_product(picking, product, location=location)
+                return self._deliver_product(
+                    picking, product, product_qty=1, location=location
+                )
 
         if not barcode_valid:
-            lot = search.lot_from_scan(barcode)
-            if lot:
-                return self._deliver_lot(picking, lot, location)
-
-        if not barcode_valid and allow_prepackaged_product:
             packaging = search.packaging_from_scan(barcode)
             if packaging:
                 # By scanning a packaging, we want to process
                 # the full quantity of the packaging
                 packaging_qty = packaging.product_uom_id._compute_quantity(
                     packaging.qty, packaging.product_id.uom_id
                 )
@@ -174,14 +172,19 @@
                     picking,
                     packaging.product_id,
                     product_qty=packaging_qty,
                     location=location,
                 )
 
         if not barcode_valid:
+            lot = search.lot_from_scan(barcode)
+            if lot:
+                return self._deliver_lot(picking, lot, product_qty=1, location=location)
+
+        if not barcode_valid:
             sublocation = search.location_from_scan(barcode)
             if sublocation and sublocation.is_sublocation_of(
                 self.picking_types.mapped("default_location_src_id")
             ):
                 message = self.msg_store.location_src_set_to_sublocation(sublocation)
                 return self._response_for_deliver(location=sublocation, message=message)
 
@@ -193,28 +196,31 @@
     def _set_lines_done(self, lines, product_qty=None):
         """Set done quantities on `lines`.
 
         Once all lines of a picking have been processed, the picking will be
         validated automatically.
         Return `True` if the related picking has been validated.
         """
-        if product_qty:
-            # When we scan a packaging we process only one move line,
+        allow_prepackaged_product = self.work.menu.allow_prepackaged_product
+        if product_qty:  # defined with lot/product/packaging scan
+            # With a product_qty we process only one move line,
             # so one move to deal with regarding the qty
             qty_done = lines.move_id.product_id.uom_id._compute_quantity(
                 product_qty, lines.move_id.product_uom
             )
-            lines.qty_done = qty_done
-            return self._action_picking_done(lines.picking_id, force=True)
+            lines.qty_done += qty_done
+            return self._action_picking_done(
+                lines.picking_id, force=allow_prepackaged_product
+            )
         for line in lines:
             # note: the package level is automatically set to "is_done" when
             # the qty_done is full
             line.qty_done = line.product_uom_qty
         picking = fields.first(lines.mapped("picking_id"))
-        return self._action_picking_done(picking)
+        return self._action_picking_done(picking, force=allow_prepackaged_product)
 
     def _reset_lines(self, lines):
         for line in lines:
             # note: the package level "is_done" field is automatically unset
             # when the qty_done is not full
             line.qty_done = 0
 
@@ -254,66 +260,70 @@
             # in the picking type, and then use IN (ids)
             ("picking_id.picking_type_id", "in", self.picking_types.ids),
         ]
         if no_qty_done:
             domain.append(("qty_done", "=", 0))
         return domain
 
-    def _lines_from_lot_domain(self, lot, no_qty_done=True, location=None):
+    def _lines_from_lot_domain(
+        self, lot, no_qty_done=True, product_qty=None, location=None
+    ):
         location_domain = (
             [("picking_id.location_id", "=", location.id)] if location else []
         )
-        return expression.AND(
+        domain = expression.AND(
             [
                 self._lines_base_domain(no_qty_done),
                 [("lot_id", "=", lot.id)],
                 location_domain,
             ]
         )
+        if product_qty:
+            domain.extend(
+                [
+                    ("product_qty", ">=", product_qty),
+                ]
+            )
+        return domain
 
     def _lines_from_product_domain(
         self, product, no_qty_done=True, product_qty=None, location=None
     ):
         # TODO: searching lines is common to other scenario, to refactor
         domain = expression.AND(
             [self._lines_base_domain(no_qty_done), [("product_id", "=", product.id)]]
         )
         if location:
-            domain.extend([("picking_id.location_id", "=", location.id)])
+            domain.extend([("location_id", "=", location.id)])
         if product_qty:
-            # Match lines corresponding to the product packaging qty
-            # (in stock UoM) and exclude lines having a source package (those
-            # must be processed by scanning the package)
             domain.extend(
                 [
                     ("product_qty", ">=", product_qty),
-                    ("package_id", "=", False),
                 ]
             )
         return domain
 
     def _lines_from_package_domain(self, package, no_qty_done=True):
         return expression.AND(
             [self._lines_base_domain(no_qty_done), [("package_id", "=", package.id)]]
         )
 
     def _deliver_product(self, picking, product, product_qty=None, location=None):
+        """Handle the scan_deliver end point for a product."""
         if product.tracking in ("lot", "serial"):
             return self._response_for_deliver(
                 picking,
                 location=location,
                 message=self.msg_store.scan_lot_on_product_tracked_by_lot(),
             )
 
-        limit = 1 if product_qty else None
         lines = self.env["stock.move.line"].search(
             self._lines_from_product_domain(
-                product, product_qty=product_qty, location=location
+                product, no_qty_done=False, product_qty=product_qty, location=location
             ),
-            limit=limit,
             order="date_planned",
         )
         if not lines:
             return self._response_for_deliver(
                 picking,
                 location=location,
                 message=self.msg_store.product_not_found_in_pickings(),
@@ -363,27 +373,42 @@
             # abort the operation if the package contain more than one product
             if len(packages.mapped("quant_ids.product_id")) > 1:
                 return self._response_for_deliver(
                     new_picking,
                     location=location,
                     message=self.msg_store.product_mixed_package_scan_package(),
                 )
+            # abort if the quantity is bigger than one
+            if sum(packages.quant_ids.mapped("reserved_quantity")) > 1:
+                return self._response_for_deliver(
+                    new_picking,
+                    location=location,
+                    message=self.msg_store.product_not_unitary_in_package_scan_package(),
+                )
+        # We focus only on lines on which we can increase the 'qty_done'
+        lines = lines.filtered(
+            lambda l: (l.qty_done + product_qty) <= l.product_uom_qty
+        )
         # Filter lines to keep only ones from one delivery operation
         # (we do not want to process lines of another delivery operation)
         lines = lines._filter_on_picking(picking)
+        # We want to process 1 qty of one line
+        lines = fields.first(lines)
         # Validate lines (this will validate the delivery if all lines are processed)
         if self._set_lines_done(lines, product_qty):
             return self._response_for_deliver(
                 location=location, message=self.msg_store.transfer_complete(new_picking)
             )
         return self._response_for_deliver(new_picking, location=location)
 
-    def _deliver_lot(self, picking, lot, location):
+    def _deliver_lot(self, picking, lot, product_qty=None, location=None):
         lines = self.env["stock.move.line"].search(
-            self._lines_from_lot_domain(lot, location=location)
+            self._lines_from_lot_domain(
+                lot, no_qty_done=False, product_qty=product_qty, location=location
+            )
         )
         if not lines:
             return self._response_for_deliver(
                 picking,
                 location=location,
                 message=self.msg_store.lot_not_found_in_pickings(),
             )
@@ -434,30 +459,34 @@
             if len(packages.quant_ids) > 1:
                 return self._response_for_deliver(
                     new_picking,
                     location=location,
                     message=self.msg_store.lot_mixed_package_scan_package(),
                 )
 
-        if self._set_lines_done(lines):
+        # Filter lines to keep only ones from one delivery operation
+        # (we do not want to process lines of another delivery operation)
+        lines = lines._filter_on_picking(picking)
+        # We want to process 1 qty of one line
+        lines = fields.first(lines)
+        if self._set_lines_done(lines, product_qty=product_qty):
             return self._response_for_deliver(
                 location=location, message=self.msg_store.transfer_complete(new_picking)
             )
         return self._response_for_deliver(new_picking, location)
 
     def _action_picking_done(self, picking, force=False):
         """Try to validate the stock picking if all quantities are satisfied.
 
         Return `True` if the picking has been validated successfully.
 
         :param picking: stock.picking recordset
         :param force: bypass check and set picking as done no matter if satisfied.
             You will likely get a backorder for not processed lines.
         """
-
         if picking.state == "done":
             return True
         if force:
             picking._action_done()
             return True
         all_done = False
         for move in picking.move_lines:
```

## odoo/addons/shopfloor/services/location_content_transfer.py

```diff
@@ -1,11 +1,12 @@
 # Copyright 2020-2021 Camptocamp SA (http://www.camptocamp.com)
 # Copyright 2020-2022 Jacques-Etienne Baudoux (BCIM) <je@bcim.be>
+# Copyright 2023 Michael Tietz (MT Software) <mtietz@mt-software.de>
 # License AGPL-3.0 or later (http://www.gnu.org/licenses/agpl.html).
-from odoo import _
+from odoo import _, fields
 
 from odoo.addons.base_rest.components.service import to_int
 from odoo.addons.component.core import Component
 
 from ..utils import to_float
 
 # NOTE for the implementation: share several similarities with the "cluster
@@ -15,15 +16,15 @@
 # TODO add picking and package content in package level?
 
 
 class LocationContentTransfer(Component):
     """
     Methods for the Location Content Transfer Process
 
-    Move the full content of a location to one or another location.
+    Move the full content of a location to one or more locations.
 
     Generally used to move a pallet with multiple boxes to either:
 
     * 1 destination location, unloading the full pallet
     * To multiple destination locations, unloading one product/lot per
       locations
     * To multiple destination locations, unloading one product/lot per
@@ -46,17 +47,41 @@
     """
 
     _inherit = "base.shopfloor.process"
     _name = "shopfloor.location.content.transfer"
     _usage = "location_content_transfer"
     _description = __doc__
 
+    _advisory_lock_find_work = "location_content_transfer_find_work"
+
     def _response_for_start(self, message=None, popup=None):
-        """Transition to the 'start' state"""
-        return self._response(next_state="start", message=message, popup=popup)
+        """Transition to the 'start' or 'get_work' state
+
+        The switch to 'get_work' is done if the option is enabled on the scenario
+        """
+        if self.work.menu.allow_get_work:
+            return self._response(
+                next_state="get_work", data={}, message=message, popup=popup
+            )
+        return self._response(next_state="scan_location", message=message, popup=popup)
+
+    def _response_for_scan_location(self, location=None, message=None):
+        """Transition to the 'scan_location' state
+
+        If location is set, the client will display information on that location
+        and only accept this specific location to be scanned.
+        """
+        data = {}
+        if location:
+            data["location"] = self.data.location(location)
+        return self._response(
+            next_state="scan_location",
+            data=data,
+            message=message,
+        )
 
     def _response_for_scan_destination_all(
         self, pickings, message=None, confirmation_required=False
     ):
         """Transition to the 'scan_destination_all' state
 
         The client screen shows a summary of all the lines and packages
@@ -160,41 +185,44 @@
             self._domain_recover_pickings()
         )
         started_pickings = candidate_pickings.filtered(
             lambda picking: any(line.qty_done for line in picking.move_line_ids)
         )
         return started_pickings
 
+    def _recover_started_picking(self):
+        """Get the next response if the user has work in progress."""
+        started_pickings = self._search_recover_pickings()
+        if not started_pickings:
+            return False
+        return self._router_single_or_all_destination(
+            started_pickings, message=self.msg_store.recovered_previous_session()
+        )
+
     def start_or_recover(self):
         """Start a new session or recover an existing one
 
         If the current user had transfers in progress in this scenario
         and reopen the menu, we want to directly reopen the screens to choose
         destinations. Otherwise, we go to the "start" state.
         """
-        started_pickings = self._search_recover_pickings()
-        if started_pickings:
-            return self._router_single_or_all_destination(
-                started_pickings, message=self.msg_store.recovered_previous_session()
-            )
-        return self._response_for_start()
+        response = self._recover_started_picking()
+        return response or self._response_for_start()
 
     def _find_location_move_lines_domain(self, location):
         return [
             ("location_id", "=", location.id),
             ("qty_done", "=", 0),
             ("state", "in", ("assigned", "partially_available")),
-            ("shopfloor_user_id", "=", False),
+            ("picking_id.user_id", "in", (False, self.env.uid)),
+            ("picking_id.state", "=", "assigned"),
         ]
 
-    def _find_location_all_move_lines_domain(self, location):
-        return [
-            ("location_id", "=", location.id),
-            ("state", "in", ("assigned", "partially_available")),
-        ]
+    def _find_location_move_lines_from_scan_location(self, *args, **kwargs):
+        return self._find_location_move_lines(*args, **kwargs)
 
     def _find_location_move_lines(self, location):
         """Find lines that potentially are to move in the location"""
         return self.env["stock.move.line"].search(
             self._find_location_move_lines_domain(location)
         )
 
@@ -218,49 +246,83 @@
                     "location_dest_id": picking_type.default_location_dest_id.id,
                     "origin": self.work.menu.name,
                     "picking_type_id": picking_type.id,
                 }
             )
         return self.env["stock.move"].create(move_vals_list)
 
-    def _unreserve_other_lines(self, location, move_lines):
-        """Unreserve move lines in location in another picking type
+    def _find_location_to_work_from(self):
+        location = self.env["stock.location"]
+        pickings = self.env["stock.picking"].search(
+            [
+                ("picking_type_id", "in", self.picking_types.ids),
+                ("state", "=", "assigned"),
+                ("user_id", "in", (False, self.env.user.id)),
+            ],
+            order="user_id, priority desc, scheduled_date asc, id desc",
+        )
+
+        for next_picking in pickings:
+            move_lines = next_picking.move_line_ids.filtered(
+                lambda line: line.qty_done < line.product_uom_qty
+            )
+            location = fields.first(move_lines).location_id
+            if location:
+                break
+        return location
+
+    def find_work(self):
+        """Find the next location to work from, for a user.
+
+        First recover any started pickings.
+        The find the first move line from the oldest transfer that can be worked on.
+        Mark all move lines on that location as picked.
+        And ask the user to confirm.
 
-        Returns a tuple of (
-          move lines that stays in the location to process,
-          moves to reserve again,
-          response to return to client in case of error
-        )
-        """
-        lines_other_picking_types = move_lines.filtered(
-            lambda line: line.picking_id.picking_type_id not in self.picking_types
-        )
-        if not lines_other_picking_types:
-            return (move_lines, self.env["stock.move"].browse(), None)
-        unreserved_moves = move_lines.move_id
-        location_move_lines = self.env["stock.move.line"].search(
-            self._find_location_all_move_lines_domain(location)
-        )
-        extra_move_lines = location_move_lines - move_lines
-        if extra_move_lines:
-            return (
-                self.env["stock.move.line"].browse(),
-                self.env["stock.move"].browse(),
-                self._response_for_start(
-                    message=self.msg_store.picking_already_started_in_location(
-                        extra_move_lines.picking_id
-                    )
-                ),
-            )
-        package_levels = move_lines.package_level_id
-        # if we leave the package level around, it will try to reserve
-        # the same package as before
-        package_levels.explode_package()
-        unreserved_moves._do_unreserve()
-        return (move_lines - lines_other_picking_types, unreserved_moves, None)
+        Transitions:
+        * start: no work found
+        * scan_location: with the location to work form for confirmation
+        """
+        response = self._recover_started_picking()
+        if response:
+            return response
+        self._actions_for("lock").advisory(self._advisory_lock_find_work)
+        location = self._find_location_to_work_from()
+        if not location:
+            return self._response_for_start(message=self.msg_store.no_work_found())
+        move_lines = self._find_location_move_lines(location)
+        stock = self._actions_for("stock")
+        stock.mark_move_line_as_picked(move_lines, quantity=0)
+        return self._response_for_scan_location(location=location)
+
+    def _find_move_lines_to_cancel_work(self, location):
+        unreserve = self._actions_for("stock.unreserve")
+        return self.env["stock.move.line"].search(
+            unreserve._find_location_all_move_lines_domain(location)
+        )
+
+    def _move_lines_cancel_work(self, move_lines):
+        move_lines.write({"shopfloor_user_id": False})
+        move_lines.mapped("picking_id").write({"user_id": False})
+        stock = self._actions_for("stock")
+        stock.unmark_move_line_as_picked(move_lines)
+
+    def cancel_work(self, location_id):
+        """Cancel work marked as picked by the user.
+
+        Transitions:
+        * start:
+        """
+        location = self.env["stock.location"].browse(location_id)
+        if not location:
+            return self._response_for_start(message=self.msg_store.location_not_found())
+
+        move_lines = self._find_move_lines_to_cancel_work(location)
+        self._move_lines_cancel_work(move_lines)
+        return self._response_for_start()
 
     def scan_location(self, barcode):  # noqa: C901
         """Scan start location
 
         Called at the beginning at the workflow to select the location from which
         we want to move the content.
 
@@ -290,25 +352,27 @@
             return self._response_for_start(message=self.msg_store.barcode_not_found())
 
         if not self.is_src_location_valid(location):
             return self._response_for_start(
                 message=self.msg_store.cannot_move_something_in_picking_type()
             )
 
-        move_lines = self._find_location_move_lines(location)
+        move_lines = self._find_location_move_lines_from_scan_location(location)
 
         savepoint = self._actions_for("savepoint").new()
+        unreserve = self._actions_for("stock.unreserve")
 
         unreserved_moves = self.env["stock.move"].browse()
         if self.work.menu.allow_unreserve_other_moves:
-            move_lines, unreserved_moves, response = self._unreserve_other_lines(
-                location, move_lines
+            message = unreserve.check_unreserve(location, move_lines)
+            if message:
+                return self._response_for_start(message=message)
+            move_lines, unreserved_moves = unreserve.unreserve_moves(
+                move_lines, self.picking_types
             )
-            if response:
-                return response
         else:
             picking_types = move_lines.picking_id.picking_type_id
             if len(picking_types) > 1:
                 return self._response_for_start(
                     message={
                         "message_type": "error",
                         "body": _("This location content can't be moved at once."),
@@ -336,21 +400,14 @@
             if not all([x.state == "assigned" for x in new_moves]):
                 savepoint.rollback()
                 return self._response_for_start(
                     message=self.msg_store.new_move_lines_not_assigned()
                 )
             move_lines = new_moves.move_line_ids
             for line in move_lines:
-                for line in move_lines:
-                    line.write(
-                        {
-                            "qty_done": line.product_uom_qty,
-                            "shopfloor_user_id": self.env.uid,
-                        }
-                    )
                 if not self.is_dest_location_valid(line.move_id, line.location_dest_id):
                     savepoint.rollback()
                     return self._response_for_start(
                         message=self.msg_store.location_content_unable_to_transfer(
                             location
                         )
                     )
@@ -398,16 +455,15 @@
     def _set_all_destination_lines_and_done(self, pickings, move_lines, dest_location):
         self._write_destination_on_lines(move_lines, dest_location)
         stock = self._actions_for("stock")
         stock.validate_moves(move_lines.move_id)
 
     def _lock_lines(self, lines):
         """Lock move lines"""
-        sql = "SELECT id FROM %s WHERE ID IN %%s FOR UPDATE" % lines._table
-        self.env.cr.execute(sql, (tuple(lines.ids),), log_exceptions=False)
+        self._actions_for("lock").for_update(lines)
 
     def set_destination_all(self, location_id, barcode, confirmation=False):
         """Scan destination location for all the moves of the location
 
         barcode is a stock.location for the destination
 
         Transitions:
@@ -500,14 +556,17 @@
             return self._response_for_scan_destination(location, package_level)
 
         move_lines = self._find_transfer_move_lines(location)
         package_move_lines = package_level.move_line_ids
         other_move_lines = move_lines - package_move_lines
 
         product = search.product_from_scan(barcode)
+        if not product:
+            packaging = search.packaging_from_scan(barcode)
+            product = packaging.product_id
         # Normally the user scan the barcode of the package. But if they scan the
         # product and we can be sure it's the correct package, it's tolerated.
         if product and product in package_move_lines.mapped("product_id"):
             if product in other_move_lines.mapped("product_id") or product.tracking in (
                 "lot",
                 "serial",
             ):
@@ -568,14 +627,19 @@
         package = search.package_from_scan(barcode)
         if package and move_line.package_id == package:
             # In case we have a source package but no package level because if
             # we have a package level, we would use "scan_package".
             return self._response_for_scan_destination(location, move_line)
 
         product = search.product_from_scan(barcode)
+        if not product:
+            packaging = search.packaging_from_scan(barcode)
+            if packaging:
+                product = packaging.product_id
+
         if product and product == move_line.product_id:
             if product.tracking in ("lot", "serial"):
                 move_lines = self._find_transfer_move_lines(location)
                 return self._response_for_start_single(
                     move_lines.mapped("picking_id"),
                     message=self.msg_store.scan_lot_on_product_tracked_by_lot(),
                 )
@@ -902,14 +966,20 @@
     _inherit = "base.shopfloor.validator"
     _name = "shopfloor.location.content.transfer.validator"
     _usage = "location_content_transfer.validator"
 
     def start_or_recover(self):
         return {}
 
+    def get_work(self):
+        return {}
+
+    def cancel_work(self):
+        return {"location_id": {"required": True, "type": "integer"}}
+
     def scan_location(self):
         return {"barcode": {"required": True, "type": "string"}}
 
     def set_destination_all(self):
         return {
             "location_id": {"coerce": to_int, "required": True, "type": "integer"},
             "barcode": {"required": True, "type": "string"},
@@ -992,14 +1062,16 @@
         """List of possible next states
 
         With the schema of the data send to the client to transition
         to the next state.
         """
         return {
             "start": {},
+            "scan_location": {},
+            "get_work": {},
             "scan_destination_all": self._schema_all,
             "start_single": self._schema_single,
             "scan_destination": self._schema_single,
         }
 
     @property
     def _schema_all(self):
@@ -1031,51 +1103,99 @@
                 "nullable": True,
                 "required": False,
             },
         }
 
     def start_or_recover(self):
         return self._response_schema(
-            next_states={"start", "scan_destination_all", "start_single"}
+            next_states={
+                "scan_location",
+                "scan_destination_all",
+                "start_single",
+                "get_work",
+            }
         )
 
     def scan_location(self):
         return self._response_schema(
-            next_states={"start", "scan_destination_all", "start_single"}
+            next_states={
+                "scan_location",
+                "get_work",
+                "scan_destination_all",
+                "start_single",
+            }
         )
 
     def set_destination_all(self):
-        return self._response_schema(next_states={"start", "scan_destination_all"})
+        return self._response_schema(
+            next_states={"scan_location", "get_work", "scan_destination_all"}
+        )
 
     def go_to_single(self):
-        return self._response_schema(next_states={"start", "start_single"})
+        return self._response_schema(
+            next_states={"scan_location", "get_work", "start_single"}
+        )
 
     def scan_package(self):
         return self._response_schema(
-            next_states={"start", "start_single", "scan_destination"}
+            next_states={
+                "scan_location",
+                "get_work",
+                "start_single",
+                "scan_destination",
+            }
         )
 
     def scan_line(self):
         return self._response_schema(
-            next_states={"start", "start_single", "scan_destination"}
+            next_states={
+                "scan_location",
+                "get_work",
+                "start_single",
+                "scan_destination",
+            }
         )
 
     def set_destination_package(self):
-        return self._response_schema(next_states={"start_single", "scan_destination"})
+        return self._response_schema(
+            next_states={
+                "scan_location",
+                "get_work",
+                "start_single",
+                "scan_destination",
+            }
+        )
 
     def set_destination_line(self):
-        return self._response_schema(next_states={"start_single", "scan_destination"})
+        return self._response_schema(
+            next_states={
+                "scan_location",
+                "get_work",
+                "start_single",
+                "scan_destination",
+            }
+        )
 
     def postpone_package(self):
-        return self._response_schema(next_states={"start_single"})
+        return self._response_schema(
+            next_states={"scan_location", "get_work", "start_single"}
+        )
 
     def postpone_line(self):
-        return self._response_schema(next_states={"start_single"})
+        return self._response_schema(
+            next_states={"scan_location", "get_work", "start_single"}
+        )
 
     def stock_out_package(self):
-        return self._response_schema(next_states={"start", "start_single"})
+        return self._response_schema(
+            next_states={"scan_location", "get_work", "start_single"}
+        )
 
     def stock_out_line(self):
-        return self._response_schema(next_states={"start", "start_single"})
+        return self._response_schema(
+            next_states={"scan_location", "get_work", "start_single"}
+        )
 
     def dismiss_package_level(self):
-        return self._response_schema(next_states={"start", "start_single"})
+        return self._response_schema(
+            next_states={"scan_location", "get_work", "start_single"}
+        )
```

## odoo/addons/shopfloor/services/service.py

```diff
@@ -42,26 +42,26 @@
     def search_move_line(self):
         # TODO: picking types should be set somehow straight in the work context
         # by `_validate_headers_update_work_context` in this way
         # we can remove this override and the need to call `_get_process_picking_types`
         # every time.
         return self._actions_for("search_move_line", picking_types=self.picking_types)
 
-    def _check_picking_status(self, pickings):
+    def _check_picking_status(self, pickings, states=("assigned",)):
         """Check if given pickings can be processed.
 
         If the picking is already done, canceled or didn't belong to the
         expected picking type, a message is returned.
         """
         for picking in pickings:
             if not picking.exists():
                 return self.msg_store.stock_picking_not_found()
             if picking.state == "done":
                 return self.msg_store.already_done()
-            if picking.state != "assigned":  # the picking must be ready
+            if picking.state not in states:  # the picking must be ready
                 return self.msg_store.stock_picking_not_available(picking)
             if picking.picking_type_id not in self.picking_types:
                 return self.msg_store.cannot_move_something_in_picking_type()
 
     def is_src_location_valid(self, location):
         """Check the source location is valid for given process.
```

## odoo/addons/shopfloor/services/single_pack_transfer.py

```diff
@@ -19,24 +19,24 @@
 
     _inherit = "base.shopfloor.process"
     _name = "shopfloor.single.pack.transfer"
     _usage = "single_pack_transfer"
     _description = __doc__
 
     def _data_after_package_scanned(self, package_level):
-        move_line = package_level.move_line_ids[0]
+        move_lines = package_level.move_line_ids
         package = package_level.package_id
         # TODO use data.package_level (but the "name" moves in "package.name")
         return {
             "id": package_level.id,
             "name": package.name,
-            "location_src": self.data.location(move_line.location_id),
+            "location_src": self.data.location(package.location_id),
             "location_dest": self.data.location(package_level.location_dest_id),
-            "product": self.data.product(move_line.product_id),
-            "picking": self.data.picking(move_line.picking_id),
+            "products": self.data.products(move_lines.product_id),
+            "picking": self.data.picking(move_lines.picking_id),
         }
 
     def _response_for_start(self, message=None, popup=None):
         return self._response(next_state="start", message=message, popup=popup)
 
     def _response_for_confirm_start(self, package_level, message=None):
         data = self._data_after_package_scanned(package_level)
@@ -345,15 +345,18 @@
     def _schema_for_package_level_details(self, required=False):
         # TODO use schemas.package_level (but the "name" moves in "package.name")
         return {
             "id": {"required": required, "type": "integer"},
             "name": {"type": "string", "nullable": False, "required": required},
             "location_src": {"type": "dict", "schema": self.schemas.location()},
             "location_dest": {"type": "dict", "schema": self.schemas.location()},
-            "product": {"type": "dict", "schema": self.schemas.product()},
+            "products": {
+                "type": "list",
+                "schema": {"type": "dict", "schema": self.schemas.product()},
+            },
             "picking": {"type": "dict", "schema": self.schemas.picking()},
         }
 
     def _schema_confirmation_required(self):
         return {
             "confirmation_required": {
                 "type": "boolean",
```

## odoo/addons/shopfloor/services/zone_picking.py

```diff
@@ -1,19 +1,21 @@
 # Copyright 2020-2021 Camptocamp SA (http://www.camptocamp.com)
 # Copyright 2020-2021 Jacques-Etienne Baudoux (BCIM) <je@bcim.be>
+# Copyright 2023 Michael Tietz (MT Software) <mtietz@mt-software.de>
 # License AGPL-3.0 or later (http://www.gnu.org/licenses/agpl.html).
 import functools
 from collections import defaultdict
 
 from odoo.fields import first
 from odoo.tools.float_utils import float_compare, float_is_zero
 
 from odoo.addons.base_rest.components.service import to_bool, to_int
 from odoo.addons.component.core import Component
 
+from ..exceptions import ConcurentWorkOnTransfer
 from ..utils import to_float
 
 
 class ZonePicking(Component):
     """
     Methods for the Zone Picking Process
 
@@ -39,20 +41,23 @@
        chooses the type to work with
     3. The client application shows the list of move lines, with an option
        to choose the sorting of the lines
     4. The operator selects a line to pick, by scanning one of:
 
        * location, if only a single move line there; if a location is scanned
          and it contains several move lines, the view is updated to show only
-         them
+         them. The next scan (e.g. a product) will be based on the previous
+         scanned location.
        * package, if it is linked to a move line. If the package is not linked
          to an existing move line but can be a replacement for one, the view is
          updated to show only the fitting move lines. And the user can confirm
          the change of package by scanning it a second time.
-       * product
+       * product, if only a single move line matches. Otherwise the view is updated
+         to show only the matching move lines, The next scan (e.g. a location) will
+         be based on the previous product scanned.
        * lot
 
     5. The operator scans the destination for the line they scanned, this is where
        the path splits:
 
        * they scan a location, in which case the move line's destination is
          updated with it and the move is done
@@ -190,35 +195,42 @@
     def _response_for_select_line(
         self,
         move_lines,
         message=None,
         popup=None,
         confirmation_required=False,
         product=False,
+        sublocation=False,
+        package=False,
     ):
         if confirmation_required and not message:
             message = self.msg_store.need_confirmation()
-        data = self._data_for_move_lines(move_lines, product=product)
+        data = self._data_for_move_lines(
+            move_lines, product=product, sublocation=sublocation, package=package
+        )
         data["confirmation_required"] = confirmation_required
+        data["scan_location_or_pack_first"] = self.work.menu.scan_location_or_pack_first
         return self._response(
             next_state="select_line",
             data=data,
             message=message,
             popup=popup,
         )
 
     def _response_for_set_line_destination(
         self,
         move_line,
         message=None,
         confirmation_required=False,
+        **kw,
     ):
         if confirmation_required and not message:
             message = self.msg_store.need_confirmation()
         data = self._data_for_move_line(move_line)
+        data["move_line"].update(kw)
         data["confirmation_required"] = confirmation_required
         return self._response(
             next_state="set_line_destination", data=data, message=message
         )
 
     def _response_for_zero_check(self, move_line, message=None):
         data = self._data_for_location(move_line.location_id)
@@ -290,35 +302,49 @@
         return self.search_move_line.counters_for_lines(zone_lines)
 
     def _picking_type_zone_lines(self, zone_location, picking_type):
         return self.search_move_line.search_move_lines_by_location(
             zone_location, picking_type=picking_type
         )
 
-    def _data_for_move_line(self, move_line, zone_location=None, picking_type=None):
+    def _data_for_move_line(
+        self, move_line, zone_location=None, picking_type=None, **kw
+    ):
         zone_location = zone_location or self.zone_location
         picking_type = picking_type or self.picking_type
+        line_data = self.data.move_line(move_line, with_picking=True)
+        line_data.update(kw)
         return {
             "zone_location": self.data.location(zone_location),
             "picking_type": self.data.picking_type(picking_type),
-            "move_line": self.data.move_line(move_line, with_picking=True),
+            "move_line": line_data,
         }
 
     def _data_for_move_lines(
-        self, move_lines, zone_location=None, picking_type=None, product=None
+        self,
+        move_lines,
+        zone_location=None,
+        picking_type=None,
+        product=None,
+        sublocation=None,
+        package=None,
     ):
         zone_location = zone_location or self.zone_location
         picking_type = picking_type or self.picking_type
         data = {
             "zone_location": self.data.location(zone_location),
             "picking_type": self.data.picking_type(picking_type),
             "move_lines": self.data.move_lines(move_lines, with_picking=True),
         }
         if product:
             data["product"] = self.data.product(product)
+        if sublocation and sublocation != zone_location:
+            data["sublocation"] = self.data.location(sublocation)
+        if package:
+            data["package"] = self.data.package(package)
         for data_move_line in data["move_lines"]:
             # TODO: this could be expensive, think about a better way
             # to retrieve if location will be empty.
             # Maybe group lines by location and compute only once.
             move_line = self.env["stock.move.line"].browse(data_move_line["id"])
             # `location_will_be_empty` flag states if, by processing this move line
             # and picking the product, the location will be emptied.
@@ -375,24 +401,26 @@
         self,
         locations=None,
         picking_type=None,
         package=None,
         product=None,
         lot=None,
         match_user=False,
+        enforce_empty_package=False,
     ):
         """Find lines that potentially need work in given locations."""
         return self.search_move_line.search_move_lines_by_location(
             locations or self.zone_location,
             picking_type=picking_type or self.picking_type,
             order=self.lines_order,
             package=package,
             product=product,
             lot=lot,
             match_user=match_user,
+            enforce_empty_package=enforce_empty_package,
         )
 
     def _find_buffer_move_lines_domain(self, dest_package=None):
         domain = [
             ("picking_id.picking_type_id", "in", self.picking_types.ids),
             ("qty_done", ">", 0),
             ("state", "not in", ("cancel", "done")),
@@ -461,168 +489,309 @@
         """List all move lines to pick, sorted
 
         Transitions:
         * select_line: show the list of move lines
         """
         return self._list_move_lines(self.zone_location)
 
-    def _list_move_lines(self, location, product=False):
-        move_lines = self._find_location_move_lines(location, product=product)
-        return self._response_for_select_line(move_lines, product=product)
+    def _list_move_lines(
+        self, location, product=False, sublocation=False, package=False
+    ):
+        move_lines = self._find_location_move_lines(
+            sublocation or location, product=product, package=package, match_user=True
+        )
+        return self._response_for_select_line(
+            move_lines, product=product, sublocation=sublocation, package=package
+        )
 
-    def _scan_source_location(self, barcode, confirmation=False, product_id=False):
+    def _scan_source_location(
+        self,
+        barcode,
+        confirmation=False,
+        product_id=False,
+        sublocation=False,
+        package=False,
+    ):
         """Search a location and find available lines into it."""
         response = None
         message = None
         search = self._actions_for("search")
         location = search.location_from_scan(barcode)
         if not location:
             return response, message
 
         if not location.is_sublocation_of(self.zone_location):
             response = self._list_move_lines(self.zone_location)
             message = self.msg_store.location_not_allowed()
             return response, message
 
-        product, lot, package = self._find_product_in_location(location, product_id)
-        if len(product) > 1:
+        if package and package.location_id != location:
+            # Do not search based on a package from a previous location
+            package = False
+        product, lot, packages = self._find_product_in_location(
+            location, product_id, package
+        )
+        if len(packages) > 1:
+            message = self.msg_store.several_packs_in_location(location)
+        elif len(packages) == 1 and self.work.menu.scan_location_or_pack_first:
+            message = self.msg_store.scan_the_package()
+        elif len(product) > 1 and not message:
             message = self.msg_store.several_products_in_location(location)
-        elif len(lot) > 1:
+        elif len(lot) > 1 and not message:
             message = self.msg_store.several_lots_in_location(location)
-        elif len(package) > 1:
-            message = self.msg_store.several_packs_in_location(location)
         if message:
-            # So next scan will be check in relation to
-            self._zone_location = location
-            response = self._list_move_lines(location)
+            response = self._list_move_lines(
+                location, sublocation=location, package=package
+            )
             return response, message
-
         move_lines = self._find_location_move_lines(
             location,
             product=product,
             lot=lot,
             package=package,
             match_user=True,
         )
         if move_lines:
-            response = self._response_for_set_line_destination(first(move_lines))
+            move_line = first(move_lines)
+            response = self._response_for_set_line_destination(
+                move_line, qty_done=self._get_prefill_qty(move_line)
+            )
         else:
-            # if no move line, narrow the list of move lines on the scanned location
-            response = self._list_move_lines(location)
-            message = self.msg_store.location_empty(location)
+            response = self._list_move_lines(self.zone_location)
+            message = self.msg_store.wrong_record(location)
         return response, message
 
-    def _find_product_in_location(self, location, product_id):
+    def _find_product_in_location(self, location, product_id, package=False):
         """Find the prooducts in stock in given location move line in the location."""
         domain = [("location_id", "=", location.id)]
         if product_id:
             domain.append(("product_id", "=", product_id))
+        if package:
+            domain.append(("package_id", "=", package.id))
         quants = self.env["stock.quant"].search(domain)
         product = quants.product_id
         lot = quants.lot_id
         package = quants.package_id
         return product, lot, package
 
-    def _scan_source_package(self, barcode, confirmation=False, product_id=False):
+    def _scan_source_package(
+        self,
+        barcode,
+        confirmation=False,
+        product_id=False,
+        sublocation=False,
+        package=False,
+    ):
         """Search a package and find available lines for it.
 
         First search for lines that have the specific package.
         If none are found search for lines whose package could be replaced
         by the one selected and in that case ask for confirmation.
         """
         message = None
         response = None
         search = self._actions_for("search")
         packaging = self._actions_for("packaging")
         package = search.package_from_scan(barcode)
         if not package:
             return response, message
-        if packaging.package_has_several_products(package):
-            message = self.msg_store.several_products_in_package(package)
-        if packaging.package_has_several_lots(package):
-            message = self.msg_store.several_lots_in_package(package)
-        if message:
-            return self.list_move_lines(), message
-        move_lines = self._find_location_move_lines(package=package)
+        if not package.location_id.is_sublocation_of(self.zone_location):
+            # Package is not in an allowed location
+            response = self._list_move_lines(self.zone_location)
+            message = self.msg_store.location_not_allowed()
+            return response, message
+
+        move_lines = self._find_location_move_lines(
+            locations=sublocation, package=package
+        )
         if move_lines:
-            response = self._response_for_set_line_destination(first(move_lines))
+            if packaging.package_has_several_products(package):
+                message = self.msg_store.several_products_in_package(package)
+            if packaging.package_has_several_lots(package):
+                message = self.msg_store.several_lots_in_package(package)
+            if message:
+                return (
+                    self._list_move_lines(
+                        self.zone_location,
+                        sublocation=sublocation,
+                        package=package,
+                    ),
+                    message,
+                )
+            move_line = first(move_lines)
+            # Fix me for a package prefill qty is zero ?
+            qty_done = self._get_prefill_qty(move_line)
+            response = self._response_for_set_line_destination(
+                move_line, qty_done=qty_done
+            )
             return response, message
-        pack_location = package.location_id
-        if pack_location and pack_location.is_sublocation_of(self.zone_location):
-            # Check if the package selected can be a substitute on a move line
-            move_lines = self._find_location_move_lines(
-                locations=pack_location,
-                product=package.product_packaging_id.product_id,
+        # Check if the package selected can be a substitute on a move line
+        products = package.quant_ids.filtered(lambda q: q.quantity > 0).product_id
+        for product in products:
+            move_lines |= self._find_location_move_lines(
+                locations=package.location_id,
+                product=product,
             )
         if move_lines:
             if not confirmation:
                 message = self.msg_store.package_different_change()
                 response = self._response_for_select_line(
                     move_lines, message, confirmation_required=True
                 )
             else:
                 change_package_lot = self._actions_for("change.package.lot")
                 response = change_package_lot.change_package(
                     first(move_lines),
                     package,
+                    # FIXME we may need to pass the quantity being done
                     self._response_for_set_line_destination,
                     self._response_for_change_pack_lot,
                 )
         else:
-            response = self._list_move_lines(self.zone_location)
+            response = self._list_move_lines(sublocation or self.zone_location)
             message = self.msg_store.package_has_no_product_to_take(barcode)
         return response, message
 
-    def _scan_source_product(self, barcode, confirmation=False, product_id=False):
+    def _get_prefill_qty(self, move_line, qty=0):
+        """Returns the done quantity to use on the selection of a move line.
+
+        Before the introduction of the no prefill quantity parameter on scenarios,
+        when a move line was selected the done quantity was equal to the quantity
+        on the line. This is still the default behaviour.
+        But when the no prefill quantity is set. The quantity done will be set
+        according to the scanned barcode.
+
+        """
+        if self.work.menu.no_prefill_qty:
+            return qty
+        return move_line.product_uom_qty
+
+    def _scan_source_product(
+        self,
+        barcode,
+        confirmation=False,
+        product_id=False,
+        sublocation=False,
+        package=False,
+    ):
         """Search a product and find available lines for it."""
         message = None
         response = None
         search = self._actions_for("search")
         product = search.product_from_scan(barcode)
+        packaging = self.env["product.packaging"].browse()
+        if not product:
+            packaging = search.packaging_from_scan(barcode)
+            product = packaging.product_id
         if not product:
             return response, message
-        move_lines = self._find_location_move_lines(product=product)
+        move_lines = self._find_location_move_lines(
+            locations=sublocation,
+            product=product,
+            package=package,
+            enforce_empty_package=self.work.menu.scan_location_or_pack_first,
+        )
+
+        move_lines_with_package_ids = []
+        move_lines_without_package_ids = []
+        if not package and self.work.menu.scan_location_or_pack_first:
+            for move_line in move_lines:
+                if move_line.package_id:
+                    move_lines_with_package_ids.append(move_line.id)
+                else:
+                    move_lines_without_package_ids.append(move_line.id)
+            move_lines = move_lines.browse(move_lines_without_package_ids)
+
         if len(move_lines.location_id) > 1:
             message = self.msg_store.several_move_in_different_location()
         elif len(move_lines.lot_id) > 1:
             message = self.msg_store.several_move_with_different_lot()
         if message:
-            response = self._list_move_lines(self.zone_location, product)
+            response = self._list_move_lines(
+                self.zone_location, product, sublocation=sublocation, package=package
+            )
         elif move_lines:
-            response = self._response_for_set_line_destination(first(move_lines))
+            move_line = first(move_lines)
+            qty_done = self._get_prefill_qty(move_line, qty=(packaging.qty or 1.0))
+            response = self._response_for_set_line_destination(
+                move_line, qty_done=qty_done
+            )
         else:
-            response = self._list_move_lines(self.zone_location)
-            message = self.msg_store.product_not_found()
+            response = self._list_move_lines(
+                sublocation or self.zone_location,
+                sublocation=sublocation,
+                package=package,
+            )
+            if move_lines_with_package_ids:
+                message = self.msg_store.product_not_unitary_in_package_scan_package()
+            else:
+                message = self.msg_store.product_not_found_in_pickings()
         return response, message
 
-    def _scan_source_lot(self, barcode, confirmation=False, product_id=False):
+    def _scan_source_lot(
+        self,
+        barcode,
+        confirmation=False,
+        product_id=False,
+        sublocation=False,
+        package=False,
+    ):
         """Search a lot and find available lines for it."""
         message = None
         response = None
         search = self._actions_for("search")
         products = self.env["product.product"].browse(product_id)
         # Could get several lots from different products, check each of them
         lots = search.lot_from_scan(barcode, products=products, limit=None)
         if not lots:
             return response, message
+        move_lines_with_package_ids = []
+        move_lines_without_package_ids = []
         for lot in lots:
-            move_lines = self._find_location_move_lines(lot=lot)
+            move_lines = self._find_location_move_lines(
+                locations=sublocation, lot=lot, package=package
+            )
             if not move_lines:
                 continue
+            if not package and self.work.menu.scan_location_or_pack_first:
+                for move_line in move_lines:
+                    if move_line.package_id:
+                        move_lines_with_package_ids.append(move_line.id)
+                    else:
+                        move_lines_without_package_ids.append(move_line.id)
+                move_lines = move_lines.browse(move_lines_without_package_ids)
+
             if len(move_lines.location_id) > 1:
                 message = self.msg_store.several_move_in_different_location()
                 response = self.list_move_lines()
             else:
-                response = self._response_for_set_line_destination(first(move_lines))
+                move_line = first(move_lines)
+                qty_done = self._get_prefill_qty(move_line, qty=1.0)
+                response = self._response_for_set_line_destination(
+                    move_line, qty_done=qty_done
+                )
             return response, message
-        response = self._list_move_lines(self.zone_location)
-        message = self.msg_store.lot_not_found()
+        message = self.msg_store.lot_not_found_in_pickings()
+        response = self._list_move_lines(
+            sublocation or self.zone_location, package=package
+        )
+        if move_lines_with_package_ids:
+            message = self.msg_store.lot_mixed_package_scan_package()
+        else:
+            message = self.msg_store.lot_not_found_in_pickings()
         return response, message
 
-    def scan_source(self, barcode, confirmation=False, product_id=None):
+    def scan_source(
+        self,
+        barcode,
+        confirmation=False,
+        product_id=None,
+        sublocation_id=None,
+        package_id=None,
+    ):
         """Select a move line or narrow the list of move lines
 
         When the barcode is a location and we can unambiguously know which move
         line is picked (the quants in the location has one product/lot/package,
         matching a single move line), then the move line is selected.
         Otherwise, the list of move lines is refreshed with a filter on the
         scanned location, showing the move lines that have this location as
@@ -633,37 +802,64 @@
 
         A selected line goes to the next screen to select the destination
         location or package.
 
         If a product is passed to the function the search on move line will
         be filtered based on it as well.
 
+        And if a sublocation_id is passed the search on move line will be restriced
+        to it.
+
         Transitions:
         * select_line: barcode not found or narrow the list on a location
         * set_line_destination: a line has been selected for picking
         """
-
         # select corresponding move line from barcode (location, package, product, lot)
+        sublocation = (
+            self.env["stock.location"].browse(sublocation_id).exists()
+            if sublocation_id
+            else self.env["stock.location"]
+        )
+        selected_package = (
+            self.env["stock.quant.package"].browse(package_id).exists()
+            if package_id
+            else self.env["stock.quant.package"]
+        )
         handlers = (
             # search by location 1st
             self._scan_source_location,
             # then by package
             self._scan_source_package,
-            # then by product
-            self._scan_source_product,
-            # then by lot
-            self._scan_source_lot,
+        ) + (
+            # if first scan location or pack option is not set
+            # or the sublocation has already been scanned
+            (
+                # by product
+                self._scan_source_product,
+                # then by lot
+                self._scan_source_lot,
+            )
+            if not self.work.menu.scan_location_or_pack_first
+            or sublocation_id
+            or selected_package
+            else ()
         )
         for handler in handlers:
             response, message = handler(
-                barcode, confirmation=confirmation, product_id=product_id
+                barcode,
+                confirmation=confirmation,
+                product_id=product_id,
+                sublocation=sublocation,
+                package=selected_package,
             )
             if response:
                 return self._response(base_response=response, message=message)
-        response = self.list_move_lines()
+        response = self._list_move_lines(
+            self.zone_location, sublocation=sublocation, package=selected_package
+        )
         return self._response(
             base_response=response, message=self.msg_store.barcode_not_found()
         )
 
     def _set_destination_location(self, move_line, quantity, confirmation, location):
         location_changed = False
         response = None
@@ -673,40 +869,54 @@
         # if `confirmation is True
         # Ask confirmation to the user if the scanned location is not in the
         # expected ones but is valid (in picking type's default destination)
         if not self.is_dest_location_valid(move_line.move_id, location):
             response = self._response_for_set_line_destination(
                 move_line,
                 message=self.msg_store.dest_location_not_allowed(),
+                qty_done=quantity,
             )
             return (location_changed, response)
 
         if not confirmation and self.is_dest_location_to_confirm(
             move_line.location_dest_id, location
         ):
             response = self._response_for_set_line_destination(
                 move_line,
                 message=self.msg_store.confirm_location_changed(
                     move_line.location_dest_id, location
                 ),
                 confirmation_required=True,
+                qty_done=quantity,
             )
             return (location_changed, response)
 
         # If no destination package
         if not move_line.result_package_id:
             response = self._response_for_set_line_destination(
                 move_line,
                 message=self.msg_store.dest_package_required(),
+                qty_done=quantity,
             )
             return (location_changed, response)
         # destination location set to the scanned one
         self._write_destination_on_lines(move_line, location)
         stock = self._actions_for("stock")
-        stock.mark_move_line_as_picked(move_line, quantity)
+        try:
+            stock.mark_move_line_as_picked(move_line, quantity, check_user=True)
+        except ConcurentWorkOnTransfer as error:
+            response = self._response_for_set_line_destination(
+                move_line,
+                message={
+                    "message_type": "error",
+                    "body": str(error),
+                },
+                qty_done=quantity,
+            )
+            return (location_changed, response)
         stock.validate_moves(move_line.move_id)
         location_changed = True
         # Zero check
         zero_check = self.picking_type.shopfloor_zero_check
         if zero_check and move_line.location_id.planned_qty_in_location_is_empty():
             response = self._response_for_zero_check(move_line)
         return (location_changed, response)
@@ -736,42 +946,86 @@
         # A valid package is:
         # * an empty package
         # * not used as destination for another move line
         if not self._is_package_empty(package):
             response = self._response_for_set_line_destination(
                 move_line,
                 message=self.msg_store.package_not_empty(package),
+                qty_done=quantity,
             )
             return (package_changed, response)
         multiple_move_allowed = self.work.menu.multiple_move_single_pack
         if package.planned_move_line_ids and not multiple_move_allowed:
             response = self._response_for_set_line_destination(
                 move_line,
                 message=self.msg_store.package_already_used(package),
+                qty_done=quantity,
             )
             return (package_changed, response)
         # the quantity done is set to the passed quantity
         # but if we move a partial qty, we need to split the move line
         compare = self._move_line_compare_qty(move_line, quantity)
         qty_greater = compare == 1
         if qty_greater:
             response = self._response_for_set_line_destination(
                 move_line,
                 message=self.msg_store.unable_to_pick_more(move_line.product_uom_qty),
+                qty_done=quantity,
             )
             return (package_changed, response)
         stock = self._actions_for("stock")
-        stock.mark_move_line_as_picked(move_line, quantity, package)
+        try:
+            stock.mark_move_line_as_picked(
+                move_line, quantity, package, check_user=True
+            )
+        except ConcurentWorkOnTransfer as error:
+            response = self._response_for_set_line_destination(
+                move_line,
+                message={
+                    "message_type": "error",
+                    "body": str(error),
+                },
+                qty_done=quantity,
+            )
+            return (package_changed, response)
         package_changed = True
         # Zero check
         zero_check = self.picking_type.shopfloor_zero_check
         if zero_check and move_line.location_id.planned_qty_in_location_is_empty():
             response = self._response_for_zero_check(move_line)
         return (package_changed, response)
 
+    def _set_destination_update_quantity(self, move_line, quantity, barcode):
+        """Handle the done quantity increment on set_destination end point."""
+        response = None
+        if not self.work.menu.no_prefill_qty:
+            return response
+        search = self._actions_for("search")
+        # Handle barcode of product or packaging
+        product = search.product_from_scan(barcode)
+        packaging = self.env["product.packaging"].browse()
+        if not product:
+            packaging = search.packaging_from_scan(barcode)
+            product = packaging.product_id
+        if product and move_line.product_id == product:
+            quantity += packaging.qty or 1.0
+            response = self._response_for_set_line_destination(
+                move_line, qty_done=quantity
+            )
+            return response
+        # Handle barcode of a lot
+        lot = search.lot_from_scan(barcode)
+        if lot and move_line.lot_id == lot:
+            quantity += 1.0
+            response = self._response_for_set_line_destination(
+                move_line, qty_done=quantity
+            )
+            return response
+        return response
+
     # flake8: noqa: C901
     def set_destination(
         self,
         move_line_id,
         barcode,
         quantity,
         confirmation=False,
@@ -803,14 +1057,21 @@
         Those fields will be used to identify which move lines are in the buffer.
 
         A valid package is:
 
         * an empty package
         * not used as destination for another move line
 
+        With the addition of the no prefill quantity parameter this endpoint can also
+        be used to change the done quantity on the move line before setting a
+        destination.
+
+        When the barcode is the product (or its packaging) or the lot on the line:
+            * The done quantity is incremented by one or the packaging quantity.
+
         Transitions:
         * select_line: destination has been set, showing the next lines to pick
         * zero_check: if the option is active and if the quantity of product
           moved is 0 in the source location after the move (beware: at this
           point the product we put in the buffer is still considered to be in
           the source location, so we have to compute the source location's
           quantity - qty_done).
@@ -823,14 +1084,26 @@
         if not move_line.exists():
             return self._response_for_start(message=self.msg_store.record_not_found())
 
         pkg_moved = False
         search = self._actions_for("search")
         accept_only_package = not self._move_line_full_qty(move_line, quantity)
 
+        response = self._set_destination_update_quantity(move_line, quantity, barcode)
+        if response:
+            return response
+
+        if quantity <= 0:
+            message = self.msg_store.picking_zero_quantity()
+            return self._response_for_set_line_destination(
+                move_line,
+                message=message,
+                qty_done=self._get_prefill_qty(move_line, qty=0),
+            )
+
         extra_message = ""
         if not accept_only_package:
             # When the barcode is a location
             location = search.location_from_scan(barcode)
             if location:
                 if self._pick_pack_same_time():
                     (
@@ -840,15 +1113,15 @@
                     # TODO: we should append the msg instead.
                     # To achieve this, we should refactor `response.message` to a list
                     # or, to no break backward compat, we could add `extra_messages`
                     # to allow backend to send a main message and N additional messages.
                     extra_message = message
                     if not good_for_packing:
                         return self._response_for_set_line_destination(
-                            move_line, message=message
+                            move_line, message=message, qty_done=quantity
                         )
                 pkg_moved, response = self._set_destination_location(
                     move_line,
                     quantity,
                     confirmation,
                     location,
                 )
@@ -866,15 +1139,15 @@
             if self._pick_pack_same_time():
                 (
                     good_for_packing,
                     message,
                 ) = self._handle_pick_pack_same_time_for_package(move_line, package)
                 if not good_for_packing:
                     return self._response_for_set_line_destination(
-                        move_line, message=message
+                        move_line, message=message, qty_done=quantity
                     )
             location = move_line.location_dest_id
             pkg_moved, response = self._set_destination_package(
                 move_line, quantity, package
             )
             if response:
                 return response
@@ -883,15 +1156,17 @@
 
         if not pkg_moved and not package:
             if accept_only_package:
                 message = self.msg_store.package_not_found_for_barcode(barcode)
             else:
                 # we don't know if user wanted to scan a location or a package
                 message = self.msg_store.barcode_not_found()
-            return self._response_for_set_line_destination(move_line, message=message)
+            return self._response_for_set_line_destination(
+                move_line, message=message, qty_done=quantity
+            )
 
         if pkg_moved:
             message = self.msg_store.confirm_pack_moved()
             if extra_message:
                 message["body"] += "\n" + extra_message["body"]
 
         # Process the next line
@@ -1296,16 +1571,15 @@
                 return self._response_for_unload_set_destination(first(move_lines))
         return self._unload_response(
             unload_single_message=self.msg_store.barcode_no_match(package.name),
         )
 
     def _lock_lines(self, lines):
         """Lock move lines"""
-        sql = "SELECT id FROM %s WHERE ID IN %%s FOR UPDATE" % lines._table
-        self.env.cr.execute(sql, (tuple(lines.ids),), log_exceptions=False)
+        self._actions_for("lock").for_update(lines)
 
     def unload_set_destination(self, package_id, barcode, confirmation=False):
         """Scan the final destination for move lines in the buffer with the
         destination package
 
         All the move lines in the buffer with the package_id as destination
         package are updated with the scanned location.
@@ -1407,21 +1681,27 @@
         }
 
     def scan_source(self):
         return {
             "barcode": {"required": False, "nullable": True, "type": "string"},
             "confirmation": {"type": "boolean", "nullable": True, "required": False},
             "product_id": {"required": False, "nullable": True, "type": "integer"},
+            "sublocation_id": {"required": False, "nullable": True, "type": "integer"},
+            "package_id": {"required": False, "nullable": True, "type": "integer"},
         }
 
     def set_destination(self):
         return {
             "move_line_id": {"coerce": to_int, "required": True, "type": "integer"},
             "barcode": {"required": False, "nullable": True, "type": "string"},
-            "quantity": {"coerce": to_float, "required": True, "type": "float"},
+            "quantity": {
+                "coerce": to_float,
+                "required": True,
+                "type": "float",
+            },
             "confirmation": {"type": "boolean", "nullable": True, "required": False},
         }
 
     def is_zero(self):
         return {
             "move_line_id": {"coerce": to_int, "required": True, "type": "integer"},
             "zero": {"coerce": to_bool, "required": True, "type": "boolean"},
@@ -1628,25 +1908,36 @@
                 "type": "boolean",
                 "nullable": True,
                 "required": False,
             },
             "product": self.schemas._schema_dict_of(
                 self.schemas.product(), required=False
             ),
+            "sublocation": self.schemas._schema_dict_of(
+                self.schemas.location(), required=False
+            ),
+            "package": self.schemas._schema_dict_of(
+                self.schemas.package(), required=False
+            ),
         }
         return schema
 
     @property
     def _schema_for_move_lines_empty_location(self):
         schema = self._schema_for_move_lines
         schema["move_lines"]["schema"]["schema"]["location_will_be_empty"] = {
             "type": "boolean",
             "nullable": False,
             "required": True,
         }
+        schema["scan_location_or_pack_first"] = {
+            "type": "boolean",
+            "nullable": False,
+            "required": True,
+        }
         return schema
 
     @property
     def _schema_for_zero_check(self):
         schema = {
             "zone_location": self.schemas._schema_dict_of(self.schemas.location()),
             "picking_type": self.schemas._schema_dict_of(self.schemas.picking_type()),
```

## odoo/addons/shopfloor/static/description/index.html

### odoo/addons/shopfloor/static/description/index.html

```diff
@@ -394,14 +394,22 @@
       <p>
         This module provides REST APIs to support the scenarios. It needs a frontend
 to consume the backend APIs and provide screens for users on barcode devices.
 A default front-end application is provided by
         <tt class="docutils literal">shopfloor_mobile</tt>
         .
       </p>
+      <div class="line-block">
+        <div class="line">Note: if you want to enable a new scenario on an existing application, you must trigger the registry sync on the shopfloor.app in a post_init_hook or a post-migrate script.</div>
+        <div class="line">
+          See an example
+          <a class="reference external" href="https://github.com/OCA/wms/pull/520/commits/bccdfd445a9bc943998c4848f183a076e8459a98">here</a>
+          .
+        </div>
+      </div>
       <p>
         <strong>Table of contents</strong>
       </p>
       <div class="contents local topic" id="contents">
         <ul class="simple">
           <li>
             <a class="reference internal" href="#usage" id="id2">Usage</a>
@@ -554,14 +562,24 @@
               &gt;
             </li>
             <li>
               Jacques-Etienne Baudoux &lt;
               <a class="reference external" href="mailto:je@bcim.be">je@bcim.be</a>
               &gt;
             </li>
+            <li>
+              Juan Miguel Sánchez Arce &lt;
+              <a class="reference external" href="mailto:juan.sanchez@camptocamp.com">juan.sanchez@camptocamp.com</a>
+              &gt;
+            </li>
+            <li>
+              Michael Tietz (MT Software) &lt;
+              <a class="reference external" href="mailto:mtietz@mt-software.de">mtietz@mt-software.de</a>
+              &gt;
+            </li>
           </ul>
         </div>
         <div class="section" id="design">
           <h2>
             <a class="toc-backref" href="#id10">Design</a>
           </h2>
           <ul class="simple">
```

## odoo/addons/shopfloor/tests/__init__.py

```diff
@@ -1,36 +1,43 @@
 from . import test_menu_counters
 from . import test_openapi
 from . import test_actions_change_package_lot
 from . import test_actions_data
 from . import test_actions_data_detail
 from . import test_actions_search
+from . import test_actions_stock
 from . import test_single_pack_transfer
 from . import test_single_pack_transfer_putaway
 from . import test_cluster_picking_base
 from . import test_cluster_picking_batch
 from . import test_cluster_picking_select
 from . import test_cluster_picking_scan_line
+from . import test_cluster_picking_scan_line_location_or_pack_first
+from . import test_cluster_picking_scan_line_no_prefill_qty
 from . import test_cluster_picking_scan_destination
+from . import test_cluster_picking_scan_destination_no_prefill_qty
 from . import test_cluster_picking_is_zero
 from . import test_cluster_picking_skip
 from . import test_cluster_picking_stock_issue
 from . import test_cluster_picking_change_pack_lot
 from . import test_cluster_picking_unload
 from . import test_checkout_base
 from . import test_checkout_scan
 from . import test_checkout_select
 from . import test_checkout_scan_line
+from . import test_checkout_scan_line_no_prefill_qty
 from . import test_checkout_scan_line_base
 from . import test_checkout_select_line
 from . import test_checkout_select_package_base
 from . import test_checkout_set_qty
 from . import test_checkout_scan_package_action
+from . import test_checkout_scan_package_action_no_prefill_qty
 from . import test_checkout_new_package
 from . import test_checkout_no_package
+from . import test_checkout_auto_post
 from . import test_checkout_list_delivery_packaging
 from . import test_checkout_list_package
 from . import test_checkout_summary
 from . import test_checkout_change_packaging
 from . import test_checkout_cancel_line
 from . import test_checkout_done
 from . import test_delivery_base
@@ -41,24 +48,29 @@
 from . import test_delivery_set_qty_done_pack
 from . import test_delivery_set_qty_done_line
 from . import test_delivery_sublocation
 from . import test_delivery_list_stock_picking
 from . import test_delivery_select
 from . import test_location_content_transfer_base
 from . import test_location_content_transfer_start
+from . import test_location_content_transfer_get_work
 from . import test_location_content_transfer_set_destination_all
+from . import test_location_content_transfer_scan_location
 from . import test_location_content_transfer_single
 from . import test_location_content_transfer_set_destination_package_or_line
 from . import test_location_content_transfer_putaway
 from . import test_location_content_transfer_mix
 from . import test_zone_picking_base
 from . import test_zone_picking_start
 from . import test_zone_picking_select_picking_type
 from . import test_zone_picking_select_line
+from . import test_zone_picking_select_line_no_prefill_qty
+from . import test_zone_picking_select_line_first_scan_location
 from . import test_zone_picking_set_line_destination
+from . import test_zone_picking_set_line_destination_no_prefill_qty
 from . import test_zone_picking_set_line_destination_pick_pack
 from . import test_zone_picking_zero_check
 from . import test_zone_picking_stock_issue
 from . import test_zone_picking_change_pack_lot
 from . import test_zone_picking_unload_buffer_lines
 from . import test_zone_picking_unload_single
 from . import test_zone_picking_unload_all
```

## odoo/addons/shopfloor/tests/common.py

```diff
@@ -62,14 +62,15 @@
             cls.env["product.packaging"]
             .sudo()
             .create(
                 {
                     "name": "Box",
                     "product_id": cls.product_a.id,
                     "barcode": "ProductABox",
+                    "qty": 3.0,
                 }
             )
         )
         cls.product_b = (
             cls.env["product.product"]
             .sudo()
             .create(
@@ -110,14 +111,15 @@
             cls.env["product.packaging"]
             .sudo()
             .create(
                 {
                     "name": "Box",
                     "product_id": cls.product_c.id,
                     "barcode": "ProductCBox",
+                    "qty": 3,
                 }
             )
         )
         cls.product_d = (
             cls.env["product.product"]
             .sudo()
             .create(
@@ -139,24 +141,26 @@
                     "product_id": cls.product_d.id,
                     "barcode": "ProductDBox",
                 }
             )
         )
 
     @classmethod
-    def _create_picking(cls, picking_type=None, lines=None, confirm=True):
+    def _create_picking(cls, picking_type=None, lines=None, confirm=True, **kw):
         picking_form = Form(cls.env["stock.picking"])
         picking_form.picking_type_id = picking_type or cls.picking_type
         picking_form.partner_id = cls.customer
         if lines is None:
             lines = [(cls.product_a, 10), (cls.product_b, 10)]
         for product, qty in lines:
             with picking_form.move_ids_without_package.new() as move:
                 move.product_id = product
                 move.product_uom_qty = qty
+        for k, v in kw.items():
+            setattr(picking_form, k, v)
         picking = picking_form.save()
         if confirm:
             picking.action_confirm()
         return picking
 
     @classmethod
     def _update_qty_in_location(
```

## odoo/addons/shopfloor/tests/test_actions_data.py

```diff
@@ -36,25 +36,46 @@
         expected = {
             "id": location.id,
             "name": location.name,
             "barcode": location.name,
         }
         self.assertDictEqual(data, expected)
 
+    def test_data_location_with_operation_progress(self):
+        location = self.stock_location
+        location.sudo().barcode = None
+        data = self.data.location(location, with_operation_progress=True)
+        self.assert_schema(self.schema.location(), data)
+        expected = {
+            "id": location.id,
+            "name": location.name,
+            "barcode": location.name,
+            "operation_progress": {
+                "done": 18.0,
+                "to_do": 165.0,
+            },
+        }
+        self.assertDictEqual(data, expected)
+
     def test_data_lot(self):
         lot = self.env["stock.production.lot"].create(
             {
                 "product_id": self.product_b.id,
                 "company_id": self.env.company.id,
                 "ref": "#FOO",
             }
         )
         data = self.data.lot(lot)
         self.assert_schema(self.schema.lot(), data)
-        expected = {"id": lot.id, "name": lot.name, "ref": "#FOO"}
+        expected = {
+            "id": lot.id,
+            "name": lot.name,
+            "ref": "#FOO",
+            "expiration_date": None,
+        }
         self.assertDictEqual(data, expected)
 
     def test_data_package(self):
         package = self.move_a.move_line_ids.package_id
         package.packaging_id = self.packaging.id
         package.package_storage_type_id = self.storage_type_pallet
         data = self.data.package(package, picking=self.picking, with_packaging=True)
@@ -110,14 +131,38 @@
             "partner": {"id": self.customer.id, "name": self.customer.name},
             "carrier": {"id": carrier.id, "name": carrier.name},
             "ship_carrier": None,
         }
         self.assertEqual(data.pop("scheduled_date").split("T")[0], "2020-08-03")
         self.assertDictEqual(data, expected)
 
+    def test_data_picking_with_progress(self):
+        carrier = self.picking.carrier_id.search([], limit=1)
+        self.picking.write(
+            {"origin": "created by test", "note": "read me", "carrier_id": carrier.id}
+        )
+        data = self.data.picking(self.picking, with_progress=True)
+        self.assert_schema(self.schema.picking(), data)
+        expected = {
+            "id": self.picking.id,
+            "move_line_count": 4,
+            "package_level_count": 2,
+            "bulk_line_count": 2,
+            "name": self.picking.name,
+            "note": "read me",
+            "origin": "created by test",
+            "weight": 110.0,
+            "partner": {"id": self.customer.id, "name": self.customer.name},
+            "carrier": {"id": carrier.id, "name": carrier.name},
+            "ship_carrier": None,
+            "progress": 0.0,
+        }
+        self.assertEqual(data.pop("scheduled_date").split("T")[0], "2020-08-03")
+        self.assertDictEqual(data, expected)
+
     def test_data_product(self):
         (
             self.env["product.packaging"]
             .sudo()
             .create(
                 {
                     "name": "Box 2",
@@ -143,37 +188,39 @@
         move_line = self.move_a.move_line_ids
         result_package = self.env["stock.quant.package"].create(
             {"packaging_id": self.packaging.id}
         )
         move_line.write({"qty_done": 3.0, "result_package_id": result_package.id})
         data = self.data.move_line(move_line)
         self.assert_schema(self.schema.move_line(), data)
+        self.assertIn(self.move_a.state, ["partially_available", "assigned", "done"])
         expected = {
             "id": move_line.id,
             "qty_done": 3.0,
             "quantity": move_line.product_uom_qty,
             "product": self._expected_product(self.product_a),
             "lot": None,
             "package_src": {
                 "id": move_line.package_id.id,
                 "name": move_line.package_id.name,
-                "move_line_count": 1,
+                "move_line_count": 0,
                 "weight": 20.0,
                 "storage_type": None,
             },
             "package_dest": {
                 "id": result_package.id,
                 "name": result_package.name,
-                "move_line_count": 0,
+                "move_line_count": 1,
                 "weight": 6.0,
                 "storage_type": None,
             },
             "location_src": self._expected_location(move_line.location_id),
             "location_dest": self._expected_location(move_line.location_dest_id),
             "priority": "1",
+            "progress": 30.0,
         }
         self.assertDictEqual(data, expected)
 
     def test_data_move_line_lot(self):
         move_line = self.move_b.move_line_ids
         data = self.data.move_line(move_line)
         self.assert_schema(self.schema.move_line(), data)
@@ -182,36 +229,40 @@
             "qty_done": 0.0,
             "quantity": move_line.product_uom_qty,
             "product": self._expected_product(self.product_b),
             "lot": {
                 "id": move_line.lot_id.id,
                 "name": move_line.lot_id.name,
                 "ref": None,
+                "expiration_date": None,
             },
             "package_src": None,
             "package_dest": None,
             "location_src": self._expected_location(move_line.location_id),
             "location_dest": self._expected_location(move_line.location_dest_id),
             "priority": "1",
+            "progress": 0.0,
         }
         self.assertDictEqual(data, expected)
 
     def test_data_move_line_package_lot(self):
         move_line = self.move_c.move_line_ids
         data = self.data.move_line(move_line)
         self.assert_schema(self.schema.move_line(), data)
+        self.assertIn(self.move_a.state, ["partially_available", "assigned", "done"])
         expected = {
             "id": move_line.id,
             "qty_done": 0.0,
             "quantity": move_line.product_uom_qty,
             "product": self._expected_product(self.product_c),
             "lot": {
                 "id": move_line.lot_id.id,
                 "name": move_line.lot_id.name,
                 "ref": None,
+                "expiration_date": None,
             },
             "package_src": {
                 "id": move_line.package_id.id,
                 "name": move_line.package_id.name,
                 "move_line_count": 1,
                 "weight": 30,
                 "storage_type": None,
@@ -222,14 +273,15 @@
                 "move_line_count": 1,
                 "weight": 0,
                 "storage_type": None,
             },
             "location_src": self._expected_location(move_line.location_id),
             "location_dest": self._expected_location(move_line.location_dest_id),
             "priority": "1",
+            "progress": 0.0,
         }
         self.assertDictEqual(data, expected)
 
     def test_data_move_line_raw(self):
         move_line = self.move_d.move_line_ids
         data = self.data.move_line(move_line)
         self.assert_schema(self.schema.move_line(), data)
@@ -240,14 +292,15 @@
             "product": self._expected_product(self.product_d),
             "lot": None,
             "package_src": None,
             "package_dest": None,
             "location_src": self._expected_location(move_line.location_id),
             "location_dest": self._expected_location(move_line.location_dest_id),
             "priority": "1",
+            "progress": 0.0,
         }
         self.assertDictEqual(data, expected)
 
     def test_data_move_line_with_picking(self):
         move_line = self.move_d.move_line_ids
         data = self.data.move_line(move_line, with_picking=True)
         self.assert_schema(self.schema.move_line(with_picking=True), data)
@@ -259,14 +312,15 @@
             "lot": None,
             "package_src": None,
             "package_dest": None,
             "location_src": self._expected_location(move_line.location_id),
             "location_dest": self._expected_location(move_line.location_dest_id),
             "picking": self.data.picking(move_line.picking_id),
             "priority": "1",
+            "progress": 0.0,
         }
         self.assertDictEqual(data, expected)
 
 
 class ActionsDataCaseBatchPicking(ActionsDataCaseBase, PickingBatchMixin):
     @classmethod
     def setUpClassBaseData(cls):
```

## odoo/addons/shopfloor/tests/test_actions_data_detail.py

```diff
@@ -49,14 +49,15 @@
         data = self.data_detail.lot_detail(lot)
         self.assert_schema(self.schema_detail.lot_detail(), data)
 
         expected = {
             "id": lot.id,
             "name": lot.name,
             "ref": "#FOO",
+            "expiration_date": "2020-05-31T00:00:00",
             "product": self._expected_product_detail(self.product_b, full=True),
         }
         # ignore time and TZ, we don't care here
         self.assertEqual(data.pop("removal_date").split("T")[0], "2020-05-20")
         self.assertEqual(data.pop("expire_date").split("T")[0], "2020-05-31")
         self.assertDictEqual(data, expected)
 
@@ -124,14 +125,52 @@
             },
             "move_lines": self.data_detail.move_lines(picking.move_line_ids),
             "picking_type_code": "outgoing",
         }
         self.assertEqual(data.pop("scheduled_date").split("T")[0], "2020-05-13")
         self.assertDictEqual(data, expected)
 
+    def test_data_picking_with_progress(self):
+        picking = self.picking
+        carrier = picking.carrier_id.search([], limit=1)
+        picking.write(
+            {
+                "origin": "created by test",
+                "note": "read me",
+                "priority": "1",
+                "carrier_id": carrier.id,
+            }
+        )
+        picking.move_lines.write({"date": "2020-05-13"})
+        data = self.data_detail.picking_detail(picking, with_progress=True)
+        self.assert_schema(self.schema_detail.picking_detail(), data)
+        expected = {
+            "id": picking.id,
+            "move_line_count": 4,
+            "package_level_count": 2,
+            "bulk_line_count": 2,
+            "name": picking.name,
+            "note": "read me",
+            "origin": "created by test",
+            "ship_carrier": None,
+            "weight": 110.0,
+            "partner": {"id": self.customer.id, "name": self.customer.name},
+            "carrier": {"id": picking.carrier_id.id, "name": picking.carrier_id.name},
+            "priority": "Urgent",
+            "operation_type": {
+                "id": picking.picking_type_id.id,
+                "name": picking.picking_type_id.name,
+            },
+            "move_lines": self.data_detail.move_lines(picking.move_line_ids),
+            "picking_type_code": "outgoing",
+            "progress": 0.0,
+        }
+        self.assertEqual(data.pop("scheduled_date").split("T")[0], "2020-05-13")
+        self.assertDictEqual(data, expected)
+
     def test_data_move_line_package(self):
         move_line = self.move_a.move_line_ids
         result_package = self.env["stock.quant.package"].create(
             {"packaging_id": self.packaging.id}
         )
         move_line.write({"qty_done": 3.0, "result_package_id": result_package.id})
         data = self.data_detail.move_line(move_line)
@@ -142,28 +181,29 @@
             "qty_done": 3.0,
             "quantity": move_line.product_uom_qty,
             "product": self._expected_product_detail(product),
             "lot": None,
             "package_src": {
                 "id": move_line.package_id.id,
                 "name": move_line.package_id.name,
-                "move_line_count": 1,
+                "move_line_count": 0,
                 "weight": 20.0,
                 "storage_type": None,
             },
             "package_dest": {
                 "id": result_package.id,
                 "name": result_package.name,
-                "move_line_count": 0,
+                "move_line_count": 1,
                 "weight": 6.0,
                 "storage_type": None,
             },
             "location_src": self._expected_location(move_line.location_id),
             "location_dest": self._expected_location(move_line.location_dest_id),
             "priority": "1",
+            "progress": 30.0,
         }
         self.assertDictEqual(data, expected)
 
     def test_data_move_line_lot(self):
         move_line = self.move_b.move_line_ids
         data = self.data_detail.move_line(move_line)
         self.assert_schema(self.schema_detail.move_line(), data)
@@ -173,20 +213,22 @@
             "qty_done": 0.0,
             "quantity": move_line.product_uom_qty,
             "product": self._expected_product_detail(product),
             "lot": {
                 "id": move_line.lot_id.id,
                 "name": move_line.lot_id.name,
                 "ref": None,
+                "expiration_date": None,
             },
             "package_src": None,
             "package_dest": None,
             "location_src": self._expected_location(move_line.location_id),
             "location_dest": self._expected_location(move_line.location_dest_id),
             "priority": "1",
+            "progress": 0.0,
         }
         self.assertDictEqual(data, expected)
 
     def test_data_move_line_package_lot(self):
         move_line = self.move_c.move_line_ids
         data = self.data_detail.move_line(move_line)
         self.assert_schema(self.schema_detail.move_line(), data)
@@ -196,14 +238,15 @@
             "qty_done": 0.0,
             "quantity": move_line.product_uom_qty,
             "product": self._expected_product_detail(product),
             "lot": {
                 "id": move_line.lot_id.id,
                 "name": move_line.lot_id.name,
                 "ref": None,
+                "expiration_date": None,
             },
             "package_src": {
                 "id": move_line.package_id.id,
                 "name": move_line.package_id.name,
                 "move_line_count": 1,
                 "weight": 30.0,
                 "storage_type": None,
@@ -214,14 +257,15 @@
                 "move_line_count": 1,
                 "weight": 0.0,
                 "storage_type": None,
             },
             "location_src": self._expected_location(move_line.location_id),
             "location_dest": self._expected_location(move_line.location_dest_id),
             "priority": "1",
+            "progress": 0.0,
         }
         self.assertDictEqual(data, expected)
 
     def test_data_move_line_raw(self):
         move_line = self.move_d.move_line_ids
         data = self.data_detail.move_line(move_line)
         self.assert_schema(self.schema_detail.move_line(), data)
@@ -233,14 +277,15 @@
             "product": self._expected_product_detail(product),
             "lot": None,
             "package_src": None,
             "package_dest": None,
             "location_src": self._expected_location(move_line.location_id),
             "location_dest": self._expected_location(move_line.location_dest_id),
             "priority": "1",
+            "progress": 0.0,
         }
         self.assertDictEqual(data, expected)
 
     def test_product(self):
         move_line = self.move_b.move_line_ids
         product = move_line.product_id.with_context(location=move_line.location_id.id)
         Partner = self.env["res.partner"].sudo()
```

## odoo/addons/shopfloor/tests/test_actions_search.py

```diff
@@ -46,16 +46,17 @@
 
     def test_search_product(self):
         rec = self.product_a
         handler = self.search.product_from_scan
         self.assertEqual(handler(rec.barcode), rec)
         self.assertEqual(handler(False), rec.browse())
         self.assertEqual(handler("NONE"), rec.browse())
+        # It is not possible to search a product by packaging
         packaging = self.product_a_packaging
-        self.assertEqual(handler(packaging.barcode), rec)
+        self.assertFalse(handler(packaging.barcode))
 
     def test_search_lot_number_unique(self):
         rec = (
             self.env["stock.production.lot"]
             .sudo()
             .create(
                 {"product_id": self.product_a.id, "company_id": self.env.company.id}
@@ -96,7 +97,156 @@
             .sudo()
             .create({"name": "TEST PKG", "barcode": "1234"})
         )
         handler = self.search.generic_packaging_from_scan
         self.assertEqual(handler(rec.barcode), rec)
         self.assertEqual(handler(False), rec.browse())
         self.assertEqual(handler("NONE"), rec.browse())
+
+
+class TestFindCase(TestSearchBaseCase):
+    def test_find_api(self):
+        self.assertEqual(self.search.find(False).record, None)
+        self.assertEqual(self.search.find("NONE").record, None)
+        self.assertEqual(self.search.find("foo", types=("not_existing",)).record, None)
+        # TODO: test SearchResult class
+
+    def test_find_location(self):
+        rec = self.customer_location
+        res = self.search.find(rec.barcode, types=("location",))
+        self.assertEqual(res.record, rec)
+        res = self.search.find(rec.name, types=("location",))
+        self.assertEqual(res.record, rec)
+
+    def test_find_location_with_limit(self):
+        rec = self.customer_location
+        rec2 = self.customer_location.sudo().copy({"barcode": "CUSTOMERS2"})
+        res = self.search.find("Customers", types=("location",))
+        self.assertEqual(res.records, None)
+        res = self.search.find(
+            "Customers", types=("location",), handler_kw=dict(location=dict(limit=2))
+        )
+        self.assertEqual(res.records, rec + rec2)
+
+    def test_find_package(self):
+        rec = self.env["stock.quant.package"].sudo().create({"name": "1234"})
+        res = self.search.find(rec.name, types=("package",))
+        self.assertEqual(res.record, rec)
+
+    def test_find_picking(self):
+        ptype = self.env.ref("shopfloor.picking_type_single_pallet_transfer_demo")
+        rec = self._create_picking(picking_type=ptype)
+        res = self.search.find(rec.name, types=("picking",))
+        self.assertEqual(res.record, rec)
+
+    def test_find_product(self):
+        rec = self.product_a
+        res = self.search.find(rec.barcode, types=("product",))
+        self.assertEqual(res.record, rec)
+        # It is not possible to search a product by packaging
+        packaging = self.product_a_packaging
+        res = self.search.find(packaging.barcode, types=("product",))
+        self.assertEqual(res.record, None)
+
+    def test_find_product_packaging(self):
+        rec = self.product_a_packaging
+        res = self.search.find(rec.barcode, types=("packaging",))
+        self.assertEqual(res.record, rec)
+
+    def test_find_lot_number_unique(self):
+        rec = (
+            self.env["stock.production.lot"]
+            .sudo()
+            .create(
+                {"product_id": self.product_a.id, "company_id": self.env.company.id}
+            )
+        )
+        res = self.search.find(
+            rec.name, types=("lot",), handler_kw=dict(lot=dict(products=self.product_a))
+        )
+        self.assertEqual(res.record, rec)
+
+    def test_find_lot_number_shared_with_multiple_products(self):
+        lot_model = self.env["stock.production.lot"].sudo()
+        lots = (
+            lot_model.create(
+                {
+                    "name": "TEST",
+                    "product_id": self.product_a.id,
+                    "company_id": self.env.company.id,
+                }
+            ),
+            lot_model.create(
+                {
+                    "name": "TEST",
+                    "product_id": self.product_b.id,
+                    "company_id": self.env.company.id,
+                }
+            ),
+        )
+        res = self.search.find(
+            lots[0].name,
+            types=("lot",),
+            handler_kw=dict(lot=dict(products=self.product_a)),
+        )
+        self.assertEqual(res.record, lots[0])
+        res = self.search.find(
+            lots[1].name,
+            types=("lot",),
+            handler_kw=dict(lot=dict(products=self.product_a)),
+        )
+        self.assertEqual(res.record, lots[0])
+        res = self.search.find(
+            lots[0].name,
+            types=("lot",),
+            handler_kw=dict(lot=dict(products=self.product_b)),
+        )
+        self.assertEqual(res.record, lots[1])
+        res = self.search.find(
+            lots[1].name,
+            types=("lot",),
+            handler_kw=dict(lot=dict(products=self.product_b)),
+        )
+        self.assertEqual(res.record, lots[1])
+
+    def test_find_generic_packaging(self):
+        rec = (
+            self.env["product.packaging"]
+            .sudo()
+            .create({"name": "TEST PKG", "barcode": "1234"})
+        )
+        res = self.search.find(rec.barcode, types=("delivery_packaging",))
+        self.assertEqual(res.record, rec)
+
+    def test_find_chain(self):
+        prod = self.product_a
+        # prod last type -> found
+        res = self.search.find(
+            prod.barcode,
+            types=(
+                "location",
+                "lot",
+                "product",
+            ),
+        )
+        self.assertEqual(res.record, prod)
+        loc = self.customer_location.sudo().copy({"barcode": prod.barcode})
+        # prod last type but a location w/ the same name exists -> location found
+        res = self.search.find(
+            prod.barcode,
+            types=(
+                "location",
+                "lot",
+                "product",
+            ),
+        )
+        self.assertEqual(res.record, loc)
+        # change types order -> prod found
+        res = self.search.find(
+            prod.barcode,
+            types=(
+                "product",
+                "location",
+                "lot",
+            ),
+        )
+        self.assertEqual(res.record, prod)
```

## odoo/addons/shopfloor/tests/test_checkout_base.py

```diff
@@ -34,7 +34,36 @@
         return self.data.move_line(move_line)
 
     def _package_data(self, package, picking):
         return self.data.package(package, picking=picking, with_packaging=True)
 
     def _packaging_data(self, packaging):
         return self.data.packaging(packaging)
+
+    def _data_for_select_line(self, picking, **kw):
+        data = {
+            "picking": self._stock_picking_data(picking),
+            "group_lines_by_location": True,
+            "show_oneline_package_content": False,
+            "need_confirm_pack_all": False,
+        }
+        data.update(kw)
+        return data
+
+    def _assert_select_package_qty_above(self, response, picking):
+        self.assert_response(
+            response,
+            next_state="select_package",
+            data={
+                "selected_move_lines": [
+                    self._move_line_data(ml) for ml in picking.move_line_ids.sorted()
+                ],
+                "picking": self._picking_summary_data(picking),
+                "packing_info": "",
+                "no_package_enabled": True,
+            },
+            message={
+                "message_type": "warning",
+                "body": "The quantity scanned for one or more lines cannot be "
+                "higher than the maximum allowed.",
+            },
+        )
```

## odoo/addons/shopfloor/tests/test_checkout_cancel_line.py

```diff
@@ -83,15 +83,15 @@
                 },
             ],
         )
 
         self.assert_response(
             response,
             next_state="select_line",
-            data={"picking": self._stock_picking_data(picking)},
+            data=self._data_for_select_line(picking),
             message={"body": "Package cancelled", "message_type": "success"},
         )
 
     def test_cancel_line_ok(self):
         picking = self.picking
 
         raw_line = self.raw_move.move_line_ids
@@ -108,15 +108,15 @@
             raw_line,
             [{"qty_done": 0, "shopfloor_checkout_done": False}],
         )
 
         self.assert_response(
             response,
             next_state="select_line",
-            data={"picking": self._stock_picking_data(picking)},
+            data=self._data_for_select_line(picking),
             message={"body": "Line cancelled", "message_type": "success"},
         )
 
     def test_cancel_line_error_package_not_found(self):
         # and now, we want to drop the new_package
         response = self.service.dispatch(
             "cancel_line", params={"picking_id": self.picking.id, "package_id": 0}
```

## odoo/addons/shopfloor/tests/test_checkout_done.py

```diff
@@ -48,21 +48,24 @@
             response,
             next_state="confirm_done",
             data={"picking": self._stock_picking_data(self.picking, done=True)},
             message=self.service.msg_store.transfer_confirm_done(),
         )
 
     def test_done_partial_confirm(self):
-        # line is done
+        # lines are done
         response = self.service.dispatch(
             "done", params={"picking_id": self.picking.id, "confirmation": True}
         )
-
+        # as they are all the lines that relate to the picking, they didn't have
+        # been extracted in a separate transfer. An usual backorder has been
+        # created for the unprocessed qty.
         self.assertRecordValues(self.picking, [{"state": "done"}])
         self.assertTrue(self.picking.backorder_ids)
+        self.assertEqual(self.picking.backorder_ids.move_line_ids.product_uom_qty, 8)
 
         self.assert_response(
             response,
             next_state="select_document",
             message=self.service.msg_store.transfer_done_success(self.picking),
         )
 
@@ -106,18 +109,24 @@
 
     def test_done_partial_confirm(self):
         # line is done
         response = self.service.dispatch(
             "done", params={"picking_id": self.picking.id, "confirmation": True}
         )
 
-        self.assertRecordValues(self.picking, [{"state": "done", "backorder_ids": []}])
+        # it has been extracted in its own picking, the current one staying open
+        picking_done = self.line1.picking_id
+        self.assertRecordValues(picking_done, [{"state": "done", "backorder_ids": []}])
+        self.assertRecordValues(
+            self.picking, [{"state": "assigned", "backorder_ids": [picking_done.id]}]
+        )
         self.assertRecordValues(
             self.line1 + self.line2,
             [{"result_package_id": self.package.id}, {"result_package_id": False}],
         )
+        self.assertIn(self.line2, self.picking.move_line_ids)
 
         self.assert_response(
             response,
             next_state="select_document",
-            message=self.service.msg_store.transfer_done_success(self.picking),
+            message=self.service.msg_store.transfer_done_success(picking_done),
         )
```

## odoo/addons/shopfloor/tests/test_checkout_list_package.py

```diff
@@ -1,9 +1,11 @@
 # Copyright 2020 Camptocamp SA (http://www.camptocamp.com)
 # License AGPL-3.0 or later (http://www.gnu.org/licenses/agpl.html).
+from odoo import fields
+
 from .test_checkout_base import CheckoutCommonCase
 from .test_checkout_select_package_base import CheckoutSelectPackageMixin
 
 
 class SelectDestPackageMixin:
     def _assert_response_select_dest_package(
         self, response, picking, selected_lines, packages, message=None
@@ -159,15 +161,15 @@
                 {"result_package_id": self.pack1.id, "shopfloor_checkout_done": False},
             ],
         )
         self.assert_response(
             response,
             # go pack to the screen to select lines to put in packages
             next_state="select_line",
-            data={"picking": self._stock_picking_data(self.picking)},
+            data=self._data_for_select_line(self.picking),
             message=self.msg_store.goods_packed_in(self.delivery_package),
         )
 
     def test_scan_dest_package_ok(self):
         response = self.service.dispatch(
             "scan_dest_package",
             params={
@@ -222,14 +224,60 @@
                 "picking_id": self.picking.id,
                 "selected_line_ids": self.selected_lines.ids,
                 "package_id": self.delivery_package.id,
             },
         )
         self._assert_package_set(response)
 
+    def test_set_dest_package_ok_on_partial_qty_done(self):
+        # Partially process line three 3 quantiy out of 10
+        self.move_line3.qty_done = 3
+        response = self.service.dispatch(
+            "set_dest_package",
+            params={
+                "picking_id": self.picking.id,
+                "selected_line_ids": self.selected_lines.ids,
+                "package_id": self.delivery_package.id,
+            },
+        )
+        # self._assert_package_set(response)
+        self.assertRecordValues(
+            self.move_line1 + self.move_line2 + self.move_line3,
+            [
+                {
+                    "result_package_id": self.delivery_package.id,
+                    "shopfloor_checkout_done": True,
+                },
+                {
+                    "result_package_id": self.delivery_package.id,
+                    "shopfloor_checkout_done": True,
+                },
+                # Line 3 has been split
+                {
+                    "result_package_id": self.delivery_package.id,
+                    "shopfloor_checkout_done": True,
+                    "product_uom_qty": 3,
+                    "qty_done": 3,
+                },
+            ],
+        )
+        # Left quantity to do from line 3
+        new_move_line = self.picking.move_line_ids.filtered(
+            lambda line: line.qty_done == 0 and line.product_uom_qty == 7
+        )
+        self.assertTrue(new_move_line)
+        self.assertFalse(new_move_line.shopfloor_checkout_done)
+        self.assert_response(
+            response,
+            # go pack to the screen to select lines to put in packages
+            next_state="select_line",
+            data=self._data_for_select_line(self.picking),
+            message=self.msg_store.goods_packed_in(self.delivery_package),
+        )
+
     def test_set_dest_package_error_not_found(self):
         response = self.service.dispatch(
             "set_dest_package",
             params={
                 "picking_id": self.picking.id,
                 "selected_line_ids": self.selected_lines.ids,
                 "package_id": 0,
@@ -256,7 +304,22 @@
         self._assert_response_select_dest_package(
             response,
             self.picking,
             self.selected_lines,
             self._get_allowed_packages(self.picking),
             message=self.service.msg_store.dest_package_not_valid(package),
         )
+
+    def test_set_dest_package_error_qty_done_above(self):
+        # If the qty_done of a selected line goes beyond
+        # the maximum allowed, a message should be displayed
+        # and the user shouldn't be allowed to select a package.
+        line = fields.first(self.picking.move_line_ids)
+        line.qty_done = line.product_uom_qty + 1
+        response = self.service.dispatch(
+            "list_dest_package",
+            params={
+                "picking_id": self.picking.id,
+                "selected_line_ids": self.picking.move_line_ids.ids,
+            },
+        )
+        self._assert_select_package_qty_above(response, self.picking)
```

## odoo/addons/shopfloor/tests/test_checkout_new_package.py

```diff
@@ -1,9 +1,11 @@
 # Copyright 2020 Camptocamp SA (http://www.camptocamp.com)
 # License AGPL-3.0 or later (http://www.gnu.org/licenses/agpl.html).
+from odoo import fields
+
 from .test_checkout_base import CheckoutCommonCase
 from .test_checkout_select_package_base import CheckoutSelectPackageMixin
 
 
 class CheckoutNewPackageCase(CheckoutCommonCase, CheckoutSelectPackageMixin):
     def test_new_package_ok(self):
         picking = self._create_picking(
@@ -52,10 +54,35 @@
             # the same package
             [{"result_package_id": pack1.id, "shopfloor_checkout_done": False}],
         )
         self.assert_response(
             response,
             # go pack to the screen to select lines to put in packages
             next_state="select_line",
-            data={"picking": self._stock_picking_data(picking)},
+            data=self._data_for_select_line(picking),
             message=self.msg_store.goods_packed_in(new_package),
         )
+
+    def test_set_dest_package_error_qty_done_above(self):
+        picking = self._create_picking(
+            lines=[
+                (self.product_a, 10),
+                (self.product_b, 10),
+            ]
+        )
+        moves = picking.move_lines
+        self._fill_stock_for_moves(moves, in_package=True)
+        picking.action_assign()
+        # If the qty_done of a selected line goes beyond
+        # the maximum allowed, a message should be displayed
+        # and the user shouldn't be allowed to select a package.
+        selected_lines = moves.move_line_ids
+        line = fields.first(selected_lines)
+        line.qty_done = line.product_uom_qty + 1
+        response = self.service.dispatch(
+            "list_dest_package",
+            params={
+                "picking_id": picking.id,
+                "selected_line_ids": picking.move_line_ids.ids,
+            },
+        )
+        self._assert_select_package_qty_above(response, picking)
```

## odoo/addons/shopfloor/tests/test_checkout_no_package.py

```diff
@@ -1,11 +1,13 @@
 # Copyright 2020 Camptocamp SA (http://www.camptocamp.com)
 # License AGPL-3.0 or later (http://www.gnu.org/licenses/agpl.html).
 import werkzeug
 
+from odoo import fields
+
 from .test_checkout_base import CheckoutCommonCase
 from .test_checkout_select_package_base import CheckoutSelectPackageMixin
 
 
 class CheckoutNoPackageCase(CheckoutCommonCase, CheckoutSelectPackageMixin):
     @classmethod
     def setUpClassBaseData(cls):
@@ -53,15 +55,15 @@
             move_line3,
             [{"result_package_id": False, "shopfloor_checkout_done": False}],
         )
         self.assert_response(
             response,
             # go pack to the screen to select lines to put in packages
             next_state="select_line",
-            data={"picking": self._stock_picking_data(self.picking)},
+            data=self._data_for_select_line(self.picking),
             message={
                 "message_type": "success",
                 "body": "Product(s) processed as raw product(s)",
             },
         )
 
     def test_no_package_disabled(self):
@@ -71,7 +73,22 @@
                 "no_package",
                 params={
                     "picking_id": self.picking.id,
                     "selected_line_ids": self.pack1_moves.move_line_ids.ids,
                 },
             )
             self.assertEqual(err.name, "`checkout.no_package` endpoint is not enabled")
+
+    def test_set_dest_package_error_qty_done_above(self):
+        # If the qty_done of a selected line goes beyond
+        # the maximum allowed, a message should be displayed
+        # and the user shouldn't be allowed to select a package.
+        line = fields.first(self.picking.move_line_ids)
+        line.qty_done = line.product_uom_qty + 1
+        response = self.service.dispatch(
+            "list_dest_package",
+            params={
+                "picking_id": self.picking.id,
+                "selected_line_ids": self.picking.move_line_ids.ids,
+            },
+        )
+        self._assert_select_package_qty_above(response, self.picking)
```

## odoo/addons/shopfloor/tests/test_checkout_scan.py

```diff
@@ -9,15 +9,15 @@
         self._fill_stock_for_moves(picking.move_lines, in_package=in_package)
         picking.action_assign()
         barcode = barcode_func(picking)
         response = self.service.dispatch("scan_document", params={"barcode": barcode})
         self.assert_response(
             response,
             next_state="select_line",
-            data={"picking": self._stock_picking_data(picking)},
+            data=self._data_for_select_line(picking),
         )
 
     def test_scan_document_stock_picking_ok(self):
         self._test_scan_ok(lambda picking: picking.name)
 
     def test_scan_document_location_ok(self):
         self._test_scan_ok(lambda picking: picking.move_line_ids.location_id.barcode)
```

## odoo/addons/shopfloor/tests/test_checkout_scan_line.py

```diff
@@ -1,13 +1,27 @@
 # Copyright 2020 Camptocamp SA (http://www.camptocamp.com)
 # License AGPL-3.0 or later (http://www.gnu.org/licenses/agpl.html).
 from .test_checkout_scan_line_base import CheckoutScanLineCaseBase
 
 
 class CheckoutScanLineCase(CheckoutScanLineCaseBase):
+    @classmethod
+    def setUpClassBaseData(cls, *args, **kwargs):
+        super().setUpClassBaseData(*args, **kwargs)
+        cls.delivery_packaging = (
+            cls.env["product.packaging"]
+            .sudo()
+            .create(
+                {
+                    "name": "DelivBox",
+                    "barcode": "DelivBox",
+                }
+            )
+        )
+
     def test_scan_line_package_ok(self):
         picking = self._create_picking(
             lines=[(self.product_a, 10), (self.product_b, 10)]
         )
         move1 = picking.move_lines[0]
         move2 = picking.move_lines[1]
         # put the lines in 2 separate packages (only the first line should be selected
@@ -45,46 +59,59 @@
     def test_scan_line_product_ok(self):
         picking = self._create_picking(
             lines=[(self.product_a, 10), (self.product_b, 10)]
         )
         # do not put them in a package, we'll pack units here
         self._fill_stock_for_moves(picking.move_lines)
         picking.action_assign()
+        # The product a is scanned, so selected and quantity updated
         line_a = picking.move_line_ids.filtered(
             lambda l: l.product_id == self.product_a
         )
-        # we have 2 different products in the picking, we scan the first
-        # one and expect to select the line
-        self._test_scan_line_ok(self.product_a.barcode, line_a)
+        # Because not part of a package other lines are selected also
+        related_lines = picking.move_line_ids - line_a
+        selected_lines = picking.move_line_ids
+        self._test_scan_line_ok(
+            self.product_a.barcode, selected_lines, related_lines=related_lines
+        )
 
     def test_scan_line_product_several_lines_ok(self):
         picking = self._create_picking(
             lines=[(self.product_a, 10), (self.product_a, 10), (self.product_b, 10)]
         )
         self._fill_stock_for_moves(picking.move_lines)
         picking.action_assign()
+        # The product a is scanned, so selected and quantity updated
         lines_a = picking.move_line_ids.filtered(
             lambda l: l.product_id == self.product_a
         )
-        # expect to select all the lines with the scanned product, as long
-        # as they are in the same package
-        self._test_scan_line_ok(self.product_a.barcode, lines_a)
+        # Because not part of a package other lines are selected also
+        related_lines = picking.move_line_ids - lines_a
+        selected_lines = picking.move_line_ids
+        self._test_scan_line_ok(
+            self.product_a.barcode, selected_lines, related_lines=related_lines
+        )
 
     def test_scan_line_product_packaging_ok(self):
         picking = self._create_picking(
             lines=[(self.product_a, 10), (self.product_a, 10), (self.product_b, 10)]
         )
         self._fill_stock_for_moves(picking.move_lines)
         picking.action_assign()
         lines_a = picking.move_line_ids.filtered(
             lambda l: l.product_id == self.product_a
         )
         # when we scan the packaging of the product, we should select the
         # lines as if the product was scanned
-        self._test_scan_line_ok(self.product_a_packaging.barcode, lines_a)
+        # Because not part of a package other lines are selected also
+        related_lines = picking.move_line_ids - lines_a
+        selected_lines = picking.move_line_ids
+        self._test_scan_line_ok(
+            self.product_a_packaging.barcode, selected_lines, related_lines
+        )
 
     def test_scan_line_product_lot_ok(self):
         picking = self._create_picking(
             lines=[(self.product_a, 1), (self.product_a, 1), (self.product_b, 1)]
         )
         for move in picking.move_lines:
             self._fill_stock_for_moves(move, in_lot=True)
@@ -113,15 +140,15 @@
         """
         response = self.service.dispatch(
             "scan_line", params={"picking_id": picking.id, "barcode": barcode}
         )
         self.assert_response(
             response,
             next_state="select_line",
-            data={"picking": self._stock_picking_data(picking)},
+            data=self._data_for_select_line(picking),
             message=message,
         )
 
     def test_scan_line_error_barcode_not_found(self):
         picking = self._create_picking(lines=[(self.product_a, 10)])
         self._fill_stock_for_moves(picking.move_lines, in_package=True)
         picking.action_assign()
@@ -299,7 +326,51 @@
             response,
             next_state="summary",
             data={
                 "picking": self._stock_picking_data(picking, done=True),
                 "all_processed": True,
             },
         )
+
+    def test_scan_line_delivery_package_ok(self):
+        picking = self._create_picking(
+            lines=[(self.product_a, 10), (self.product_b, 10)]
+        )
+        move1 = picking.move_lines[0]
+        move2 = picking.move_lines[1]
+        # put the lines in 2 separate packages (only the first line should be selected
+        # by the package barcode)
+        self._fill_stock_for_moves(move1, in_package=True)
+        self._fill_stock_for_moves(move2, in_package=True)
+        picking.action_assign()
+        result_pkgs = picking.move_line_ids.result_package_id
+        response = self.service.dispatch(
+            "scan_line",
+            params={
+                "picking_id": picking.id,
+                "barcode": self.delivery_packaging.barcode,
+            },
+        )
+        # back to same state
+        self.assertEqual(response["next_state"], "select_line")
+        self.assertEqual(
+            response["message"],
+            self.msg_store.confirm_put_all_goods_in_delivery_package(
+                self.delivery_packaging
+            ),
+        )
+        self.assertTrue(response["data"]["select_line"]["need_confirm_pack_all"])
+        response = self.service.dispatch(
+            "scan_line",
+            params={
+                "picking_id": picking.id,
+                "barcode": self.delivery_packaging.barcode,
+                "confirm_pack_all": True,
+            },
+        )
+        # move to summary as all lines are done
+        self.assertEqual(response["next_state"], "summary")
+        self.assertTrue(response["message"]["body"].startswith("Goods packed into "))
+        self.assertNotEqual(
+            result_pkgs.sorted("id"),
+            picking.move_line_ids.result_package_id.sorted("id"),
+        )
```

## odoo/addons/shopfloor/tests/test_checkout_scan_line_base.py

```diff
@@ -1,18 +1,25 @@
 # Copyright 2021 Camptocamp SA (https://www.camptocamp.com)
 # License AGPL-3.0 or later (https://www.gnu.org/licenses/agpl.html)
 from .test_checkout_base import CheckoutCommonCase
 from .test_checkout_select_package_base import CheckoutSelectPackageMixin
 
 
 class CheckoutScanLineCaseBase(CheckoutCommonCase, CheckoutSelectPackageMixin):
-    def _test_scan_line_ok(self, barcode, selected_lines, packing_info=""):
+    def _test_scan_line_ok(
+        self, barcode, selected_lines, related_lines=None, packing_info=""
+    ):
         """Test /scan_line with a valid return
 
         :param barcode: the barcode we scan
         :selected_lines: expected move lines returned by the endpoint
         """
         picking = selected_lines.mapped("picking_id")
         response = self.service.dispatch(
             "scan_line", params={"picking_id": picking.id, "barcode": barcode}
         )
-        self._assert_selected(response, selected_lines, packing_info=packing_info)
+        self._assert_selected(
+            response,
+            selected_lines,
+            related_lines=related_lines,
+            packing_info=packing_info,
+        )
```

## odoo/addons/shopfloor/tests/test_checkout_scan_package_action.py

```diff
@@ -355,15 +355,15 @@
             # qty_done was zero so we don't set it as packed and it remains in
             # the same package
             [{"result_package_id": pack1.id, "shopfloor_checkout_done": False}],
         )
         self.assert_response(
             response,
             next_state="select_line",
-            data={"picking": self._stock_picking_data(picking)},
+            data=self._data_for_select_line(picking),
             message=self.msg_store.goods_packed_in(new_package),
         )
 
     def test_scan_package_action_scan_packaging_bad_carrier(self):
         picking = self._create_picking(lines=[(self.product_a, 10)])
         picking.carrier_id = picking.carrier_id.search([], limit=1)
         pack1_moves = picking.move_lines
```

## odoo/addons/shopfloor/tests/test_checkout_select.py

```diff
@@ -36,15 +36,15 @@
     def test_select_ok(self):
         response = self.service.dispatch(
             "select", params={"picking_id": self.picking.id}
         )
         self.assert_response(
             response,
             next_state="select_line",
-            data={"picking": self._stock_picking_data(self.picking)},
+            data=self._data_for_select_line(self.picking),
         )
 
     def _test_error(self, picking, msg):
         response = self.service.dispatch("select", params={"picking_id": picking.id})
         self.assert_response(
             response,
             next_state="manual_selection",
```

## odoo/addons/shopfloor/tests/test_checkout_select_line.py

```diff
@@ -75,15 +75,15 @@
         :param params: params sent to /select_line
         :param message: the dict of expected error message
         """
         response = self.service.dispatch("select_line", params=params)
         self.assert_response(
             response,
             next_state="select_line",
-            data={"picking": self._stock_picking_data(self.picking)},
+            data=self._data_for_select_line(self.picking),
             message=message,
         )
 
     def test_select_line_package_error_not_found(self):
         selected_lines = self.move_single.move_line_ids
         selected_lines.unlink()
         self._test_select_line_error(
```

## odoo/addons/shopfloor/tests/test_checkout_select_package_base.py

```diff
@@ -43,19 +43,22 @@
             self.assertEqual(line.qty_done, quantity)
         for line in deselected_lines:
             self.assertEqual(line.qty_done, 0, "Lines deselected must have no qty done")
         self._assert_selected_response(
             response, selected_lines, message=message, packing_info=packing_info
         )
 
-    def _assert_selected(self, response, selected_lines, message=None, **kw):
+    def _assert_selected(
+        self, response, selected_lines, related_lines=None, message=None, **kw
+    ):
+        related_lines = related_lines or self.env["stock.move.line"]
         picking = selected_lines.mapped("picking_id")
         unselected_lines = picking.move_line_ids - selected_lines
-        for line in selected_lines:
+        for line in selected_lines - related_lines:
             self.assertEqual(
                 line.qty_done,
                 line.product_uom_qty,
                 "Scanned lines must have their qty done set to the reserved quantity",
             )
-        for line in unselected_lines:
+        for line in unselected_lines + related_lines:
             self.assertEqual(line.qty_done, 0)
         self._assert_selected_response(response, selected_lines, message=message, **kw)
```

## odoo/addons/shopfloor/tests/test_checkout_set_qty.py

```diff
@@ -188,18 +188,18 @@
                 "move_line_id": line1.id,
                 "qty_done": line1.product_uom_qty + 1,
             },
         )
         self._assert_selected_qties(
             response,
             selected_lines,
-            {line1: line1.product_uom_qty, line2: line2.product_uom_qty},
+            {line1: line1.product_uom_qty + 1, line2: line2.product_uom_qty},
             message={
-                "body": "Not allowed to pack more than the quantity, "
-                "the value has been changed to the maximum.",
+                "body": "Please note that the scanned quantity "
+                "is higher than the maximum allowed.",
                 "message_type": "warning",
             },
         )
 
     def test_set_custom_qty_negative(self):
         selected_lines = self.moves_pack1.move_line_ids
         line1 = selected_lines[0]
@@ -236,20 +236,20 @@
                 "selected_line_ids": selected_lines.ids,
                 "move_line_id": line_to_change.id,
                 "qty_done": new_qty,
             },
         )
         self.assertEqual(line_to_change.qty_done, new_qty)
         self.assertEqual(line_keep_qty.qty_done, line_keep_qty.product_uom_qty)
-        new_line = [
+        new_lines = [
             x for x in self.moves_pack1.move_line_ids if x not in selected_lines
-        ][0]
-        self.assertEqual(new_line.product_uom_qty, 1.0)
+        ]
+        # Lines are not being split anymore
+        self.assertFalse(new_lines)
         self._assert_selected_qties(
             response,
             self.moves_pack1.move_line_ids,
             {
                 line_to_change: new_qty,
                 line_keep_qty: line_keep_qty.product_uom_qty,
-                new_line: 0.0,
             },
         )
```

## odoo/addons/shopfloor/tests/test_cluster_picking_base.py

```diff
@@ -20,29 +20,33 @@
 
     def setUp(self):
         super().setUp()
         self.service = self.get_service(
             "cluster_picking", menu=self.menu, profile=self.profile
         )
 
-    def _line_data(self, move_line, qty=None, package_dest=False):
+    def _line_data(self, move_line, qty=None, package_dest=False, qty_done=None, **kw):
         picking = move_line.picking_id
         # A package exists on the move line, because the quant created
         # by ``_simulate_batch_selected`` has a package.
         data = self.data.move_line(move_line)
         if not package_dest:
             data["package_dest"] = None
         if qty:
             data["quantity"] = qty
+        if qty_done:
+            data["qty_done"] = qty_done
         data.update(
             {
                 "batch": self.data.picking_batch(picking.batch_id),
                 "picking": self.data.picking(picking),
+                "scan_location_or_pack_first": False,
             }
         )
+        data.update(kw)
         return data
 
     @classmethod
     def _set_dest_package_and_done(cls, move_lines, dest_package):
         """Simulate what would have been done in the previous steps"""
         for line in move_lines:
             line.write(
@@ -65,10 +69,10 @@
         cls.env["stock.quant"].sudo().search(
             [("location_id", "=", cls.stock_location.id)]
         ).unlink()
         cls.batch = cls._create_picking_batch(
             [[cls.BatchProduct(product=cls.product_a, quantity=1)]]
         )
 
-    def _line_data(self, move_line, qty=1.0):
+    def _line_data(self, move_line, qty=1.0, **kw):
         # just force qty to 1.0
-        return super()._line_data(move_line, qty=qty)
+        return super()._line_data(move_line, qty=qty, **kw)
```

## odoo/addons/shopfloor/tests/test_cluster_picking_change_pack_lot.py

```diff
@@ -22,14 +22,15 @@
         batch = line.picking_id.batch_id
         response = self.service.dispatch(
             "change_pack_lot",
             params={
                 "picking_batch_id": batch.id,
                 "move_line_id": line.id,
                 "barcode": barcode,
+                "quantity": line.qty_done,
             },
         )
         if success:
             self.assert_response(
                 response,
                 message=message,
                 next_state="scan_destination",
```

## odoo/addons/shopfloor/tests/test_cluster_picking_scan_destination.py

```diff
@@ -140,15 +140,15 @@
                 "quantity": line.product_uom_qty,
             },
         )
         self.assertRecordValues(line, [{"qty_done": 0, "result_package_id": False}])
         self.assert_response(
             response,
             next_state="scan_destination",
-            data=self._line_data(line),
+            data=self._line_data(line, qty_done=10.0),
             message={
                 "message_type": "error",
                 "body": "The destination bin {} is not empty,"
                 " please take another.".format(self.bin1.name),
             },
         )
 
@@ -197,18 +197,20 @@
                 "picking_batch_id": self.batch.id,
                 "move_line_id": line.id,
                 # this bin is used for the other picking
                 "barcode": "⌿",
                 "quantity": line.product_uom_qty,
             },
         )
+        line_data = self._line_data(line)
+        line_data["qty_done"] = 10
         self.assert_response(
             response,
             next_state="scan_destination",
-            data=self._line_data(line),
+            data=line_data,
             message={
                 "message_type": "error",
                 "body": "Bin {} doesn't exist".format("⌿"),
             },
         )
 
     def test_scan_destination_pack_quantity_more(self):
@@ -222,15 +224,15 @@
                 "barcode": self.bin1.name,
                 "quantity": line.product_uom_qty + 1,
             },
         )
         self.assert_response(
             response,
             next_state="scan_destination",
-            data=self._line_data(line),
+            data=self._line_data(line, qty_done=11.0),
             message={
                 "message_type": "error",
                 "body": "You must not pick more than {} units.".format(
                     line.product_uom_qty
                 ),
             },
         )
```

## odoo/addons/shopfloor/tests/test_cluster_picking_scan_line.py

```diff
@@ -10,81 +10,60 @@
     After a batch has been selected and the user confirmed they are
     working on it.
 
     User scans something and the scan_line endpoints validates they
     scanned the proper thing to pick.
     """
 
-    def _scan_line_ok(self, line, scanned):
+    def _scan_line_ok(self, line, scanned, expected_qty_done=1):
         batch = line.picking_id.batch_id
+        previous_qty_done = line.qty_done
         response = self.service.dispatch(
             "scan_line",
             params={
                 "picking_batch_id": batch.id,
                 "move_line_id": line.id,
                 "barcode": scanned,
             },
         )
+        # For any barcode scanned, the quantity done is set in
+        # the response data to fully done but the record is not updated.
+        # We ensure the qty has not changed in the record.
+        self.assertEqual(line.qty_done, previous_qty_done)
+
         self.assert_response(
-            response, next_state="scan_destination", data=self._line_data(line)
+            response,
+            next_state="scan_destination",
+            data=self._line_data(line, qty_done=expected_qty_done),
         )
 
-    def _scan_line_error(self, line, scanned, message):
+    def _scan_line_error(self, line, scanned, message, sublocation=None):
         batch = line.picking_id.batch_id
         response = self.service.dispatch(
             "scan_line",
             params={
                 "picking_batch_id": batch.id,
                 "move_line_id": line.id,
                 "barcode": scanned,
             },
         )
+        kw = {"sublocation": self.data.location(sublocation)} if sublocation else {}
         self.assert_response(
             response,
             next_state="start_line",
-            data=self._line_data(line),
+            data=self._line_data(line, **kw),
             message=message,
         )
 
     def test_scan_line_pack_ok(self):
         """Scan to check if user picks the correct pack for current line"""
         self._simulate_batch_selected(self.batch, in_package=True)
         line = self.batch.picking_ids.move_line_ids
         self._scan_line_ok(line, line.package_id.name)
 
-    def test_scan_line_pack_multiple_product(self):
-        """Scan pack with multiple products raises an error"""
-        self._simulate_batch_selected(self.batch, in_package=True)
-        line = self.batch.picking_ids.move_line_ids
-        package = line.package_id
-        location = self.batch.picking_ids.location_id
-        self._update_qty_in_location(location, self.product_b, 2, package=package)
-        self._scan_line_error(
-            line,
-            line.package_id.name,
-            self.msg_store.several_products_in_package(package),
-        )
-
-    def test_scan_line_pack_multiple_lot(self):
-        """Scan pack with multiple lots raises an error"""
-        self.product_a.tracking = "lot"
-        self._simulate_batch_selected(self.batch, in_package=True, in_lot=True)
-        line = self.batch.picking_ids.move_line_ids
-        package = line.package_id
-        location = self.batch.picking_ids.location_id
-        new_lot = self.env["stock.production.lot"].create(
-            {"product_id": self.product_a.id, "company_id": self.env.company.id}
-        )
-        self._update_qty_in_location(
-            location, self.product_a, 2, package=package, lot=new_lot
-        )
-        self._scan_line_error(
-            line, line.package_id.name, self.msg_store.several_lots_in_package(package)
-        )
-
     def test_scan_line_product_ok(self):
         """Scan to check if user picks the correct product for current line"""
         self._simulate_batch_selected(self.batch)
         line = self.batch.picking_ids.move_line_ids
         self._scan_line_ok(line, line.product_id.barcode)
 
     def test_scan_line_lot_ok(self):
@@ -187,14 +166,15 @@
         # package
         move = line.move_id.copy()
         move.location_id = line.location_id.copy()
         self._fill_stock_for_moves(move)
         move._action_confirm(merge=False)
         move._action_assign()
         move.move_line_ids[0].package_id = None
+        move.move_line_ids[0].location_id = line.location_id.copy()
         self._scan_line_ok(line, move.product_id.barcode)
 
     def test_scan_line_lot_error_several_packages(self):
         """When we scan a lot which is in more than one package, error"""
         self._simulate_batch_selected(self.batch, in_package=True, in_lot=True)
         line = self.batch.picking_ids.move_line_ids
         # create a second move line for the same product in a different
@@ -281,14 +261,15 @@
         self._scan_line_error(
             line,
             location.barcode,
             {
                 "message_type": "warning",
                 "body": "Several packages found in Stock, please scan a package.",
             },
+            sublocation=location,
         )
         # scanning the package works
         self._scan_line_ok(line, pack_1.name)
 
     def test_scan_line_location_error_several_products(self):
         """Scan to check if user scans a correct location for current line
 
@@ -302,14 +283,15 @@
         self._scan_line_error(
             line,
             location.barcode,
             {
                 "message_type": "warning",
                 "body": "Several products found in Stock, please scan a product.",
             },
+            sublocation=location,
         )
         self._scan_line_ok(line, self.product_a.barcode)
 
     def test_scan_line_location_error_several_lots(self):
         """Scan to check if user scans a correct location for current line
 
         If there are several lots in the location, user has to scan one.
@@ -334,14 +316,15 @@
         self._scan_line_error(
             line,
             location.barcode,
             {
                 "message_type": "warning",
                 "body": "Several lots found in Stock, please scan a lot.",
             },
+            sublocation=location,
         )
         self._scan_line_ok(line, line.lot_id.name)
 
     def test_scan_line_error_wrong_package(self):
         """Wrong package scanned"""
         self._simulate_batch_selected(self.batch, in_package=True)
         pack = self.env["stock.quant.package"].sudo().create({})
```

## odoo/addons/shopfloor/tests/test_cluster_picking_select.py

```diff
@@ -334,14 +334,15 @@
         response = self.service.dispatch(
             "confirm_start", params={"picking_batch_id": self.batch.id}
         )
         data = self.data.move_line(first_move_line)
         data["package_dest"] = None
         data["picking"] = self.data.picking(picking)
         data["batch"] = self.data.picking_batch(batch)
+        data["scan_location_or_pack_first"] = False
         self.assert_response(
             response,
             data=data,
             next_state="start_line",
         )
 
     def test_confirm_start_not_exists(self):
```

## odoo/addons/shopfloor/tests/test_delivery_base.py

```diff
@@ -61,26 +61,50 @@
                 {
                     "name": "Box",
                     "product_id": cls.product_f.id,
                     "barcode": "ProductFBox",
                 }
             )
         )
+        cls.product_g = (
+            cls.env["product.product"]
+            .sudo()
+            .create(
+                {
+                    "name": "Product G",
+                    "type": "product",
+                    "default_code": "G",
+                    "barcode": "G",
+                    "weight": 1,
+                }
+            )
+        )
+        cls.product_g_packaging = (
+            cls.env["product.packaging"]
+            .sudo()
+            .create(
+                {
+                    "name": "Box",
+                    "product_id": cls.product_g.id,
+                    "barcode": "ProductGBox",
+                }
+            )
+        )
 
     def setUp(self):
         super().setUp()
         self.service = self.get_service(
             "delivery", menu=self.menu, profile=self.profile
         )
 
     def _stock_picking_data(self, picking):
         return self.service.data_detail.picking_detail(picking)
 
     def _stock_location_data(self, location):
-        return self.service.data.location(location)
+        return self.service.data.location(location, with_operation_progress=True)
 
     def assert_response_deliver(
         self, response, picking=None, message=None, location=None
     ):
         self.assert_response(
             response,
             next_state="deliver",
```

## odoo/addons/shopfloor/tests/test_delivery_scan_deliver.py

```diff
@@ -20,23 +20,27 @@
                 (cls.product_c, 10),
                 # D as raw product
                 (cls.product_d, 10),
                 # E as raw product with a lot
                 (cls.product_e, 10),
                 # F in two different packages
                 (cls.product_f, 10),
+                # G in a package with quantity of one.
+                (cls.product_g, 10),
             ]
         )
         cls.pack1_moves = picking.move_lines[:2]
         cls.pack2_move = picking.move_lines[2]
         cls.pack3_move = picking.move_lines[5]
+        cls.pack4_move = picking.move_lines[6]
         cls.raw_move = picking.move_lines[3]
         cls.raw_lot_move = picking.move_lines[4]
         cls._fill_stock_for_moves(cls.pack1_moves, in_package=True)
         cls._fill_stock_for_moves(cls.pack2_move, in_package=True)
+        cls._fill_stock_for_moves(cls.pack4_move, in_package=True)
         cls._fill_stock_for_moves(cls.raw_move)
         cls._fill_stock_for_moves(cls.raw_lot_move, in_lot=True)
         # Set a lot for A for the mixed package (A + B)
         cls.product_a_lot = cls.env["stock.production.lot"].create(
             {"product_id": cls.product_a.id, "company_id": cls.env.company.id}
         )
         cls.product_a_quant = cls.env["stock.quant"].search(
@@ -113,40 +117,91 @@
             response,
             # if the client was working on a picking (it sends picking_id, then
             # send refreshed data)
             picking=self.picking,
             message=self.service.msg_store.barcode_not_found(),
         )
 
-    def _test_scan_set_done_ok(self, move_lines, barcode):
+    def _test_scan_set_done_ok(self, move_lines, barcode, qties=None):
         response = self.service.dispatch("scan_deliver", params={"barcode": barcode})
-        self.assert_qty_done(move_lines)
-        self.assert_response_deliver(response, picking=self.picking)
+        self.assert_qty_done(move_lines, qties)
+        picking = move_lines.move_id.picking_id
+        if picking.state == "done":
+            self.assert_response_deliver(
+                response, message=self.msg_store.transfer_complete(picking)
+            )
+        else:
+            self.assert_response_deliver(response, picking=picking)
 
-    def test_scan_deliver_scan_package_ok(self):
+    def test_scan_deliver_scan_package(self):
         move_lines = self.pack1_moves.mapped("move_line_ids")
         package = move_lines.mapped("package_id")
         self.assertEqual(self.picking.state, "assigned")
         self._test_scan_set_done_ok(move_lines, package.name)
         self.assertEqual(self.picking.state, "assigned")
 
+    def test_scan_deliver_scan_package_with_prepackaged_product(self):
+        """Check scanning a package process it entirely.
+
+        "Process as pre-packaged product" option is enabled to create a backorder.
+        """
+        self.menu.sudo().allow_prepackaged_product = True
+        move_lines = self.pack1_moves.mapped("move_line_ids")
+        package = move_lines.mapped("package_id")
+        self.assertEqual(self.picking.state, "assigned")
+        response = self.service.dispatch(
+            "scan_deliver", params={"barcode": package.name}
+        )
+        self.assert_response_deliver(
+            response, message=self.service.msg_store.transfer_complete(self.picking)
+        )
+        for line in move_lines:
+            self.assertEqual(line.move_id.product_uom_qty, line.move_id.quantity_done)
+            self.assertEqual(line.move_id.state, "done")
+        self.assertEqual(self.picking.state, "done")
+        self.assertTrue(self.picking.backorder_ids)
+
     def test_scan_deliver_scan_package_no_move_lines(self):
         response = self.service.dispatch(
             "scan_deliver",
             params={"barcode": self.free_package.name, "picking_id": self.picking.id},
         )
         self.assert_response_deliver(
             response,
             picking=self.picking,
             message=self.service.msg_store.cannot_move_something_in_picking_type(),
         )
 
-    def test_scan_deliver_scan_product_in_package_ok(self):
-        self._test_scan_set_done_ok(
-            self.pack2_move.mapped("move_line_ids"), self.product_c.barcode
+    def test_scan_deliver_scan_product_not_in_package(self):
+        """Check scanning product increment quantity done by one."""
+        for qty_done in range(1, 3):
+            response = self.service.dispatch(
+                "scan_deliver",
+                params={
+                    "barcode": self.product_d.barcode,
+                    "picking_id": self.picking.id,
+                },
+            )
+            self.assertEqual(self.raw_move.move_line_ids.qty_done, qty_done)
+
+        self.assert_response_deliver(
+            response,
+            picking=self.picking,
+        )
+
+    def test_scan_deliver_scan_product_in_package_multiple(self):
+        """Check product scanned alone in a package but quantity more than one."""
+        response = self.service.dispatch(
+            "scan_deliver",
+            params={"barcode": self.product_c.barcode, "picking_id": self.picking.id},
+        )
+        self.assert_response_deliver(
+            response,
+            picking=self.picking,
+            message=self.service.msg_store.product_not_unitary_in_package_scan_package(),
         )
 
     def test_scan_deliver_scan_product_in_multiple_packages(self):
         response = self.service.dispatch(
             "scan_deliver",
             params={"barcode": self.product_f.barcode, "picking_id": self.picking.id},
         )
@@ -176,25 +231,30 @@
             response,
             picking=self.picking,
             message=self.service.msg_store.scan_lot_on_product_tracked_by_lot(),
         )
 
     def test_scan_deliver_scan_raw_product_ok(self):
         self._test_scan_set_done_ok(
-            self.raw_move.mapped("move_line_ids"), self.product_d.barcode
+            self.raw_move.mapped("move_line_ids"),
+            self.product_d.barcode,
+            [1],  # When scanning a product we want to process only 1 qty
         )
 
     def test_scan_deliver_scan_raw_product_in_multiple_pickings(self):
         # Scan a raw product (not related to a package or lot) which is present
         # in multiple delivery operations (so two different moves).
         # We should be able to process these two moves one after the other.
+        self.picking.do_unreserve()
+        self.raw_move.product_uom_qty = 1
+        self.picking.action_assign()
         picking2 = self._create_picking(
             lines=[
                 # D as raw product
-                (self.product_d, 10),
+                (self.product_d, 1),
             ]
         )
         raw_move2 = picking2.move_lines
         self._fill_stock_for_moves(raw_move2)
         picking2.action_assign()
         # Scan the first move
         self._test_scan_set_done_ok(
@@ -203,32 +263,65 @@
         # Scan the second move
         # NOTE: we do not use '_test_scan_set_done_ok' here as we expect
         # the delivery to be complete (we process its only move line).
         response = self.service.dispatch(
             "scan_deliver", params={"barcode": self.product_d.barcode}
         )
         self.assert_response_deliver(
-            response, message=self.service.msg_store.transfer_complete(picking2)
+            response, message=self.service.msg_store.transfer_complete(self.picking)
         )
-        self.assertEqual(raw_move2.quantity_done, 10)
+        self.assertEqual(raw_move2.quantity_done, 1)
         self.assertEqual(raw_move2.state, "done")
 
     def test_scan_deliver_scan_product_not_found(self):
         response = self.service.dispatch(
             "scan_deliver", params={"barcode": self.free_product.barcode}
         )
         self.assert_response_deliver(
             response,
             message=self.service.msg_store.product_not_found_in_pickings(),
         )
 
-    def test_scan_deliver_scan_lot_ok(self):
-        move_lines = self.raw_lot_move.move_line_ids
-        lot = move_lines.lot_id
-        self._test_scan_set_done_ok(move_lines, lot.name)
+    def test_scan_deliver_scan_lot(self):
+        """Check scanning a lot process only one piece/unit of this lot."""
+        line = self.raw_lot_move.move_line_ids
+        lot = line.lot_id
+        response = self.service.dispatch("scan_deliver", params={"barcode": lot.name})
+        self.assert_response_deliver(
+            response,
+            picking=self.picking,
+        )
+        self.assertEqual(line.qty_done, 1)
+        self.assertEqual(line.state, "assigned")
+        for _ in range(int(line.product_uom_qty) - 1):
+            self.service.dispatch(
+                "scan_deliver",
+                params={
+                    "barcode": lot.name,
+                    "picking_id": self.picking.id,
+                },
+            )
+        self.assertEqual(line.qty_done, self.raw_lot_move.product_uom_qty)
+
+    def test_scan_deliver_scan_lot_with_prepackaged_product(self):
+        """Check scanning a lot process only one piece/unit of this lot.
+
+        "Process as pre-packaged product" option is enabled to create a backorder.
+        """
+        self.menu.sudo().allow_prepackaged_product = True
+        line = self.raw_lot_move.move_line_ids
+        lot = line.lot_id
+        response = self.service.dispatch("scan_deliver", params={"barcode": lot.name})
+        self.assert_response_deliver(
+            response, message=self.service.msg_store.transfer_complete(self.picking)
+        )
+        self.assertEqual(line.qty_done, 1)
+        self.assertEqual(line.move_id.state, "done")
+        self.assertEqual(self.picking.state, "done")
+        self.assertTrue(self.picking.backorder_ids)
 
     def test_scan_deliver_scan_lot_not_found(self):
         response = self.service.dispatch("scan_deliver", params={"barcode": "FREE_LOT"})
         self.assert_response_deliver(
             response,
             message=self.service.msg_store.lot_not_found_in_pickings(),
         )
@@ -239,15 +332,35 @@
         )
         self.assert_response_deliver(
             response,
             picking=self.picking,
             message=self.service.msg_store.lot_mixed_package_scan_package(),
         )
 
-    def test_scan_deliver_scan_product_packaging_ok(self):
+    def test_scan_deliver_scan_product_packaging(self):
+        """Check scanning a product packaging use the packaging quantity.
+
+        Quantity on the line is the packaging quantity
+        """
+        # Scan a product packaging having the same qty than the qty to ship.
+        # We have 10 qties to ship and we scan a product packaging of 10 qties.
+        line = self.raw_move.mapped("move_line_ids")
+        response = self.service.dispatch(
+            "scan_deliver", params={"barcode": self.packaging.barcode}
+        )
+        self.assert_response_deliver(response, picking=self.picking)
+        self.assertEqual(line.qty_done, self.packaging.qty)
+
+    def test_scan_deliver_scan_product_packaging_with_prepackaged_product(self):
+        """Check scanning a product packaging use the packaging quantity.
+
+        Quantity on the line is the packaging quantity
+
+        "Process as pre-packaged product" option is enabled to create a backorder.
+        """
         # Scan a product packaging having the same qty than the qty to ship.
         # We have 10 qties to ship and we scan a product packaging of 10 qties.
         self.menu.sudo().allow_prepackaged_product = True
         line = self.raw_move.mapped("move_line_ids")
         response = self.service.dispatch(
             "scan_deliver", params={"barcode": self.packaging.barcode}
         )
@@ -255,57 +368,128 @@
             response, message=self.service.msg_store.transfer_complete(self.picking)
         )
         self.assertEqual(line.qty_done, self.packaging.qty)
 
     def test_scan_deliver_scan_product_packaging_partial_qty(self):
         # Scan a product packaging with a smaller qty than the move line
         # We have 10 qties to ship but we scan a product packaging of 5 qties.
+        # -> Processed 5 over 10 qties
+        # Then we scan a second time the product packaging all qties will be processed
+        # -> Processed 10/10
+        self.packaging.qty = 5
+        line = self.raw_move.mapped("move_line_ids")
+        self.assertEqual(line.move_id.product_qty, 10)
+        response = self.service.dispatch(
+            "scan_deliver", params={"barcode": self.packaging.barcode}
+        )
+        self.assert_response_deliver(response, picking=self.picking)
+        self.assertEqual(line.qty_done, self.packaging.qty)
+        self.assertTrue(line.move_id.product_qty > self.packaging.qty)
+        # Process the remaining qties, still by scanning the packaging
+        response = self.service.dispatch(
+            "scan_deliver", params={"barcode": self.packaging.barcode}
+        )
+        self.assert_response_deliver(response, picking=self.picking)
+        self.assertEqual(line.move_id.product_qty, line.move_id.quantity_done)
+        self.assertEqual(line.move_id.state, "assigned")
+
+    def test_scan_deliver_scan_product_packaging_partial_qty_with_prepackaged_product(
+        self,
+    ):
+        # Scan a product packaging with a smaller qty than the move line
+        # while the "Process pre-packaged product" option is enabled.
+        # We have 10 qties to ship but we scan a product packaging of 5 qties.
         # -> Ship 5 (creating a backorder for the 5 remaining)
+        # Then we scan a second time the product packaging to process the backorder
+        # -> Ship 5 (again)
         self.menu.sudo().allow_prepackaged_product = True
         self.packaging.qty = 5
         line = self.raw_move.mapped("move_line_ids")
         self.assertEqual(line.move_id.product_qty, 10)
         response = self.service.dispatch(
             "scan_deliver", params={"barcode": self.packaging.barcode}
         )
         self.assert_response_deliver(
-            response, message=self.service.msg_store.transfer_complete(self.picking)
+            response,
+            message=self.service.msg_store.transfer_complete(self.picking),
         )
         self.assertEqual(line.qty_done, self.packaging.qty)
         self.assertEqual(line.move_id.product_qty, self.packaging.qty)
         self.assertEqual(line.move_id.state, "done")
+        self.assertTrue(self.picking.backorder_ids)
+        # Process the backorder
+        backorder = self.picking.backorder_ids
+        backorder_raw_move = backorder.move_lines.filtered_domain(
+            [("product_id", "=", self.product_d.id)]
+        )
+        backorder_line = backorder_raw_move.move_line_ids
+        response = self.service.dispatch(
+            "scan_deliver", params={"barcode": self.packaging.barcode}
+        )
+        self.assert_response_deliver(
+            response, message=self.service.msg_store.transfer_complete(backorder)
+        )
+        self.assertEqual(backorder_line.move_id.product_qty, self.packaging.qty)
+        self.assertEqual(backorder_line.move_id.state, "done")
+
+    def test_scan_deliver_scan_product_alone_in_package_qty_one(self):
+        """Check scanning a product alone in a package with a quantity of one."""
+        self.picking.action_cancel()
+        pick = self._create_picking(
+            lines=[
+                (self.product_c, 1),
+            ]
+        )
+        pack_move = pick.move_lines[:1]
+        self._fill_stock_for_moves(pack_move, in_package=True)
+        pick.action_assign()
+        move_lines = pick.move_lines.mapped("move_line_ids")
+        self._test_scan_set_done_ok(move_lines, self.product_c.barcode, [1])
 
     def test_scan_deliver_picking_done(self):
         # Set qty done for all lines (packages/raw product/lot...), picking is
         # automatically set to done when the last line is completed
         package1 = self.pack1_moves.mapped("move_line_ids").mapped("package_id")
         package2 = self.pack2_move.mapped("move_line_ids").mapped("package_id")
+        package4 = self.pack4_move.mapped("move_line_ids").mapped("package_id")
         self.service.dispatch(
             "set_qty_done_pack",
             params={"package_id": package1.id, "picking_id": self.picking.id},
         )
         self.assertEqual(self.picking.state, "assigned")
         self.service.dispatch(
             "set_qty_done_pack",
             params={"package_id": package2.id, "picking_id": self.picking.id},
         )
         self.assertEqual(self.picking.state, "assigned")
+
         self.service.dispatch(
-            "scan_deliver",
-            params={
-                "barcode": self.raw_move.product_id.barcode,
-                "picking_id": self.picking.id,
-            },
+            "set_qty_done_pack",
+            params={"package_id": package4.id, "picking_id": self.picking.id},
         )
         self.assertEqual(self.picking.state, "assigned")
+
+        # When a product is scanned, we process only one unit of it
+        for _ in range(int(self.raw_move.product_uom_qty)):
+            self.service.dispatch(
+                "scan_deliver",
+                params={
+                    "barcode": self.raw_move.product_id.barcode,
+                    "picking_id": self.picking.id,
+                },
+            )
+        self.assertEqual(self.picking.state, "assigned")
+
+        # When a lot is scanned, we process only one unit of it
         lot = self.raw_lot_move.move_line_ids.lot_id
-        response = self.service.dispatch(
-            "scan_deliver",
-            params={"barcode": lot.name, "picking_id": self.picking.id},
-        )
+        for _ in range(int(self.raw_lot_move.product_uom_qty)):
+            response = self.service.dispatch(
+                "scan_deliver",
+                params={"barcode": lot.name, "picking_id": self.picking.id},
+            )
         self.assertEqual(self.picking.state, "assigned")
         packages_f = self.pack3_move.move_line_ids.mapped("package_id")
         # While all lines are not processed, response still returns the picking
         self.assert_response_deliver(
             response,
             picking=self.picking,
         )
```

## odoo/addons/shopfloor/tests/test_delivery_sublocation.py

```diff
@@ -7,14 +7,28 @@
 class DeliveryScanSublocationCase(DeliveryCommonCase):
     """Tests sublocation with delivery service."""
 
     @classmethod
     def setUpClassBaseData(cls):
         super().setUpClassBaseData()
         cls.product_e.tracking = "lot"
+        # Picking for the top location
+        cls.picking = picking = cls._create_picking(
+            lines=[
+                (cls.product_d, 10),  # D as raw product
+                (cls.product_e, 10),  # E as raw product with a lot
+            ]
+        )
+        cls.raw_move = picking.move_lines[0]
+        cls.raw_lot_move = picking.move_lines[1]
+        cls._fill_stock_for_moves(cls.raw_move)
+        cls._fill_stock_for_moves(cls.raw_lot_move, in_lot=True)
+        picking.action_assign()
+        cls.lot = cls.raw_lot_move.move_line_ids.lot_id
+        # Create a sublocation
         cls.sublocation = (
             cls.env["stock.location"]
             .sudo()
             .create(
                 {
                     "name": "Output 1",
                     "location_id": cls.picking_type.default_location_src_id.id,
@@ -29,31 +43,20 @@
                 (cls.product_d, 10),  # D as raw product
                 (cls.product_e, 10),  # E as raw product with a lot
             ]
         )
         cls.picking_sublocation.location_id = cls.sublocation
         cls.raw_move_sublocation = cls.picking_sublocation.move_lines[0]
         cls.raw_lot_move_sublocation = cls.picking_sublocation.move_lines[1]
-        cls._fill_stock_for_moves(cls.raw_move_sublocation)
-        cls._fill_stock_for_moves(cls.raw_lot_move_sublocation, in_lot=True)
-        cls.picking_sublocation.action_assign()
-        # Picking for the top location
-        cls.picking = picking = cls._create_picking(
-            lines=[
-                (cls.product_d, 10),  # D as raw product
-                (cls.product_e, 10),  # E as raw product with a lot
-            ]
-        )
-        cls.raw_move = picking.move_lines[0]
-        cls.raw_lot_move = picking.move_lines[1]
-        cls._fill_stock_for_moves(cls.raw_move)
+        cls._fill_stock_for_moves(cls.raw_move_sublocation, location=cls.sublocation)
         # Use the same lot on product from both picking
-        cls.lot = cls.raw_lot_move_sublocation.move_line_ids.lot_id
-        cls._fill_stock_for_moves(cls.raw_lot_move, in_lot=cls.lot)
-        picking.action_assign()
+        cls._fill_stock_for_moves(
+            cls.raw_lot_move_sublocation, in_lot=cls.lot, location=cls.sublocation
+        )
+        cls.picking_sublocation.action_assign()
 
     def test_scan_sublocation_exists(self):
         """Check scanning a sublocation sets it as sublocation."""
         response = self.service.dispatch(
             "scan_deliver",
             params={
                 "barcode": self.sublocation.barcode,
@@ -83,19 +86,19 @@
             response,
             location=self.sublocation,
             message=self.service.msg_store.barcode_not_found(),
         )
 
     def test_scan_barcode_in_sublocation(self):
         """Scan product barcode that exists in sublocation."""
+
         response = self.service.dispatch(
             "scan_deliver",
             params={
                 "barcode": self.product_d.barcode,
-                "picking_id": None,
                 "location_id": self.sublocation.id,
             },
         )
         self.assert_response_deliver(
             response,
             location=self.sublocation,
             picking=self.picking_sublocation,
```

## odoo/addons/shopfloor/tests/test_location_content_transfer_base.py

```diff
@@ -49,15 +49,17 @@
 
         """
         pickings.user_id = cls.env.uid
         for line in pickings.mapped("move_line_ids"):
             line.qty_done = line.product_uom_qty
 
     def assert_response_start(self, response, message=None, popup=None):
-        self.assert_response(response, next_state="start", message=message, popup=popup)
+        self.assert_response(
+            response, next_state="scan_location", message=message, popup=popup
+        )
 
     def _assert_response_scan_destination_all(
         self, state, response, pickings, message=None, confirmation_required=False
     ):
         # this code is repeated from the implementation, not great, but we
         # mostly want to ensure the selection of pickings is right, and the
         # data methods have their own tests
```

## odoo/addons/shopfloor/tests/test_location_content_transfer_putaway.py

```diff
@@ -90,15 +90,15 @@
             self._update_qty_in_location(location, self.product_a, 10, package=package)
 
         response = self.service.dispatch(
             "scan_location", params={"barcode": self.test_loc.barcode}
         )
         self.assert_response(
             response,
-            next_state="start",
+            next_state="scan_location",
             message=self.service.msg_store.no_putaway_destination_available(),
         )
 
         package_levels = self.env["stock.package_level"].search(
             [("package_id", "in", (self.package.id, self.package2.id))]
         )
         # no package level created to move the package
@@ -125,15 +125,15 @@
             [("location_id", "=", self.test_loc.id), ("state", "=", "assigned")]
         )
         response = self.service.dispatch(
             "scan_location", params={"barcode": self.test_loc.barcode}
         )
         self.assert_response(
             response,
-            next_state="start",
+            next_state="scan_location",
             data=self.ANY,
             message=self.service.msg_store.location_content_unable_to_transfer(
                 self.test_loc
             ),
         )
         current_moves = self.env["stock.move"].search(
             [("location_id", "=", self.test_loc.id), ("state", "=", "assigned")]
```

## odoo/addons/shopfloor/tests/test_location_content_transfer_set_destination_all.py

```diff
@@ -121,14 +121,15 @@
         # As we have no ancestor move in progress, a normal backorder is created
         # with the remaining qties
         self.assertEqual(self.picking2.state, "done")
         self.assertEqual(move_d.state, "done")
         self.assertEqual(move_d.product_qty, 5)
         self.assertTrue(self.picking2.backorder_ids)
         self.assertNotEqual(self.picking2.backorder_ids.state, "done")
+        self.assertFalse(self.picking2.backorder_ids.user_id)
         self.assertEqual(self.picking2.backorder_ids.move_lines.product_qty, 5)
 
     def test_set_destination_all_with_partially_available_move_with_ancestor(self):
         """Scanned destination location valid, but one of the move to process
         is partially available and has an unprocessed ancestor move.
 
         In such case, new picking is created to validate the moves, and the
```

## odoo/addons/shopfloor/tests/test_location_content_transfer_start.py

```diff
@@ -52,15 +52,15 @@
         cls._fill_stock_for_moves(picking2.move_lines[1], location=cls.content_loc2)
         cls.pickings.action_assign()
         cls.move_lines = cls.pickings.move_line_ids
 
     def test_start_fresh(self):
         """Start a fresh session when there is no transfer to recover"""
         response = self.service.dispatch("start_or_recover", params={})
-        self.assert_response(response, next_state="start")
+        self.assert_response(response, next_state="scan_location")
 
     def test_start_recover_destination_all(self):
         """Recover transfers, all move lines have the same destination"""
         self._simulate_pickings_selected(self.picking1)
         # all lines go to the same destination (shelf1)
         self.assertEqual(len(self.picking1.mapped("move_line_ids.location_dest_id")), 1)
```

## odoo/addons/shopfloor/tests/test_scan_anything.py

```diff
@@ -7,19 +7,22 @@
 
 from .test_actions_data_base import ActionsDataDetailCaseBase
 
 
 class ScanAnythingCase(ActionsDataDetailCaseBase, ScanAnythingTestMixin):
     def test_scan_product(self):
         record = self.product_b
+        record.default_code = "PROD-B-code"
         record.barcode = "PROD-B"
         rec_type = "product"
         identifier = record.barcode
         data = self.data_detail.product_detail(record)
         self._test_response_ok(rec_type, data, identifier)
+        identifier = record.default_code
+        self._test_response_ok(rec_type, data, identifier)
 
     def test_scan_location(self):
         record = self.stock_location
         rec_type = "location"
         identifier = record.barcode
         data = self.data_detail.location_detail(record)
         self._test_response_ok(rec_type, data, identifier)
```

## odoo/addons/shopfloor/tests/test_single_pack_transfer.py

```diff
@@ -76,15 +76,15 @@
     def _response_package_level_data(self, package_level):
         return {
             "id": package_level.id,
             "name": package_level.package_id.name,
             "location_src": self.data.location(package_level.location_id),
             "location_dest": self.data.location(package_level.location_dest_id),
             "picking": self.data.picking(self.picking),
-            "product": self.data.product(self.product_a),
+            "products": self.data.products(self.product_a),
         }
 
     def test_start(self):
         """Test the happy path for single pack transfer /start endpoint
 
         We scan the barcode of the pack (simplest use case).
 
@@ -188,15 +188,15 @@
             "id": package_level.id,
             "name": package_level.package_id.name,
             "location_src": self.data.location(self.shelf1),
             "location_dest": self.data.location(
                 self.picking_type.default_location_dest_id
             ),
             "picking": self.data.picking(package_level.picking_id),
-            "product": self.data.product(self.product_a),
+            "products": self.data.products(self.product_a),
             "confirmation_required": False,
         }
 
         self.assert_response(response, next_state="scan_location", data=expected_data)
 
     def test_start_barcode_not_known(self):
         """Test /start when the barcode is unknown
```

## odoo/addons/shopfloor/tests/test_zone_picking_base.py

```diff
@@ -303,23 +303,31 @@
         zone_location,
         picking_type,
         move_lines,
         message=None,
         popup=None,
         confirmation_required=False,
         product=None,
+        sublocation=None,
+        location_first=None,
+        package=None,
     ):
         data = {
             "zone_location": self.data.location(zone_location),
             "picking_type": self.data.picking_type(picking_type),
             "move_lines": self.data.move_lines(move_lines, with_picking=True),
             "confirmation_required": confirmation_required,
+            "scan_location_or_pack_first": location_first,
         }
         if product:
             data["product"] = self.data.product(product)
+        if package:
+            data["package"] = self.data.package(package)
+        if sublocation:
+            data["sublocation"] = self.data.location(sublocation)
         for data_move_line in data["move_lines"]:
             move_line = self.env["stock.move.line"].browse(data_move_line["id"])
             data_move_line[
                 "location_will_be_empty"
             ] = move_line.location_id.planned_qty_in_location_is_empty(move_line)
         self.assert_response(
             response,
@@ -335,66 +343,78 @@
         zone_location,
         picking_type,
         move_lines,
         message=None,
         popup=None,
         confirmation_required=False,
         product=None,
+        sublocation=None,
+        location_first=False,
+        package=False,
     ):
         self._assert_response_select_line(
             "select_line",
             response,
             zone_location,
             picking_type,
             move_lines,
             message=message,
             popup=popup,
             confirmation_required=confirmation_required,
             product=product,
+            sublocation=sublocation,
+            location_first=location_first,
+            package=package,
         )
 
     def _assert_response_set_line_destination(
         self,
         state,
         response,
         zone_location,
         picking_type,
         move_line,
         message=None,
         confirmation_required=False,
+        qty_done=None,
     ):
+        expected_move_line = self.data.move_line(move_line, with_picking=True)
+        if qty_done is not None:
+            expected_move_line["qty_done"] = qty_done
         self.assert_response(
             response,
             next_state=state,
             data={
                 "zone_location": self.data.location(zone_location),
                 "picking_type": self.data.picking_type(picking_type),
-                "move_line": self.data.move_line(move_line, with_picking=True),
+                "move_line": expected_move_line,
                 "confirmation_required": confirmation_required,
             },
             message=message,
         )
 
     def assert_response_set_line_destination(
         self,
         response,
         zone_location,
         picking_type,
         move_line,
         message=None,
         confirmation_required=False,
+        qty_done=None,
     ):
         self._assert_response_set_line_destination(
             "set_line_destination",
             response,
             zone_location,
             picking_type,
             move_line,
             message=message,
             confirmation_required=confirmation_required,
+            qty_done=qty_done,
         )
 
     def _assert_response_zero_check(
         self,
         state,
         response,
         zone_location,
```

## odoo/addons/shopfloor/tests/test_zone_picking_select_line.py

```diff
@@ -122,14 +122,15 @@
         )
         move_line = self.picking1.move_line_ids
         self.assert_response_set_line_destination(
             response,
             zone_location=self.zone_location,
             picking_type=self.picking_type,
             move_line=move_line,
+            qty_done=10.0,
         )
 
     def test_scan_source_barcode_location_two_move_lines_same_product(self):
         """Scan source: scanned location 'Zone sub-location 1' contains two lines.
 
         Lines have the same product/package/lot,
         they get processed one after the other,
@@ -147,28 +148,30 @@
         )
         move_line = self.picking1.move_line_ids
         self.assert_response_set_line_destination(
             response,
             zone_location=self.zone_location,
             picking_type=self.picking_type,
             move_line=move_line,
+            qty_done=10.0,
         )
         # first line done
         move_line.qty_done = move_line.product_uom_qty
         # get the next one
         response = self.service.dispatch(
             "scan_source",
             params={"barcode": self.zone_sublocation1.barcode},
         )
         move_line = new_picking.move_line_ids
         self.assert_response_set_line_destination(
             response,
             zone_location=self.zone_location,
             picking_type=self.picking_type,
             move_line=move_line,
+            qty_done=10.0,
         )
 
     def test_scan_source_barcode_location_several_move_lines(self):
         """Scan source: scanned location 'Zone sub-location 2' contains two
         move lines, next step 'select_line' expected with the list of these
         move lines.
         """
@@ -181,14 +184,16 @@
             response,
             zone_location=self.zone_location,
             picking_type=self.picking_type,
             move_lines=move_lines,
             message=self.service.msg_store.several_products_in_location(
                 self.zone_sublocation2
             ),
+            sublocation=self.zone_sublocation2,
+            location_first=False,
         )
 
     def test_scan_source_barcode_package(self):
         """Scan source: scanned package has one related move line,
         next step 'set_line_destination' expected on it.
         """
         package = self.picking1.package_level_ids[0].package_id
@@ -202,20 +207,22 @@
         move_lines = move_lines.sorted(lambda l: l.move_id.priority, reverse=True)
         move_line = move_lines[0]
         self.assert_response_set_line_destination(
             response,
             zone_location=self.zone_location,
             picking_type=self.picking_type,
             move_line=move_line,
+            qty_done=10.0,
         )
 
     def test_scan_source_barcode_package_not_found(self):
         """Scan source: scanned package has no related move line,
         next step 'select_line' expected.
         """
+        self.free_package.location_id = self.zone_location
         pack_code = self.free_package.name
         response = self.service.dispatch(
             "scan_source",
             params={"barcode": pack_code},
         )
         move_lines = self.service._find_location_move_lines()
         move_lines = move_lines.sorted(lambda l: l.move_id.priority, reverse=True)
@@ -245,29 +252,32 @@
             message=self.service.msg_store.barcode_not_found(),
         )
 
     def test_scan_source_package_many_products(self):
         """Scan source: scanned package that several product, aborting
         next step 'select_line expected.
         """
-        pack = self.free_package
-        self._update_qty_in_location(self.zone_location, self.product_a, 2, pack)
-        self._update_qty_in_location(self.zone_location, self.product_b, 2, pack)
+        pack = self.picking1.package_level_ids[0].package_id
+        self._update_qty_in_location(pack.location_id, self.product_b, 2, pack)
         response = self.service.dispatch(
             "scan_source",
             params={"barcode": pack.name},
         )
-        move_lines = self.service._find_location_move_lines()
+        move_lines = self.service._find_location_move_lines(
+            locations=self.zone_sublocation1
+        )
         move_lines = move_lines.sorted(lambda l: l.move_id.priority, reverse=True)
         self.assert_response_select_line(
             response,
             zone_location=self.zone_location,
             picking_type=self.picking_type,
             move_lines=move_lines,
+            package=pack,
             message=self.service.msg_store.several_products_in_package(pack),
+            location_first=False,
         )
 
     def test_scan_source_barcode_package_can_replace_in_line(self):
         """Scan source: scanned package has no related line but can replace
         next step 'select_line' expected with confirmation required set.
         Scan source: 2nd time the package replace package line with new package
         next step 'set_line_destination'.
@@ -328,14 +338,15 @@
             product=self.product_a,
         )
         self.assert_response_set_line_destination(
             response,
             zone_location=self.zone_location,
             picking_type=self.picking_type,
             move_line=move_line,
+            qty_done=10.0,
         )
 
     def test_scan_source_barcode_product_not_found(self):
         """Scan source: scanned product has no related move line,
         next step 'select_line' expected.
         """
         response = self.service.dispatch(
@@ -345,21 +356,25 @@
         move_lines = self.service._find_location_move_lines()
         move_lines = move_lines.sorted(lambda l: l.move_id.priority, reverse=True)
         self.assert_response_select_line(
             response,
             zone_location=self.zone_location,
             picking_type=self.picking_type,
             move_lines=move_lines,
-            message=self.service.msg_store.product_not_found(),
+            message=self.service.msg_store.product_not_found_in_pickings(),
         )
 
     def test_scan_source_barcode_product_multiple_moves_different_location(self):
         """Scan source: scanned product has move lines in multiple sub location.
 
         next step : 'select_line' expected.
+
+        Then scan a location and a specific line is selected.
+
+        next step : 'set_line_destination'
         """
         # Using picking4 which has a product in two sublocation
         response = self.service.dispatch(
             "scan_source",
             params={"barcode": self.product_e.barcode},
         )
         move_lines = self.service._find_location_move_lines(product=self.product_e)
@@ -368,14 +383,80 @@
             response,
             zone_location=self.zone_location,
             picking_type=self.picking_type,
             move_lines=move_lines,
             product=self.product_e,
             message=self.service.msg_store.several_move_in_different_location(),
         )
+        response = self.service.dispatch(
+            "scan_source",
+            params={
+                "barcode": self.zone_sublocation3.barcode,
+                "product_id": self.product_e.id,
+            },
+        )
+        self.assertEqual(response["next_state"], "set_line_destination")
+        move_line = self.service._find_location_move_lines(
+            product=self.product_e, locations=self.zone_sublocation3
+        )
+        self.assert_response_set_line_destination(
+            response,
+            zone_location=self.zone_location,
+            picking_type=self.picking_type,
+            move_line=move_line,
+            qty_done=6.0,
+        )
+
+    def test_scan_source_barcode_location_multiple_moves_different_product(self):
+        """Scan source: scanned location has move lines with multiple product.
+
+        next step : 'select_line' expected.
+
+        Then scan a product and a specific line is selected.
+
+        next step : 'set_line_destination'
+        """
+        # Using picking4 which has a product in two sublocation
+        response = self.service.dispatch(
+            "scan_source",
+            params={"barcode": self.zone_sublocation3.barcode},
+        )
+        move_lines = self.service._find_location_move_lines(
+            locations=self.zone_sublocation3
+        )
+        move_lines = move_lines.sorted(lambda l: l.move_id.priority, reverse=True)
+        self.assert_response_select_line(
+            response,
+            zone_location=self.zone_location,
+            picking_type=self.picking_type,
+            move_lines=move_lines,
+            sublocation=self.zone_sublocation3,
+            message=self.service.msg_store.several_products_in_location(
+                self.zone_sublocation3
+            ),
+            location_first=False,
+        )
+        response = self.service.dispatch(
+            "scan_source",
+            params={
+                "barcode": self.product_e.barcode,
+                "sublocation_id": self.zone_sublocation3.id,
+            },
+        )
+        self.assertEqual(response["next_state"], "set_line_destination")
+        move_line = self.service._find_location_move_lines(
+            product=self.product_e, locations=self.zone_sublocation3
+        )
+        self.assert_response_set_line_destination(
+            response,
+            zone_location=self.zone_location,
+            picking_type=self.picking_type,
+            move_line=move_line,
+            qty_done=6.0,
+        )
 
     def test_scan_source_barcode_product_with_multiple_lot(self):
         """Scan source: scanned product is found with mulitple lot number.
 
         next step : 'select_line' expected.
         """
         # Product C has already one lot from test_zone_picking_base.py
@@ -420,14 +501,15 @@
         move_lines = move_lines.sorted(lambda l: l.move_id.priority, reverse=True)
         move_line = move_lines[0]
         self.assert_response_set_line_destination(
             response,
             zone_location=self.zone_location,
             picking_type=self.picking_type,
             move_line=move_line,
+            qty_done=10.0,
         )
 
     def test_scan_source_barcode_lot_in_multiple_location(self):
         """Scan source: scanned lot is in multiple location
         next step 'select_line' expected on it.
         """
         # Picking 2 has already some lot from test_zone_picking_base.py
@@ -465,15 +547,15 @@
         move_lines = self.service._find_location_move_lines()
         move_lines = move_lines.sorted(lambda l: l.move_id.priority, reverse=True)
         self.assert_response_select_line(
             response,
             zone_location=self.zone_location,
             picking_type=self.picking_type,
             move_lines=move_lines,
-            message=self.service.msg_store.lot_not_found(),
+            message=self.service.msg_store.lot_not_found_in_pickings(),
         )
 
     def test_scan_source_barcode_not_found(self):
         response = self.service.dispatch(
             "scan_source",
             params={
                 "zone_location_id": self.zone_location.id,
@@ -522,15 +604,15 @@
             service = work.component(usage="zone_picking")
             response = service.scan_source(
                 self.zone_sublocation1.barcode,
             )
             self.assertEqual(response["next_state"], "select_line")
             self.assertEqual(
                 response["message"],
-                self.service.msg_store.location_empty(self.zone_sublocation1),
+                self.service.msg_store.wrong_record(self.zone_sublocation1),
             )
 
     def test_prepare_unload_buffer_empty(self):
         # unload goods
         response = self.service.dispatch(
             "prepare_unload",
             params={},
```

## odoo/addons/shopfloor/tests/test_zone_picking_set_line_destination.py

```diff
@@ -35,33 +35,35 @@
         as it is outside the current move line destination but is still
         allowed by the picking type's default destination.
         """
         zone_location = self.zone_location
         picking_type = self.picking1.picking_type_id
         move_line = self.picking1.move_line_ids
         move_line.location_dest_id = self.shelf1
+        quantity_done = move_line.product_uom_qty
         response = self.service.dispatch(
             "set_destination",
             params={
                 "move_line_id": move_line.id,
                 "barcode": self.packing_location.barcode,
-                "quantity": move_line.product_uom_qty,
+                "quantity": quantity_done,
                 "confirmation": False,
             },
         )
         # Check response
         self.assert_response_set_line_destination(
             response,
             zone_location,
             picking_type,
             move_line,
             message=self.service.msg_store.confirm_location_changed(
                 move_line.location_dest_id, self.packing_location
             ),
             confirmation_required=True,
+            qty_done=quantity_done,
         )
         # Confirm the destination with a wrong destination (should not happen)
         response = self.service.dispatch(
             "set_destination",
             params={
                 "move_line_id": move_line.id,
                 "barcode": self.customer_location.barcode,
@@ -72,14 +74,15 @@
         # Check response
         self.assert_response_set_line_destination(
             response,
             zone_location,
             picking_type,
             move_line,
             message=self.service.msg_store.dest_location_not_allowed(),
+            qty_done=quantity_done,
         )
         # Confirm the destination with the right destination this time
         response = self.service.dispatch(
             "set_destination",
             params={
                 "move_line_id": move_line.id,
                 "barcode": self.packing_location.barcode,
@@ -102,30 +105,32 @@
         # Confirm the destination with a wrong destination, outside of picking
         # and move's move line (should not happen)
         zone_location = self.zone_location
         picking_type = self.picking1.picking_type_id
         move_line = self.picking1.move_line_ids
         move_line.move_id.location_dest_id = self.packing_sublocation_a
         move_line.picking_id.location_dest_id = self.packing_sublocation_a
+        quantity_done = move_line.product_uom_qty
         response = self.service.dispatch(
             "set_destination",
             params={
                 "move_line_id": move_line.id,
                 "barcode": self.packing_sublocation_b.barcode,
-                "quantity": move_line.product_uom_qty,
+                "quantity": quantity_done,
                 "confirmation": True,
             },
         )
         # Check response
         self.assert_response_set_line_destination(
             response,
             zone_location,
             picking_type,
             move_line,
             message=self.service.msg_store.dest_location_not_allowed(),
+            qty_done=quantity_done,
         )
 
     def test_set_destination_location_no_other_move_line_full_qty(self):
         """Scanned barcode is the destination location.
 
         The move line is the only one in the move, and we move the whole qty.
 
@@ -204,14 +209,15 @@
             },
         )
         self.assert_response_set_line_destination(
             response,
             zone_location,
             picking_type,
             move_line,
+            qty_done=6,
             message=self.service.msg_store.package_not_found_for_barcode(barcode),
         )
 
     def test_set_destination_location_several_move_line_full_qty(self):
         """Scanned barcode is the destination location.
 
         The move line has siblings in the move, and we move the whole qty:
@@ -311,14 +317,15 @@
             },
         )
         self.assert_response_set_line_destination(
             response,
             zone_location,
             picking_type,
             move_line,
+            qty_done=4,
             message=self.service.msg_store.package_not_found_for_barcode(barcode),
         )
 
     def test_set_destination_location_zero_check(self):
         """Scanned barcode is the destination location.
 
         The move line is the only one in the source location, as such the
@@ -568,7 +575,67 @@
         self.assert_response_select_line(
             response,
             zone_location,
             picking_type,
             move_lines,
             message=self.service.msg_store.confirm_pack_moved(),
         )
+
+    def test_set_destination_location_zero_quantity(self):
+        """Scanned barcode is the destination location.
+
+        Quantity to move is zero -> error raised, user can try again.
+
+        """
+        zone_location = self.zone_location
+        picking_type = self.picking1.picking_type_id
+        move_line = self.picking1.move_lines.move_line_ids
+        response = self.service.dispatch(
+            "set_destination",
+            params={
+                "move_line_id": move_line.id,
+                "barcode": self.packing_location.barcode,
+                "quantity": 0,
+            },
+        )
+        # Check response
+        self.assert_response_set_line_destination(
+            response,
+            zone_location,
+            picking_type,
+            move_line,
+            message=self.service.msg_store.picking_zero_quantity(),
+            qty_done=move_line.product_uom_qty,
+        )
+
+    def test_set_destination_error_concurent_work(self):
+        """Scanned barcode is the destination package.
+
+        Move line is already being worked on by someone else
+        """
+        zone_location = self.zone_location
+        picking_type = self.picking1.picking_type_id
+        picking_type.sudo().shopfloor_zero_check = True
+        self.assertEqual(len(self.picking1.move_line_ids), 1)
+        move_line = self.picking1.move_line_ids
+        move_line.picking_id.user_id = self.shopfloor_manager
+        response = self.service.dispatch(
+            "set_destination",
+            params={
+                "move_line_id": move_line.id,
+                "barcode": self.free_package.name,
+                "quantity": move_line.product_uom_qty,
+                "confirmation": False,
+            },
+        )
+        # Check response
+        self.assert_response_set_line_destination(
+            response,
+            zone_location,
+            picking_type,
+            move_line,
+            message={
+                "message_type": "error",
+                "body": "Someone is already working on these transfers",
+            },
+            qty_done=move_line.product_uom_qty,
+        )
```

## odoo/addons/shopfloor/tests/test_zone_picking_set_line_destination_pick_pack.py

```diff
@@ -48,32 +48,36 @@
 
     def test_set_destination_location_no_carrier(self):
         """Scan location but carrier not set on picking"""
         zone_location = self.zone_location
         picking_type = self.picking1.picking_type_id
         move_line = self.picking1.move_line_ids
         move_line.location_dest_id = self.shelf1
+        quantity_done = move_line.product_uom_qty
+        previous_qty_done = move_line.qty_done
         # Confirm the destination with the right destination
         response = self.service.dispatch(
             "set_destination",
             params={
                 "move_line_id": move_line.id,
                 "barcode": self.packing_location.barcode,
-                "quantity": move_line.product_uom_qty,
+                "quantity": quantity_done,
                 "confirmation": True,
             },
         )
+        self.assertEqual(move_line.qty_done, previous_qty_done)
         self.assert_response_set_line_destination(
             response,
             zone_location,
             picking_type,
             move_line,
             message=self.service.msg_store.picking_without_carrier_cannot_pack(
                 move_line.picking_id
             ),
+            qty_done=quantity_done,
         )
 
     def test_set_destination_location_ok_carrier(self):
         """When carried is set goods are packed into new delivery package."""
         existing_packages = self.env["stock.quant.package"].search([])
         zone_location = self.zone_location
         picking_type = self.picking1.picking_type_id
@@ -111,59 +115,63 @@
         """Scan destination package, no carrier on picking."""
         zone_location = self.zone_location
         picking_type = self.picking1.picking_type_id
         moves_before = self.picking1.move_lines
         self.assertEqual(len(moves_before), 1)
         self.assertEqual(len(moves_before.move_line_ids), 1)
         move_line = moves_before.move_line_ids
+        quantity_done = move_line.product_uom_qty
         response = self.service.dispatch(
             "set_destination",
             params={
                 "move_line_id": move_line.id,
                 "barcode": self.free_package.name,
-                "quantity": move_line.product_uom_qty,
+                "quantity": quantity_done,
                 "confirmation": True,
             },
         )
         self.assert_response_set_line_destination(
             response,
             zone_location,
             picking_type,
             move_line,
             message=self.service.msg_store.picking_without_carrier_cannot_pack(
                 move_line.picking_id
             ),
+            qty_done=quantity_done,
         )
 
     def test_set_destination_package_full_qty_ok_carrier_bad_package(self):
         """Scan destination package, carrier on picking, package invalid."""
         zone_location = self.zone_location
         picking_type = self.picking1.picking_type_id
         moves_before = self.picking1.move_lines
         self.assertEqual(len(moves_before), 1)
         self.assertEqual(len(moves_before.move_line_ids), 1)
         move_line = moves_before.move_line_ids
         move_line.picking_id.carrier_id = self.carrier
+        quantity_done = move_line.product_uom_qty
         response = self.service.dispatch(
             "set_destination",
             params={
                 "move_line_id": move_line.id,
                 "barcode": self.free_package.name,
-                "quantity": move_line.product_uom_qty,
+                "quantity": quantity_done,
                 "confirmation": False,
             },
         )
         self.assert_response_set_line_destination(
             response,
             zone_location,
             picking_type,
             move_line,
             message=self.service.msg_store.packaging_invalid_for_carrier(
                 self.free_package.packaging_id, self.carrier
             ),
+            qty_done=quantity_done,
         )
 
     def test_set_destination_package_full_qty_ok_carrier_ok_package(self):
         """Scan destination package, carrier on picking, package valid."""
         zone_location = self.zone_location
         picking_type = self.picking1.picking_type_id
         moves_before = self.picking1.move_lines
```

## odoo/addons/shopfloor/views/shopfloor_menu.xml

### odoo/addons/shopfloor/views/shopfloor_menu.xml

```diff
@@ -32,18 +32,50 @@
           <field name="prepackaged_product_is_possible" invisible="1"/>
           <field name="allow_prepackaged_product"/>
         </group>
         <group name="unload_at_destination" attrs="{'invisible': [('unload_package_at_destination_is_possible', '=', False)]}">
           <field name="unload_package_at_destination_is_possible" invisible="1"/>
           <field name="unload_package_at_destination" attrs="{'readonly': [('pick_pack_same_time', '=', True)]}"/>
         </group>
+        <group name="disable_full_bin_action" attrs="{'invisible': [('disable_full_bin_action_is_possible', '=', False)]}">
+          <field name="disable_full_bin_action_is_possible" invisible="1"/>
+          <field name="disable_full_bin_action"/>
+        </group>
         <group name="multiple_move_single_pack" attrs="{'invisible': [('multiple_move_single_pack_is_possible', '=', False)]}">
           <field name="multiple_move_single_pack_is_possible" invisible="1"/>
           <field name="multiple_move_single_pack" attrs="{'readonly': [('pick_pack_same_time', '=', True)]}"/>
         </group>
+        <group name="get_work" attrs="{'invisible': [('allow_get_work_is_possible', '=', False)]}">
+          <field name="allow_get_work_is_possible" invisible="1"/>
+          <field name="allow_get_work"/>
+        </group>
+        <group name="no_prefill_qty" attrs="{'invisible': [('no_prefill_qty_is_possible', '=', False)]}">
+          <field name="no_prefill_qty_is_possible" invisible="1"/>
+          <field name="no_prefill_qty"/>
+        </group>
+        <group name="show_oneline_package_content" attrs="{'invisible': [('show_oneline_package_content_is_possible', '=', False)]}">
+          <field name="show_oneline_package_content_is_possible" invisible="1"/>
+          <field name="show_oneline_package_content"/>
+        </group>
+        <group name="scan_location_or_pack_first" attrs="{'invisible': [('scan_location_or_pack_first_is_possible', '=', False)]}">
+          <field name="scan_location_or_pack_first_is_possible" invisible="1"/>
+          <field name="scan_location_or_pack_first"/>
+        </group>
+        <group name="auto_post_line" attrs="{'invisible': [('auto_post_line_is_possible', '=', False)]}">
+          <field name="auto_post_line_is_possible" invisible="1"/>
+          <field name="auto_post_line"/>
+        </group>
+        <group name="allow_alternative_destination" attrs="{'invisible': [('allow_alternative_destination_is_possible', '=', False)]}">
+          <field name="allow_alternative_destination_is_possible" invisible="1"/>
+          <field name="allow_alternative_destination"/>
+        </group>
+        <group name="allow_return" attrs="{'invisible': [('allow_return_is_possible', '=', False)]}">
+          <field name="allow_return_is_possible" invisible="1"/>
+          <field name="allow_return"/>
+        </group>
       </group>
     </field>
   </record>
   <record id="shopfloor_menu_search_view" model="ir.ui.view">
     <field name="model">shopfloor.menu</field>
     <field name="inherit_id" ref="shopfloor_base.shopfloor_menu_search_view"/>
     <field name="arch" type="xml">
```

## odoo/addons/shopfloor/views/stock_move_line.xml

### odoo/addons/shopfloor/views/stock_move_line.xml

```diff
@@ -7,11 +7,22 @@
     <field name="arch" type="xml">
       <field name="qty_done" position="after">
         <!-- handy for testing / debugging -->
         <!-- TODO: make them readonly? -->
         <field name="shopfloor_checkout_done" string="SF checkout done" optional="hide" groups="base.group_no_one"/>
         <field name="shopfloor_unloaded" string="SF unloaded" optional="hide" groups="base.group_no_one"/>
         <field name="shopfloor_priority" string="SF Priority" optional="hide" groups="base.group_no_one"/>
+        <field name="shopfloor_user_id" string="SF User" optional="hide" groups="base.group_no_one"/>
+      </field>
+    </field>
+  </record>
+  <record id="view_stock_move_line_operation_tree" model="ir.ui.view">
+    <field name="name">shopfloor stock.move.line.operations.tree</field>
+    <field name="model">stock.move.line</field>
+    <field name="inherit_id" ref="stock.view_stock_move_line_operation_tree"/>
+    <field name="arch" type="xml">
+      <field name="qty_done" position="after">
+        <field name="shopfloor_user_id"/>
       </field>
     </field>
   </record>
 </odoo>
```

## Comparing `odoo14_addon_shopfloor-14.0.2.9.3.dev1.dist-info/METADATA` & `odoo14_addon_shopfloor-14.0.3.0.0.dist-info/METADATA`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: odoo14-addon-shopfloor
-Version: 14.0.2.9.3.dev1
+Version: 14.0.3.0.0
 Summary: manage warehouse operations with barcode scanners
 Home-page: https://github.com/OCA/wms
 Author: Camptocamp, BCIM, Akretion, Odoo Community Association (OCA)
 Author-email: support@odoo-community.org
 License: AGPL-3
 Platform: UNKNOWN
 Classifier: Programming Language :: Python
@@ -17,14 +17,15 @@
 Requires-Dist: odoo14-addon-jsonifier
 Requires-Dist: odoo14-addon-product-manufacturer
 Requires-Dist: odoo14-addon-product-packaging-type
 Requires-Dist: odoo14-addon-shopfloor-base
 Requires-Dist: odoo14-addon-stock-helper
 Requires-Dist: odoo14-addon-stock-picking-completion-info
 Requires-Dist: odoo14-addon-stock-picking-delivery-link
+Requires-Dist: odoo14-addon-stock-picking-progress
 Requires-Dist: odoo14-addon-stock-quant-package-dimension
 Requires-Dist: odoo14-addon-stock-quant-package-product-packaging
 Requires-Dist: odoo14-addon-stock-storage-type
 Requires-Dist: odoo (<14.1dev,>=14.0a)
 
 =========
 Shopfloor
@@ -64,14 +65,17 @@
 * Location Content Transfer
 * Single Pack Transfer
 
 This module provides REST APIs to support the scenarios. It needs a frontend
 to consume the backend APIs and provide screens for users on barcode devices.
 A default front-end application is provided by ``shopfloor_mobile``.
 
+| Note: if you want to enable a new scenario on an existing application, you must trigger the registry sync on the shopfloor.app in a post_init_hook or a post-migrate script.
+| See an example `here <https://github.com/OCA/wms/pull/520/commits/bccdfd445a9bc943998c4848f183a076e8459a98>`_.
+
 **Table of contents**
 
 .. contents::
    :local:
 
 Usage
 =====
@@ -126,14 +130,16 @@
 * Simone Orsi <simahawk@gmail.com>
 * Sébastien Alix <sebastien.alix@camptocamp.com>
 * Alexandre Fayolle <alexandre.fayolle@camptocamp.com>
 * Benoit Guillot <benoit.guillot@akretion.com>
 * Thierry Ducrest <thierry.ducrest@camptocamp.com>
 * Raphaël Reverdy <raphael.reverdy@akretion.com>
 * Jacques-Etienne Baudoux <je@bcim.be>
+* Juan Miguel Sánchez Arce <juan.sanchez@camptocamp.com>
+* Michael Tietz (MT Software) <mtietz@mt-software.de>
 
 Design
 ~~~~~~
 
 * Joël Grand-Guillaume <joel.grandguillaume@camptocamp.com>
 * Jacques-Etienne Baudoux <je@bcim.be>
```

## Comparing `odoo14_addon_shopfloor-14.0.2.9.3.dev1.dist-info/RECORD` & `odoo14_addon_shopfloor-14.0.3.0.0.dist-info/RECORD`

 * *Files 4% similar despite different names*

```diff
@@ -1,166 +1,186 @@
-odoo/addons/shopfloor/README.rst,sha256=G9ky7P-HJ_d5rYPs5NBaNQjFye0gGdKvqEdGeOvix5M,4649
+odoo/addons/shopfloor/README.rst,sha256=IXipUCBmeP0Nx44oKpWODULvljMDxymqsiFE0JrMUkM,5050
 odoo/addons/shopfloor/__init__.py,sha256=ke3RmZ7XkX-lz4S8NHAxNIEJ5_Nvj5bjBAqD-W-q73c,91
-odoo/addons/shopfloor/__manifest__.py,sha256=nhHzi-sUN-6sm8Zl0B7-WpjoASseCsfihkpVDexm2Yc,2180
-odoo/addons/shopfloor/utils.py,sha256=XMNru4OMSWQ7sbuSHE4vD0m99lM3-qgZdDT36lz6J94,253
-odoo/addons/shopfloor/actions/__init__.py,sha256=YuzJQGOJBRSlxI6QGE-r67IZeoVnKHhIq5SxoeD7SIY,370
+odoo/addons/shopfloor/__manifest__.py,sha256=lqlFdqyvcw86If7WLe3MfKRW33bWzkIfYWtmraeZ8BQ,2214
+odoo/addons/shopfloor/exceptions.py,sha256=81KpIGVkuYRhA0cIuml4pg4G3izqkAAhLqoXZbUd4X8,197
+odoo/addons/shopfloor/utils.py,sha256=Be7J8Tu7ivOW4lpe8IjKxwqfTwfmK-ZkeFEavoYIIF4,375
+odoo/addons/shopfloor/actions/__init__.py,sha256=_yTf-NtaJmSylBJIoJJvKNYEI-wlqpyRw-S5eJRRzEM,400
 odoo/addons/shopfloor/actions/change_package_lot.py,sha256=A2FPV5wdTO2Bo90mmgaGTemyZ-GHy9hOwFWpw6BOLzE,9413
 odoo/addons/shopfloor/actions/completion_info.py,sha256=WqU436iPXaxHzOfGT1Eh8GnpiCBbyaAB33cJ4jdGt6A,1438
-odoo/addons/shopfloor/actions/data.py,sha256=GRMkBjUpBahDc7uyaeOt6cgtMOT4NgzC_qIhBoreL-g,9216
-odoo/addons/shopfloor/actions/data_detail.py,sha256=q2Wijr-vNTCy8sjKMcytKLp-_qwr1s1k-vao7h2HizM,5214
+odoo/addons/shopfloor/actions/data.py,sha256=ATvk0ZscTrZK_ViPwVG3btjDMKjCao_hMAk-I5u1IWE,11435
+odoo/addons/shopfloor/actions/data_detail.py,sha256=ROFFq17rXaHz-18_rpDmY9Q-csQ0vuU5ye7PjEvh1n4,5505
 odoo/addons/shopfloor/actions/inventory.py,sha256=yWDWLOgCD9uQ8n8u5EtjrqjxeW9JrFNvuJMAdRnDWAM,5275
 odoo/addons/shopfloor/actions/location_content_transfer_sorter.py,sha256=xpzea-w4zFrmpudQK3omRpZVhJdEIVQLXnuImkaZf5A,3110
-odoo/addons/shopfloor/actions/message.py,sha256=GSLTbBJI46lHOo_5HKgTiJADLolgW4T1N4LvzT_4MD8,20435
-odoo/addons/shopfloor/actions/move_line_search.py,sha256=VyGQh2r2oawig9n-uFC-w3soqJv18xuYuZIj9aMlddc,3802
+odoo/addons/shopfloor/actions/message.py,sha256=pqYTOjHbFIkMY6UyXXmleMuS7LROnUK60USrfDRzzMg,26106
+odoo/addons/shopfloor/actions/move_line_search.py,sha256=IOoHULdBLy75cFCpY_wl4r5YOU2q8J8hVnFMd1RU_jY,4089
 odoo/addons/shopfloor/actions/packaging.py,sha256=wbGBN99_zbEYSTXbA5_q9OdvFWzPugwaxj7LvaQaG1M,2046
 odoo/addons/shopfloor/actions/savepoint.py,sha256=VFo2llY-HdYHxO__0cms7qWVJJwCjmadG3KA5UX9Gls,1232
-odoo/addons/shopfloor/actions/schema.py,sha256=TZW0uie9-WIVCrYxGcsTu-i2oUT0HvmHHj4tHCUy5ls,7133
+odoo/addons/shopfloor/actions/schema.py,sha256=16x6wc4CnGTe7O5QoFXLfz3h-MyhRSXccxvJKmMoEag,8025
 odoo/addons/shopfloor/actions/schema_detail.py,sha256=QM8XZTbWG7lfhHrnkBeqqAGaQFgRS_COW3rZ4tIDq54,3195
-odoo/addons/shopfloor/actions/search.py,sha256=wpVzODn-VrGGve1h3WgtGZkzegNTkOTTZ62zfSCMAAM,2776
-odoo/addons/shopfloor/actions/stock.py,sha256=eAkR83jsMZ64GhhyzrojDSKWn2gConZBfLRiOsuAShk,4279
+odoo/addons/shopfloor/actions/search.py,sha256=Y3xB1ACT9SQclStfANPP41mMOX8Yrk9_NKoDVjgS_AQ,6443
+odoo/addons/shopfloor/actions/stock.py,sha256=1EiuHjyIuUFEtXPUylZ44m7TE3v-0SFw4Q_veEdZ7SM,10142
+odoo/addons/shopfloor/actions/stock_unreserve.py,sha256=LoFd9hzeNlTQEn0-FN3N4xWLSo1uuiw5E394OEPHm-Y,2720
 odoo/addons/shopfloor/components/__init__.py,sha256=a3ox1WOD1JhrQUrYMRn-yDJI0Vvc7ciKdmXuZB29ToU,173
-odoo/addons/shopfloor/components/scan_handler_location.py,sha256=SxsPkJ7pdwj7bOgzdTAt_QMpH3i1ZKChC-rz4bs5b0I,747
-odoo/addons/shopfloor/components/scan_handler_lot.py,sha256=LrbaMLzY1hUyRcjyIdN8prAMUoyEk3QGPci7Zq3sZVo,723
-odoo/addons/shopfloor/components/scan_handler_package.py,sha256=Y3pUxK86rKsiU6fBUlw23uoilKBqERgJ23FT9HIj6R8,746
-odoo/addons/shopfloor/components/scan_handler_product.py,sha256=pWg_oy9Tud6L5nrO-wN0g4IunmXVnunpUtDHiof741M,742
-odoo/addons/shopfloor/components/scan_handler_transfer.py,sha256=PWRLNanHivQKgKOf0wwf2sJxCArWCZXdp7UpVTB81tg,743
-odoo/addons/shopfloor/data/shopfloor_scenario_data.xml,sha256=nV72nadQ6X_pi2RAy3UAuQlt7kluQowar0MEaCn7ifA,1958
+odoo/addons/shopfloor/components/scan_handler_location.py,sha256=LImiaG4L4xBKUFWZLSnJV-eSCvj_NCDCM5GqZSnsPmE,825
+odoo/addons/shopfloor/components/scan_handler_lot.py,sha256=Rouu5MWJBrhluxt5CTnsBigdDKI607dfUqkN3QUSvxk,807
+odoo/addons/shopfloor/components/scan_handler_package.py,sha256=INbzbxzg07F4vW8DM_mjtf2dkRN1pbiBuo_xjsId9yk,829
+odoo/addons/shopfloor/components/scan_handler_product.py,sha256=TTKVltMgQba01nSE2vx2zaEMgYg3c5_hVwJXT0T9rug,833
+odoo/addons/shopfloor/components/scan_handler_transfer.py,sha256=uHtI-3T4g6ZEpoJJQYZhbJQo3bTXTnGnEs4lC0iluKc,820
+odoo/addons/shopfloor/data/shopfloor_scenario_data.xml,sha256=XoRuenOMt9K-CRNeMRIL_O-nEgk_oAuC2lzaBoIec8U,2306
 odoo/addons/shopfloor/demo/shopfloor_app_demo.xml,sha256=tqAzRijIm0KCfyIuaKH8wYIUDJR_uNQ_i4HLX5wPSgY,420
 odoo/addons/shopfloor/demo/shopfloor_menu_demo.xml,sha256=5vvD0UDNwGcH6d3cTuAnOApCB8VlErOKtnfy8_n2yWw,2938
 odoo/addons/shopfloor/demo/shopfloor_profile_demo.xml,sha256=pcz9A6s2-HVtur8_GZXoiAnVvlCZzlLXSNyQ53KEDlM,253
 odoo/addons/shopfloor/demo/stock_picking_type_demo.xml,sha256=PNwLJnPyGZVft4JNTwAL4nw_QvwkEsPX7CCxaIMVqjQ,4931
+odoo/addons/shopfloor/docs/checkout_diag_seq.plantuml,sha256=9icFiogMZsUDAiTZ9eVLyhFTLpwsIWCnfQ8RNdz4VwM,1725
+odoo/addons/shopfloor/docs/checkout_diag_seq.png,sha256=_TWFk5BYaH-bD95yeXNlwS6urclhsUYyA4u5t9mDSPA,92254
 odoo/addons/shopfloor/docs/cluster_picking_diag_seq.plantuml,sha256=n7sLyBK5FrUXcQQej7ofrXylJ_nWjiUqcrNjuo531SU,7030
 odoo/addons/shopfloor/docs/cluster_picking_diag_seq.png,sha256=VTqyD3lL2iFZGPy7STqshi_Jse0s3Z7dHcY905ue-3Q,279898
 odoo/addons/shopfloor/docs/delivery_diag_seq.plantuml,sha256=q5YxWFPa1EQT1GQ54owkTqiTItw9_7Lp_f8Grkm_BrY,1734
 odoo/addons/shopfloor/docs/delivery_diag_seq.png,sha256=j2nTu8QQu_QFe7wlbT4TvF3erk2470T5gFOrxWJahC4,73563
+odoo/addons/shopfloor/docs/location_content_transfer_diag_seq.plantuml,sha256=biXFZwPNl6Oh9-_Pu2LmDwBXvHuL0SYatqEdXb3QUUE,2372
+odoo/addons/shopfloor/docs/location_content_transfer_diag_seq.png,sha256=qWx1VJo84GFOXmS3iuyHpGivLYFEwy7MDAKiCEL0nR0,117002
 odoo/addons/shopfloor/docs/oca_logo.png,sha256=tuADeCURe0ZTpQn-bnsepQdCrUJi4yrNhkQ1eXd4eO4,3297
 odoo/addons/shopfloor/docs/single_pack_transfer_diag_seq.plantuml,sha256=XEYLKSNhzXDTGpPEI6rjKspjImEwzJfYXKoLsIYrrOA,910
 odoo/addons/shopfloor/docs/single_pack_transfer_diag_seq.png,sha256=g2EhfJ64Augy5e5ziIEs0a5ezYZzzUUecimYXzxRI6w,29489
 odoo/addons/shopfloor/docs/zone_picking_diag_seq.plantuml,sha256=Bu0NkP2HwV24IgTHEYV5uwMikk00vOEAGxK53OG9p9s,3527
 odoo/addons/shopfloor/docs/zone_picking_diag_seq.png,sha256=_qGnbfsShydA3Xjefaurt45fzlgJ8upf11B9DRv9OB0,185581
-odoo/addons/shopfloor/i18n/ca.po,sha256=rrhUn3RmWdOBUnkRvzcW8nP03Yv_RywQjFuMalnzQX8,44327
-odoo/addons/shopfloor/i18n/es_AR.po,sha256=d7ACtRSd0_qdODWPQiI8xdWBhe0gjgL6G4ZfBGDPezM,60056
-odoo/addons/shopfloor/i18n/pt_BR.po,sha256=NixtVbHHzn8bLmTXivhkUlA2eIXQaHNKEFZRHD3imBc,43118
-odoo/addons/shopfloor/i18n/shopfloor.pot,sha256=t2K8wAEHepj5fPMlCZk3XXFuhwGFAix6fUfk2z8YB5w,43111
+odoo/addons/shopfloor/i18n/ca.po,sha256=ICRouEeXkaaSS969goVe23fEw1i6PPnFzz_OXTOMD6o,52155
+odoo/addons/shopfloor/i18n/de.po,sha256=4XZeAohYtF44QVsMgJQAXULEs-u7Q1KpZ8zmegdz_iM,50944
+odoo/addons/shopfloor/i18n/es_AR.po,sha256=YoQFbZO83nW7z6clncfzaA8HNS-ndChEIcLcI0B1LGQ,71001
+odoo/addons/shopfloor/i18n/pt_BR.po,sha256=pBZ8fYTbKKICbVXwJo_o3bLLB5gwG-xSVMJsf_R51Ow,50946
+odoo/addons/shopfloor/i18n/shopfloor.pot,sha256=7emBHklq_9qW6zh1hLv1DdyuS8gYQCEyNOjdj-vaaas,52151
 odoo/addons/shopfloor/migrations/14.0.1.0.0/pre-migration.py,sha256=_6IaItDL6r9RcikiD1hBMmzmVzk0BAYYRm_K-3Ok6k0,409
 odoo/addons/shopfloor/migrations/14.0.2.0.0/post-migration.py,sha256=UqE3nn31seQoXs3duSMBDiWXSnwfV9drTmdacR9-kY4,1243
 odoo/addons/shopfloor/migrations/14.0.2.3.0/pre-migration.py,sha256=jmdADHk2VXmapzipaITsilmZuVW5xqttprwLPoOV4H4,616
 odoo/addons/shopfloor/models/__init__.py,sha256=fukHMPiALi11PBmoUjjFSnNQ2e3rd0tojFhstB4PSOY,398
 odoo/addons/shopfloor/models/priority_postpone_mixin.py,sha256=AEu_K9mul_SmjyLK8NLCycRn3BLzirUqNOaf0RVYEpE,1503
 odoo/addons/shopfloor/models/shopfloor_app.py,sha256=ZfVahQYm0jzyeH7EtlOOhxYUif9OwcHIsyZAbQxEeXA,292
-odoo/addons/shopfloor/models/shopfloor_menu.py,sha256=vg7njdwA7i0F7WjPkYUBz3VoQaY1QB_lzBpMRDgwzqQ,12249
+odoo/addons/shopfloor/models/shopfloor_menu.py,sha256=Coup3YwF-x_g3mcS9lt-VTa8vmy4VQq9ASK0l42TH6c,16868
 odoo/addons/shopfloor/models/stock_inventory.py,sha256=LKfQdSuKrskY5NtnrN1NFmKRuMSYbb0AVg_IlXVgph0,808
 odoo/addons/shopfloor/models/stock_location.py,sha256=0BPOKfoWq3yCeIM3B6V6qbDUlZNcAL9JjyIfqMteSyo,3141
-odoo/addons/shopfloor/models/stock_move.py,sha256=Pm3FiOi4yf8iIb6mcB30tepBBF7N4-n6Wh5O_K1e7jA,4749
-odoo/addons/shopfloor/models/stock_move_line.py,sha256=EjXfSERQn18HiA9ZaG7lGoMeNj-MPZSiAth6k4lqDLY,12520
+odoo/addons/shopfloor/models/stock_move.py,sha256=1eXwaglqHXtgAF30pgdPhbErwxgi6iNYUJX5zFljFMo,4749
+odoo/addons/shopfloor/models/stock_move_line.py,sha256=2zqGsevoaDI5F-lB3n5GFBKpxj1QJpq0hU_AwFqTmDo,12818
 odoo/addons/shopfloor/models/stock_package_level.py,sha256=IQhYiSj41LoZO5xZ1mwu8V8eiwROQrzjkpyrwUOadj4,2150
 odoo/addons/shopfloor/models/stock_picking.py,sha256=vtYW3zSU0nED7ohNjhgf0_MEl9iEKgR879L8miFLzBQ,4868
 odoo/addons/shopfloor/models/stock_picking_batch.py,sha256=OTjeRqFlUeA7vuaGH6q-oy2z_lKPy4HUveSz5FlX1Ws,1466
 odoo/addons/shopfloor/models/stock_picking_type.py,sha256=qn_wSGdSDvkHigO9VOZ819RfWj4MDjSYnlDPXV2huc0,935
 odoo/addons/shopfloor/models/stock_quant.py,sha256=L_MGzGfXIEtYbUimvnRYLoq38m3gedXeMMoBvbSJQDE,872
 odoo/addons/shopfloor/models/stock_quant_package.py,sha256=CcjAq4pR5BuY0ns_zvtrhH7VPGso5Lca1JlcTNzEpFQ,3579
-odoo/addons/shopfloor/readme/CONTRIBUTORS.rst,sha256=hH94WDKPNKXmJhQWFElQzc3_abZT0j8XFjzLSsjjr7Q,496
+odoo/addons/shopfloor/readme/CONTRIBUTORS.rst,sha256=30__5n7ENO91BJvIrw7MwQLbXOuTg8doPy-JDIId8I8,608
 odoo/addons/shopfloor/readme/CREDITS.rst,sha256=gvM_pe6NW3J9LsH6xxFxvRsY1AY8T8fVLeRzce2RKhY,65
-odoo/addons/shopfloor/readme/DESCRIPTION.rst,sha256=n0hq8hVPUpQRlZoUxWnrl9udDvrn8IeOUXNlcF7B7EE,485
+odoo/addons/shopfloor/readme/DESCRIPTION.rst,sha256=r3fh_VmDmCCt4TbqOffQ9IMY2NrrfshoDnj_QKwHgeA,774
 odoo/addons/shopfloor/readme/HISTORY.rst,sha256=Ibf54quZVYNg74R-oWzny0XeMee1wp8T4Og1gaGo3OQ,47
 odoo/addons/shopfloor/readme/ROADMAP.rst,sha256=jIuyexuxAbyDWBPfoHzWU57KLUto6z56N0eLQwcKOPw,179
 odoo/addons/shopfloor/readme/USAGE.rst,sha256=6Of9b6ec7gH1SKhdpBIaavsON0JWBFAzhb8KNz7Nmhc,308
 odoo/addons/shopfloor/security/groups.xml,sha256=hdLqRUZM_4RQnleinRYhxDxqW4VOI5li4oTsB7m96LQ,578
 odoo/addons/shopfloor/services/__init__.py,sha256=4lhF0VNx8QosVEZj9QJYgv6oWD0kl9FX80rL5WMrXf4,303
-odoo/addons/shopfloor/services/checkout.py,sha256=DP0oX3TIowfOkWhAGk_Qv8wdBYtPNFRpILKyvkJPxWg,60460
-odoo/addons/shopfloor/services/cluster_picking.py,sha256=fE8FIOKJpyumynsyBzDxWJxixWWBzGz6W9nh5mEKD_k,60202
-odoo/addons/shopfloor/services/delivery.py,sha256=UUvraCmz2GQk-FqiiPckXkNa3_srhbJekbQWzyG47z0,31453
-odoo/addons/shopfloor/services/location_content_transfer.py,sha256=muW2PPa4lfPUbUFOjjAZp6XdsUkgqx3a74BsPkALCbM,46357
+odoo/addons/shopfloor/services/checkout.py,sha256=fcl8eVN8LnKrp9U0XkrXU2_iWXv39Qxu8oq0aLsnNbI,69715
+odoo/addons/shopfloor/services/cluster_picking.py,sha256=mIXnQmlruhTwscJFROw1aC_hoekZ5cIMlFPMc7B71yM,67251
+odoo/addons/shopfloor/services/delivery.py,sha256=LNmvu2tWTQFOb7GCgvG_MUe7CI7mT-I5jKfij1deCBM,32632
+odoo/addons/shopfloor/services/location_content_transfer.py,sha256=_FNM9o1gv2lZbeQ62pmP2xprXf94DGGhLAhOz2gIhMQ,49967
 odoo/addons/shopfloor/services/menu.py,sha256=ByVZo7Hn9nnrfkFI8A7bUfdlqHh0B__xLD4_PvUBFR0,2225
 odoo/addons/shopfloor/services/picking_batch.py,sha256=w51R5HHkQxCHle72k28VetXKfIRRh5GTaEXv6mhikvQ,4649
-odoo/addons/shopfloor/services/service.py,sha256=8oV07IwB5BgjbpnEirhsmzSJ8-6zni2iIfqxAUZ2_3E,4157
-odoo/addons/shopfloor/services/single_pack_transfer.py,sha256=VHFOF39GT0zyCi8sw9IDbKmtp1gDtpz5iqsGS12gcac,15020
-odoo/addons/shopfloor/services/zone_picking.py,sha256=ywrg4c9Lq-g2dbKadZEVDc37VbEGft4zp-BqSk2sCqg,69066
+odoo/addons/shopfloor/services/service.py,sha256=_uuHCHDziPc_yNl9IfQWM4unumg4Tb3BCjfcAjoYyz0,4179
+odoo/addons/shopfloor/services/single_pack_transfer.py,sha256=RukqMj39kIMMwwt52HRgWSS1BsKHHN1ZV0554IATn9k,15096
+odoo/addons/shopfloor/services/zone_picking.py,sha256=wGkVys_ozLFgZGy2XG2WASsPGmv5BvDUXBQFvIqha4s,79620
 odoo/addons/shopfloor/services/forms/__init__.py,sha256=nxwJdKX47hb56ERf4Qb3UE5dkdsHCbkaXMAXs4XMAd8,27
 odoo/addons/shopfloor/services/forms/picking_form.py,sha256=F15G5yw78Pd1WgPjMz00-K1JyGaTdfdvVYzG4Dubpqk,2626
 odoo/addons/shopfloor/static/description/icon.png,sha256=6xBPJauaFOF0KDHfHgQopSc28kKvxMaeoQFQWZtfZDo,9455
-odoo/addons/shopfloor/static/description/index.html,sha256=GLGWZhuWV2k2ffk-hJAbDlXhqR7fj5ONEQK20Mk8Vfc,16036
-odoo/addons/shopfloor/tests/__init__.py,sha256=ziay5k575LcYr529p7eznLx5YqO0Kn8jPgmdOhqPMr8,3036
-odoo/addons/shopfloor/tests/common.py,sha256=91AyIkpIBWKy-_HswKF8gdLuxvktu_b2rTlt_lPFB7w,11192
+odoo/addons/shopfloor/static/description/index.html,sha256=cf_EZhTVNO3A5MoD7hXxJdqlEXRNRzgJh8HvdqQEbkk,16736
+odoo/addons/shopfloor/tests/__init__.py,sha256=l9JPb4DTmbnAPrOFJJZZHJ6Q9al-Xqnzj8iFEEatcac,3722
+odoo/addons/shopfloor/tests/common.py,sha256=VBLLGCGUdxCam2mgEXrrN_U7M20Z4SeoWnWEevjOqKk,11332
 odoo/addons/shopfloor/tests/models.py,sha256=YaM1X1DmGh9WV-ygb337qncrxoJGEbYyBsFumaEotk8,941
 odoo/addons/shopfloor/tests/test_actions_change_package_lot.py,sha256=L7Y1D1_5dgjYjk1MCdVQz01SoeQOlCTwSR_FwdItXvY,47256
-odoo/addons/shopfloor/tests/test_actions_data.py,sha256=fbEVutb6mUSL2CIR7Oh8j3vNnZILwNuULoJwXVeZq6M,12570
+odoo/addons/shopfloor/tests/test_actions_data.py,sha256=JM2TNExW_IEDM6T_xBE4wTXJrTIHHGdyh-WBMyq1Nxw,14616
 odoo/addons/shopfloor/tests/test_actions_data_base.py,sha256=NRr5oSWZ5HunkOFpGk4Rh7OC0UEbuKWl3-kUuUtmUs8,8282
-odoo/addons/shopfloor/tests/test_actions_data_detail.py,sha256=3kCAQI43IWx130bI5yPPhQRkcN_Zk8z8sna4z3zXAt0,10952
-odoo/addons/shopfloor/tests/test_actions_search.py,sha256=xtafd-3agtd6FRZcjlxW4H5dVYVWAL7lbAs96DLw0Nc,4057
-odoo/addons/shopfloor/tests/test_checkout_base.py,sha256=tUCOfeXxqKI_390We1vyk6pdUSbJcqotrImVAsrfakg,1462
-odoo/addons/shopfloor/tests/test_checkout_cancel_line.py,sha256=XOz1Y2EWXEZLGwUB06qgMRwhjWHTD0IxZcoq_ITPvio,5361
+odoo/addons/shopfloor/tests/test_actions_data_detail.py,sha256=JD3R59xhxgZXcfFObWnUlMbK58Rd39gMTeB9z1ZanQU,12723
+odoo/addons/shopfloor/tests/test_actions_search.py,sha256=Ls_FkSLfqEkuhCh4P3LSItO5yDUfyh3aPPFAHrA3PME,9374
+odoo/addons/shopfloor/tests/test_actions_stock.py,sha256=lHv9_JYQLZq_llJhdU5SeUj8BQvQLxTvpU5N0hWG1lM,1907
+odoo/addons/shopfloor/tests/test_checkout_auto_post.py,sha256=zAyIlZffWcLAfD8wLZIAyM2YXuyqjos48jtdI86XNKw,3385
+odoo/addons/shopfloor/tests/test_checkout_base.py,sha256=FIHJSPVUDHAeRV7bH8BMyHmGkavoUEQEOTnElxD36ps,2491
+odoo/addons/shopfloor/tests/test_checkout_cancel_line.py,sha256=lf3IrZbWsG4E26DEEXSEqmRzVOwQxAPr8rtYsO0qQoI,5339
 odoo/addons/shopfloor/tests/test_checkout_change_packaging.py,sha256=j7gaTOyKvi9deQ9G_nRH7XAbphma8fi_RQHiQNtiDy8,6015
-odoo/addons/shopfloor/tests/test_checkout_done.py,sha256=hW0UQA_GAZxSTD3LmPZD97TMpmN7ZbIDvuTaEDeXaa4,4469
+odoo/addons/shopfloor/tests/test_checkout_done.py,sha256=nw4bb2u9K4bS8vE1WkF1UNdFRQQSKZinnZyg14rHjbM,5074
 odoo/addons/shopfloor/tests/test_checkout_list_delivery_packaging.py,sha256=xzXkGAojpTEmftmqOPe0sFPyYJ1OviULiBc3D4U6Ge8,4425
-odoo/addons/shopfloor/tests/test_checkout_list_package.py,sha256=aanasokhvTpIxP-a48ppq-FFBf9-sc4SeeCa-MEJKws,9818
-odoo/addons/shopfloor/tests/test_checkout_new_package.py,sha256=j6r-NSGCYZSu4CwA_Q-a_iExplnHbur2JiPcNt-Q1is,2443
-odoo/addons/shopfloor/tests/test_checkout_no_package.py,sha256=q2jypSBEJV5M9qplDjImgFb5_Drm7I_EfhX0YaiEB1g,2941
-odoo/addons/shopfloor/tests/test_checkout_scan.py,sha256=zmY-HNY0blnyKzSRV2-SnawOVAfHFWvF6bkx21qgsPI,7439
-odoo/addons/shopfloor/tests/test_checkout_scan_line.py,sha256=7gz-wr_D5KROpGTOIiJPFIMCvI95SDfX4jEcArL28Bs,12651
-odoo/addons/shopfloor/tests/test_checkout_scan_line_base.py,sha256=mPl7zjf4qE6pkbTHK0BGWDhRuCeQTWQi-BKYZJfa55c,854
-odoo/addons/shopfloor/tests/test_checkout_scan_package_action.py,sha256=uzx3yl5ioj5fLhNEaSgrV8xT0keIC0APrbnyMhFXIII,16936
-odoo/addons/shopfloor/tests/test_checkout_select.py,sha256=ugBS0_Br0lqHCHvjl1WwLCtjIvK3XTzU07SGF8jr-d4,2792
-odoo/addons/shopfloor/tests/test_checkout_select_line.py,sha256=jwHb8GN2OJzDj88XMc-uU0gG832GE81L0-IdTfb6h1U,4983
-odoo/addons/shopfloor/tests/test_checkout_select_package_base.py,sha256=n9BSKxxIGR62eGnj7DL8L_VLyV5An5k2FWk8m9LGEyE,2257
-odoo/addons/shopfloor/tests/test_checkout_set_qty.py,sha256=o_3sGXj7rOdz8TLaJzuZFa-W9Jm7byRON1Htpvi23pc,9541
+odoo/addons/shopfloor/tests/test_checkout_list_package.py,sha256=z6KeUrwu9O2BYl-B8jfx_DmvvgSJzzQWFJAQF4GLYnc,12293
+odoo/addons/shopfloor/tests/test_checkout_new_package.py,sha256=vdXvOLLNMRis1UBUgJjfG1qrUTn-Ui48-qhesG-qpSw,3415
+odoo/addons/shopfloor/tests/test_checkout_no_package.py,sha256=9poSM7e6w2_9o8q8dnVDxzKTKiHJjBbSREj03ZkJgy4,3609
+odoo/addons/shopfloor/tests/test_checkout_scan.py,sha256=rKDc-9q3pxAnePGrxoq-hnPaQYom9b_-aY938YCn-Cc,7428
+odoo/addons/shopfloor/tests/test_checkout_scan_line.py,sha256=ByIJi5oLRdFKYd1rwrg_1TVQ8Z41ZGirNMPi6xBSbQQ,15354
+odoo/addons/shopfloor/tests/test_checkout_scan_line_base.py,sha256=QsNHemN4xwgxuS604qIH85wZpTxjhWWu5c7RaupDbag,976
+odoo/addons/shopfloor/tests/test_checkout_scan_line_no_prefill_qty.py,sha256=wItpicHpSmfsS2qXqrMyiSW40gTAt88Z9vTMotfIoKA,3895
+odoo/addons/shopfloor/tests/test_checkout_scan_package_action.py,sha256=BpFkVLC6XNYABc3XAy5QnyN_NK2JX1FqyxfUYNBTPrA,16925
+odoo/addons/shopfloor/tests/test_checkout_scan_package_action_no_prefill_qty.py,sha256=_cdwBYwUxHmHTrS_ETWNStyz4h1qZ8jB2Rvm3MKFPiQ,3773
+odoo/addons/shopfloor/tests/test_checkout_select.py,sha256=S96TbOiCk3Vi27NaWv_bveE08El37hm_H4lXYOV_u4c,2781
+odoo/addons/shopfloor/tests/test_checkout_select_line.py,sha256=z2qRotJcwGmwlTc7ieGtvXle_6MD1UOGXyqO5f2tFNE,4972
+odoo/addons/shopfloor/tests/test_checkout_select_package_base.py,sha256=rJpX1t_pX1b-xli1sGrKjkOYc1iq9u16sq_hOV5--nE,2392
+odoo/addons/shopfloor/tests/test_checkout_set_qty.py,sha256=k7koh7u94naRiLhNuiWSe6xuVInzS-k3t22ra4HXiYo,9523
 odoo/addons/shopfloor/tests/test_checkout_summary.py,sha256=upbWet7msZk7yuXd7NmIyMw94X39oAXGa1gf43X3K2s,2312
-odoo/addons/shopfloor/tests/test_cluster_picking_base.py,sha256=cWqXrv5D5CJeVcvUpyigO1xCCIJ1gLdSPi6s734rEN4,2736
+odoo/addons/shopfloor/tests/test_cluster_picking_base.py,sha256=nHcd-SE0qD743N5h3lZVIwoHOAe03iuXlAWFW7PC2oo,2908
 odoo/addons/shopfloor/tests/test_cluster_picking_batch.py,sha256=L9Q5Zlx_CV9AB3aA-zfyVn9_aEQy52RO1A05e1DmRvo,4038
-odoo/addons/shopfloor/tests/test_cluster_picking_change_pack_lot.py,sha256=hKuT8oYmiD9h36YheiQHJyIU5FOQX2H1XiwaKOZZ3fQ,4079
+odoo/addons/shopfloor/tests/test_cluster_picking_change_pack_lot.py,sha256=_wD11ibqy1FKi7QLm8K_x2_b1NaEQ_pWYIU66S1UZZc,4122
 odoo/addons/shopfloor/tests/test_cluster_picking_is_zero.py,sha256=La3V3lVQCx7DwglAgt9pul4MWguLauh4LmDJlm6noNU,3608
-odoo/addons/shopfloor/tests/test_cluster_picking_scan_destination.py,sha256=EAqAFoKlBncHG8yNV_P6Ie6I6eLBV-GV0UBJ9tbNPZ4,14241
-odoo/addons/shopfloor/tests/test_cluster_picking_scan_line.py,sha256=p4-6yKFbTQEs8Ye78cOsXd9Jgje23j2HEwQ5MN9D-W4,16122
-odoo/addons/shopfloor/tests/test_cluster_picking_select.py,sha256=LS8rsi6DIPFecWivBTUcnDWwLu_vRJiYkeAYd7FOlZM,15156
+odoo/addons/shopfloor/tests/test_cluster_picking_scan_destination.py,sha256=ktIn2iBtCFdPNmETueV42yhumbzSMw36VXbb_RGYSb8,14336
+odoo/addons/shopfloor/tests/test_cluster_picking_scan_destination_no_prefill_qty.py,sha256=SPj-hfHderzVr9J2TDpmS8SXRLgp_5jZyFfW_zjQoSs,4237
+odoo/addons/shopfloor/tests/test_cluster_picking_scan_line.py,sha256=xo1HHM7kkG7Y9bOhAPy38lyIKnuzfPtpAGHUyknr3v0,15443
+odoo/addons/shopfloor/tests/test_cluster_picking_scan_line_location_or_pack_first.py,sha256=ipiX6Dn0wsbm_70YbbX6YgPVvkQX9DLAcgjT0cqign4,4406
+odoo/addons/shopfloor/tests/test_cluster_picking_scan_line_no_prefill_qty.py,sha256=dMYEB_KFno60Axby6TpRXrHlG9Fqsh57OUYFLbfKpjg,2904
+odoo/addons/shopfloor/tests/test_cluster_picking_select.py,sha256=M-ISzR8Fv5uQOWeh4ckVbvq7onULDG6Q9x7bdpI5Eyw,15208
 odoo/addons/shopfloor/tests/test_cluster_picking_skip.py,sha256=6rItlecVJb_E864a9FHF04bzQ46TIkNm9MoviH9fUpY,3540
 odoo/addons/shopfloor/tests/test_cluster_picking_stock_issue.py,sha256=OIcz5lqZKjDyj55umjMmP1ITeBd8kdNWyydeer27oaE,17018
 odoo/addons/shopfloor/tests/test_cluster_picking_unload.py,sha256=tvDk_HUIwsmt-aOGVE2Niyq8nRfsORy7vjMmqLhF9wU,35857
-odoo/addons/shopfloor/tests/test_delivery_base.py,sha256=PHE8SQpM-9beDiAOkGRmWPPk9nsSJXonEc839jB-mQA,4269
+odoo/addons/shopfloor/tests/test_delivery_base.py,sha256=zsMP9_ekcW6MU0WxpmQMhAkpsCC57k2YGy587BRoJjk,4966
 odoo/addons/shopfloor/tests/test_delivery_done.py,sha256=5gjGYlfa4vwMWomrhYyZJkJXiQHzqoUn4s5T6JHtagU,4184
 odoo/addons/shopfloor/tests/test_delivery_list_stock_picking.py,sha256=Cf-Xz7m4XOoMeNGqEol-Ur4WLnN7VzEK1stsHybJG_Y,1637
 odoo/addons/shopfloor/tests/test_delivery_reset_qty_done_line.py,sha256=Aw1zIS8H_LBX-vSncVm7yiJrENNS6m1fZt22zdxuvUw,4749
 odoo/addons/shopfloor/tests/test_delivery_reset_qty_done_pack.py,sha256=RXWnu2mTmJj8J4MtiBiRClzMcS-RGkQrPVGNQPITEIw,4298
-odoo/addons/shopfloor/tests/test_delivery_scan_deliver.py,sha256=Drq2tDEPz-ZnR-jYJqMWUbYWydMVvM2cJI3pMAJ9qWQ,14969
+odoo/addons/shopfloor/tests/test_delivery_scan_deliver.py,sha256=IEVfyU1RiPe6fWNcXa3v7wgApQ0QeWzTIx9Ch-hU0yk,23213
 odoo/addons/shopfloor/tests/test_delivery_select.py,sha256=BNxfCsCWgfTMxVpkv7ckoRhszP9kzKQhz3In4unfovk,1262
 odoo/addons/shopfloor/tests/test_delivery_set_qty_done_line.py,sha256=3_4F-x4NPPsO1rmZgqpQAHCrjKl2zCMUyE83Ynhwwo8,3463
 odoo/addons/shopfloor/tests/test_delivery_set_qty_done_pack.py,sha256=yj47pbSpAvWojp4lffRiOQIfbZxFahfYhBbeZcLK8sg,5359
-odoo/addons/shopfloor/tests/test_delivery_sublocation.py,sha256=wgfesdwi8MKQnK_zJ3RhCRraJezsxTbwKvIMwLnr-o8,6237
-odoo/addons/shopfloor/tests/test_location_content_transfer_base.py,sha256=KqIZeys5h1M2NxvGYWOtrMVgrkSTqIbSNUkzqfhNNtA,4573
+odoo/addons/shopfloor/tests/test_delivery_sublocation.py,sha256=_uOUZ0OrvRANVqCbQV7HwQJ-qHqSaMeK_5Q7x42MwiM,6295
+odoo/addons/shopfloor/tests/test_location_content_transfer_base.py,sha256=ziYyAOh9TaJaYkIyb338eWeownhEVVNKWr08iF1bbC4,4603
+odoo/addons/shopfloor/tests/test_location_content_transfer_get_work.py,sha256=QK3UCAAI9K3nZuLE5wC3twev8s-ZZ4b9WePNiYQUxjc,4686
 odoo/addons/shopfloor/tests/test_location_content_transfer_mix.py,sha256=BoKFuxFaP2eTerXx_L9e__io7Dfz86ksIAhN97uXKos,23928
-odoo/addons/shopfloor/tests/test_location_content_transfer_putaway.py,sha256=DNLOg3r4lajhZDJ8In3KfVCahXHTyCYQfL9Q0xs2_SI,5821
-odoo/addons/shopfloor/tests/test_location_content_transfer_set_destination_all.py,sha256=AYx3_3Iwbm2RlFwMdJdnZZlAdiF2vLOBk5-RUMjbWn8,13357
+odoo/addons/shopfloor/tests/test_location_content_transfer_putaway.py,sha256=nCcDEGLH1kuGr8tHmySA6-2IJHmYXtipHauzD7kZM8M,5837
+odoo/addons/shopfloor/tests/test_location_content_transfer_scan_location.py,sha256=hk66MI0yIbzhEX673xOFOoASgbuf2qHtxXtaip6vS3w,1489
+odoo/addons/shopfloor/tests/test_location_content_transfer_set_destination_all.py,sha256=Zfb1hD78HgtpU5jFOo-xVnOgj4nLQwzL0d72dJ50JOI,13419
 odoo/addons/shopfloor/tests/test_location_content_transfer_set_destination_package_or_line.py,sha256=4qZjf8aUAJn71yxWoF-Sw037rlq8bOrje-OZIu2ryKg,35661
 odoo/addons/shopfloor/tests/test_location_content_transfer_single.py,sha256=hcLAnArOBGcHEereWUZzIRA2oFRCGsBX3OHUyL2dYpw,30834
-odoo/addons/shopfloor/tests/test_location_content_transfer_start.py,sha256=zbIcQQ-kU9_zu4fsAmjD15ZhcVEuxfNoHXkivIEkF_4,14435
+odoo/addons/shopfloor/tests/test_location_content_transfer_start.py,sha256=wZHj3NnHOPMJg_a9SfKewN-U8a2L5xrPN32X_Fe7BA4,14443
 odoo/addons/shopfloor/tests/test_menu_base.py,sha256=Df2nDauxnelMogS5yLvw_Xs14VNqi6GZvCC4rCatzNA,9171
 odoo/addons/shopfloor/tests/test_menu_counters.py,sha256=rzf0q-ndVj4tUemuZ_odku7yvG60Kj_hXg8zxEQDUjo,2110
 odoo/addons/shopfloor/tests/test_misc.py,sha256=Jqw6v6HQXcsBAxTcZAJrr_yYLfXVlDSRPBgeDKSpR1E,771
 odoo/addons/shopfloor/tests/test_move_action_assign.py,sha256=t0JuV2gwFSGVnNTnMa31gVGm5p9mAKQR-jyxWRJBkN8,3440
 odoo/addons/shopfloor/tests/test_openapi.py,sha256=N3j2gjAOXZOk9AOiz_D0nJKWPK1orxi8whx2JBA6-WU,712
 odoo/addons/shopfloor/tests/test_picking_form.py,sha256=egJYeSqfeWuZTWwvaJbz7GEdJOR7Z7lc9RGGquE8YzI,2355
-odoo/addons/shopfloor/tests/test_scan_anything.py,sha256=oAHu0hhLob9RrO-kcIXVj5-g_OM0IRz2l4fjkbmiKfo,1680
-odoo/addons/shopfloor/tests/test_single_pack_transfer.py,sha256=DrWe7EPMNG0_vYIRCmwnpu9H0GY0QCaG5vXNMPDR71c,38877
+odoo/addons/shopfloor/tests/test_scan_anything.py,sha256=gB7imqKmmMejnZ50uu6ZQRXyphQxRvke4s9Wgtd3ZUk,1824
+odoo/addons/shopfloor/tests/test_single_pack_transfer.py,sha256=ke9ugOeAMqdhnCusRzy3NHwp-NT5NoWdwo0d3M8eno8,38881
 odoo/addons/shopfloor/tests/test_single_pack_transfer_base.py,sha256=EpHvlG57Xnme1Fp9nr1bH9jxnbX5Ei5miV5ep1NiHCI,1221
 odoo/addons/shopfloor/tests/test_single_pack_transfer_putaway.py,sha256=WPbndjKqRwMuAuRhEhiOiprUwh8TW3LFwWo2RKt5MoU,4397
 odoo/addons/shopfloor/tests/test_stock_split.py,sha256=N30RyqfvEtPpD1kEmI2SgvOp-x0b5sfKDYHVjJ5HJxU,8847
 odoo/addons/shopfloor/tests/test_user.py,sha256=RXy-XAZMRG_ACgT_Q90qGnUFFJBPmTVANS_DoiLSHuI,1389
-odoo/addons/shopfloor/tests/test_zone_picking_base.py,sha256=1IvOVFIAMgFWThnalZplGYuTw4a1v2o9pKniD2IsfnI,18392
+odoo/addons/shopfloor/tests/test_zone_picking_base.py,sha256=Cm26k4lAo64q9lONgzFv5mt4rvOjiCSNEPdh7ZRMEWQ,19095
 odoo/addons/shopfloor/tests/test_zone_picking_change_pack_lot.py,sha256=y0HAUDT7T1ogTqlr3yvwJdFbU013fMxSeqnDQ9w0efY,5302
-odoo/addons/shopfloor/tests/test_zone_picking_select_line.py,sha256=HoFH3XERxvaiXWDZXSPJX2-zd0C1hPV9PxPiArD9r7Q,25460
+odoo/addons/shopfloor/tests/test_zone_picking_select_line.py,sha256=81XdEGIypueHZdtGmGAwwyTRdKV34cw7xvPOkRhCJFk,28427
+odoo/addons/shopfloor/tests/test_zone_picking_select_line_first_scan_location.py,sha256=o6rgmGl1S77K8Ly79UM0ONWZytiI0Sunj4qN56YjVWQ,8162
+odoo/addons/shopfloor/tests/test_zone_picking_select_line_first_scan_location.py.bak,sha256=-TMgeipU2ROoSuyjLPMEMhK5EijwqJm0qS0xixK6TAE,7937
+odoo/addons/shopfloor/tests/test_zone_picking_select_line_no_prefill_qty.py,sha256=asA1X8QcQUexQ4TzHfz6D5tmdG5RFs-juoNJQo_C4NE,3816
 odoo/addons/shopfloor/tests/test_zone_picking_select_picking_type.py,sha256=kuuPjKvpBRrj36z-lj4P7NMLqszkZasIdpvx9mayUQI,870
-odoo/addons/shopfloor/tests/test_zone_picking_set_line_destination.py,sha256=xj8RF9QnyyQMXHVUau88qrD1Jk_3N3Iz-WOiMD-uMwc,21795
-odoo/addons/shopfloor/tests/test_zone_picking_set_line_destination_pick_pack.py,sha256=PxsoPd8BJsz4cozAGvBATt4L-CWB4ytLgliIJMVm63s,7942
+odoo/addons/shopfloor/tests/test_zone_picking_set_line_destination.py,sha256=xrN0FUaLcoiY2Llmti-Tcd0ifIQ2Nq4tbjBHebJsXsc,24140
+odoo/addons/shopfloor/tests/test_zone_picking_set_line_destination_no_prefill_qty.py,sha256=K3yu7FNvH7F-PTV8xiPuivTI4S6RO8Y6rmz7N8rjYk4,5188
+odoo/addons/shopfloor/tests/test_zone_picking_set_line_destination_pick_pack.py,sha256=9W4nnbQWWoF8t7jligXhDqxKsDqjErOBb0sOGGNFNW8,8275
 odoo/addons/shopfloor/tests/test_zone_picking_start.py,sha256=rlRpmNQA4C_GxQa_V8HJuA7mDToVWpEdpU_kRG82FBc,7170
 odoo/addons/shopfloor/tests/test_zone_picking_stock_issue.py,sha256=Ptc5mfkskwLssFns3iDzpkwvTh5zoxxPFTjCA9qaBak,6236
 odoo/addons/shopfloor/tests/test_zone_picking_unload_all.py,sha256=K094Rqw54Y0x6__B4wXUWvVFcpRupDgR8_xaJlA4V38,13049
 odoo/addons/shopfloor/tests/test_zone_picking_unload_buffer_lines.py,sha256=f8UMjaaLTVaxQMQTzUFtVIy9jqWvWSTaTxejzJA1Ha4,4357
 odoo/addons/shopfloor/tests/test_zone_picking_unload_set_destination.py,sha256=KrOIPBoniZiqjiN1VQeRMTZAb86Nixv4-vBFFbe1kzY,13548
 odoo/addons/shopfloor/tests/test_zone_picking_unload_single.py,sha256=Lm8Xiju9GhlyjYTgc4yNViozYZbZUiVkaV4fzA9C2Dw,4374
 odoo/addons/shopfloor/tests/test_zone_picking_zero_check.py,sha256=kdzFlkjA1hMLOxE7vpxz7B9ibmMUskI9zufHIoFv4YM,2514
-odoo/addons/shopfloor/views/shopfloor_menu.xml,sha256=xc8COmvQzNuHv2HUWDr7qirIhzHH_b4aQDtPME8yxew,4674
+odoo/addons/shopfloor/views/shopfloor_menu.xml,sha256=BDnoIGTw81GOkg2QQZjUyKTjcES3Ef1In00A4x5YMu4,7548
 odoo/addons/shopfloor/views/stock_location.xml,sha256=d7iqbOQZbb5YPSdAXlQ6spcj8dUvQ37DpEGuaLX5B1M,829
-odoo/addons/shopfloor/views/stock_move_line.xml,sha256=MXf-b44ib91FYzhnwZ3ZYVrs-4abh48ftiKHRq75OLo,1295
+odoo/addons/shopfloor/views/stock_move_line.xml,sha256=tn3pV67aRoYmn3qkm3aSgdYArY-z9SIrl_4fpJFy3Jo,1984
 odoo/addons/shopfloor/views/stock_picking_type.xml,sha256=tVetXhwIIz0z0ejLFavkd12FnRgHKavoLXE_apNYP4c,793
-odoo14_addon_shopfloor-14.0.2.9.3.dev1.dist-info/METADATA,sha256=VbC4hBPpdmI0GNRQntPCnbZre_Fo8D_xI5lqjrD3wn8,5806
-odoo14_addon_shopfloor-14.0.2.9.3.dev1.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-odoo14_addon_shopfloor-14.0.2.9.3.dev1.dist-info/top_level.txt,sha256=qBj40grFkGOfDZ2WDSw3y1RnDlgG0u8rP8pvGNdbz4w,5
-odoo14_addon_shopfloor-14.0.2.9.3.dev1.dist-info/RECORD,,
+odoo14_addon_shopfloor-14.0.3.0.0.dist-info/METADATA,sha256=oxFK3DiS0zjofUiPvgB2QOcZA_-M36m1IIfjRVnozvg,6253
+odoo14_addon_shopfloor-14.0.3.0.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+odoo14_addon_shopfloor-14.0.3.0.0.dist-info/top_level.txt,sha256=qBj40grFkGOfDZ2WDSw3y1RnDlgG0u8rP8pvGNdbz4w,5
+odoo14_addon_shopfloor-14.0.3.0.0.dist-info/RECORD,,
```

