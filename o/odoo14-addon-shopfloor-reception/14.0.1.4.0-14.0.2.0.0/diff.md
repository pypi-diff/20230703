# Comparing `tmp/odoo14_addon_shopfloor_reception-14.0.1.4.0-py3-none-any.whl.zip` & `tmp/odoo14_addon_shopfloor_reception-14.0.2.0.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,35 +1,42 @@
-Zip file size: 177029 bytes, number of entries: 33
--rw-r--r--  2.0 unx     3384 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/README.rst
--rw-r--r--  2.0 unx       23 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/__init__.py
--rw-r--r--  2.0 unx      587 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/__manifest__.py
--rw-r--r--  2.0 unx      412 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/data/shopfloor_scenario_data.xml
--rw-r--r--  2.0 unx      627 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/demo/shopfloor_menu_demo.xml
--rw-r--r--  2.0 unx      965 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/demo/stock_picking_type_demo.xml
--rw-r--r--  2.0 unx     3866 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/docs/reception_sequence_graph.mermaid
--rw-r--r--  2.0 unx   155103 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/docs/reception_sequence_graph.png
--rw-r--r--  2.0 unx      658 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/i18n/shopfloor_reception.pot
--rw-r--r--  2.0 unx      216 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/readme/CONTRIBUTORS.rst
--rw-r--r--  2.0 unx      131 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/readme/DESCRIPTION.rst
--rw-r--r--  2.0 unx      109 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/readme/ROADMAP.rst
--rw-r--r--  2.0 unx       24 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/services/__init__.py
--rw-r--r--  2.0 unx    58745 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/services/reception.py
--rw-r--r--  2.0 unx     9455 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/static/description/icon.png
--rw-r--r--  2.0 unx    12973 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/static/description/index.html
--rw-r--r--  2.0 unx      368 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/tests/__init__.py
--rw-r--r--  2.0 unx     4729 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/tests/common.py
--rw-r--r--  2.0 unx     1253 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/tests/test_manual_selection.py
--rw-r--r--  2.0 unx     3450 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/tests/test_reception_done.py
--rw-r--r--  2.0 unx     4836 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/tests/test_select_dest_package.py
--rw-r--r--  2.0 unx     6110 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/tests/test_select_document.py
--rw-r--r--  2.0 unx    10798 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/tests/test_select_move.py
--rw-r--r--  2.0 unx     6279 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/tests/test_set_destination.py
--rw-r--r--  2.0 unx     5574 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/tests/test_set_lot.py
--rw-r--r--  2.0 unx     2267 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/tests/test_set_lot_confirm.py
--rw-r--r--  2.0 unx    14254 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/tests/test_set_quantity.py
--rw-r--r--  2.0 unx     2914 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/tests/test_set_quantity_action.py
--rw-r--r--  2.0 unx     1699 b- defN 23-May-29 21:12 odoo/addons/shopfloor_reception/tests/test_start.py
--rw-r--r--  2.0 unx     4006 b- defN 23-May-29 21:12 odoo14_addon_shopfloor_reception-14.0.1.4.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-May-29 21:12 odoo14_addon_shopfloor_reception-14.0.1.4.0.dist-info/WHEEL
--rw-r--r--  2.0 unx        5 b- defN 23-May-29 21:12 odoo14_addon_shopfloor_reception-14.0.1.4.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     3711 b- defN 23-May-29 21:12 odoo14_addon_shopfloor_reception-14.0.1.4.0.dist-info/RECORD
-33 files, 319623 bytes uncompressed, 170707 bytes compressed:  46.6%
+Zip file size: 186303 bytes, number of entries: 40
+-rw-r--r--  2.0 unx     3384 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/README.rst
+-rw-r--r--  2.0 unx       44 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/__init__.py
+-rw-r--r--  2.0 unx      587 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/__manifest__.py
+-rw-r--r--  2.0 unx      444 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/data/shopfloor_scenario_data.xml
+-rw-r--r--  2.0 unx      627 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/demo/shopfloor_menu_demo.xml
+-rw-r--r--  2.0 unx      965 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/demo/stock_picking_type_demo.xml
+-rw-r--r--  2.0 unx     3866 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/docs/reception_sequence_graph.mermaid
+-rw-r--r--  2.0 unx   155103 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/docs/reception_sequence_graph.png
+-rw-r--r--  2.0 unx     1421 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/i18n/shopfloor_reception.pot
+-rw-r--r--  2.0 unx       28 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/models/__init__.py
+-rw-r--r--  2.0 unx      239 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/models/stock_picking.py
+-rw-r--r--  2.0 unx      216 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/readme/CONTRIBUTORS.rst
+-rw-r--r--  2.0 unx      131 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/readme/DESCRIPTION.rst
+-rw-r--r--  2.0 unx      109 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/readme/ROADMAP.rst
+-rw-r--r--  2.0 unx       24 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/services/__init__.py
+-rw-r--r--  2.0 unx    67833 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/services/reception.py
+-rw-r--r--  2.0 unx     9455 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/static/description/icon.png
+-rw-r--r--  2.0 unx    12973 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/static/description/index.html
+-rw-r--r--  2.0 unx      524 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/tests/__init__.py
+-rw-r--r--  2.0 unx     4557 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/tests/common.py
+-rw-r--r--  2.0 unx     4777 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/tests/reception_return_common.py
+-rw-r--r--  2.0 unx     1253 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/tests/test_manual_selection.py
+-rw-r--r--  2.0 unx     3446 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/tests/test_reception_done.py
+-rw-r--r--  2.0 unx     5282 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/tests/test_return_reception_done.py
+-rw-r--r--  2.0 unx     3587 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/tests/test_return_scan_document.py
+-rw-r--r--  2.0 unx     3889 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/tests/test_return_scan_line.py
+-rw-r--r--  2.0 unx     4524 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/tests/test_return_set_quantity.py
+-rw-r--r--  2.0 unx     4836 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/tests/test_select_dest_package.py
+-rw-r--r--  2.0 unx     6110 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/tests/test_select_document.py
+-rw-r--r--  2.0 unx    10798 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/tests/test_select_move.py
+-rw-r--r--  2.0 unx     6279 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/tests/test_set_destination.py
+-rw-r--r--  2.0 unx     5574 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/tests/test_set_lot.py
+-rw-r--r--  2.0 unx     2267 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/tests/test_set_lot_confirm.py
+-rw-r--r--  2.0 unx    14254 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/tests/test_set_quantity.py
+-rw-r--r--  2.0 unx     2914 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/tests/test_set_quantity_action.py
+-rw-r--r--  2.0 unx     1699 b- defN 23-Jul-03 07:50 odoo/addons/shopfloor_reception/tests/test_start.py
+-rw-r--r--  2.0 unx     4006 b- defN 23-Jul-03 07:50 odoo14_addon_shopfloor_reception-14.0.2.0.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-03 07:50 odoo14_addon_shopfloor_reception-14.0.2.0.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        5 b- defN 23-Jul-03 07:50 odoo14_addon_shopfloor_reception-14.0.2.0.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     4537 b- defN 23-Jul-03 07:50 odoo14_addon_shopfloor_reception-14.0.2.0.0.dist-info/RECORD
+40 files, 352659 bytes uncompressed, 178591 bytes compressed:  49.4%
```

## zipnote {}

```diff
@@ -21,14 +21,20 @@
 
 Filename: odoo/addons/shopfloor_reception/docs/reception_sequence_graph.png
 Comment: 
 
 Filename: odoo/addons/shopfloor_reception/i18n/shopfloor_reception.pot
 Comment: 
 
+Filename: odoo/addons/shopfloor_reception/models/__init__.py
+Comment: 
+
+Filename: odoo/addons/shopfloor_reception/models/stock_picking.py
+Comment: 
+
 Filename: odoo/addons/shopfloor_reception/readme/CONTRIBUTORS.rst
 Comment: 
 
 Filename: odoo/addons/shopfloor_reception/readme/DESCRIPTION.rst
 Comment: 
 
 Filename: odoo/addons/shopfloor_reception/readme/ROADMAP.rst
@@ -48,20 +54,35 @@
 
 Filename: odoo/addons/shopfloor_reception/tests/__init__.py
 Comment: 
 
 Filename: odoo/addons/shopfloor_reception/tests/common.py
 Comment: 
 
+Filename: odoo/addons/shopfloor_reception/tests/reception_return_common.py
+Comment: 
+
 Filename: odoo/addons/shopfloor_reception/tests/test_manual_selection.py
 Comment: 
 
 Filename: odoo/addons/shopfloor_reception/tests/test_reception_done.py
 Comment: 
 
+Filename: odoo/addons/shopfloor_reception/tests/test_return_reception_done.py
+Comment: 
+
+Filename: odoo/addons/shopfloor_reception/tests/test_return_scan_document.py
+Comment: 
+
+Filename: odoo/addons/shopfloor_reception/tests/test_return_scan_line.py
+Comment: 
+
+Filename: odoo/addons/shopfloor_reception/tests/test_return_set_quantity.py
+Comment: 
+
 Filename: odoo/addons/shopfloor_reception/tests/test_select_dest_package.py
 Comment: 
 
 Filename: odoo/addons/shopfloor_reception/tests/test_select_document.py
 Comment: 
 
 Filename: odoo/addons/shopfloor_reception/tests/test_select_move.py
@@ -81,20 +102,20 @@
 
 Filename: odoo/addons/shopfloor_reception/tests/test_set_quantity_action.py
 Comment: 
 
 Filename: odoo/addons/shopfloor_reception/tests/test_start.py
 Comment: 
 
-Filename: odoo14_addon_shopfloor_reception-14.0.1.4.0.dist-info/METADATA
+Filename: odoo14_addon_shopfloor_reception-14.0.2.0.0.dist-info/METADATA
 Comment: 
 
-Filename: odoo14_addon_shopfloor_reception-14.0.1.4.0.dist-info/WHEEL
+Filename: odoo14_addon_shopfloor_reception-14.0.2.0.0.dist-info/WHEEL
 Comment: 
 
-Filename: odoo14_addon_shopfloor_reception-14.0.1.4.0.dist-info/top_level.txt
+Filename: odoo14_addon_shopfloor_reception-14.0.2.0.0.dist-info/top_level.txt
 Comment: 
 
-Filename: odoo14_addon_shopfloor_reception-14.0.1.4.0.dist-info/RECORD
+Filename: odoo14_addon_shopfloor_reception-14.0.2.0.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## odoo/addons/shopfloor_reception/__init__.py

```diff
@@ -1 +1,2 @@
 from . import services
+from . import models
```

## odoo/addons/shopfloor_reception/__manifest__.py

```diff
@@ -1,11 +1,11 @@
 {
     "name": "Shopfloor Reception",
     "summary": "Reception scenario for shopfloor",
-    "version": "14.0.1.4.0",
+    "version": "14.0.2.0.0",
     "development_status": "Beta",
     "category": "Inventory",
     "website": "https://github.com/OCA/wms",
     "author": "Camptocamp, Odoo Community Association (OCA)",
     "maintainers": ["mmequignon", "JuMiSanAr"],
     "license": "AGPL-3",
     "installable": True,
```

## odoo/addons/shopfloor_reception/data/shopfloor_scenario_data.xml

### odoo/addons/shopfloor_reception/data/shopfloor_scenario_data.xml

```diff
@@ -2,11 +2,12 @@
 <!-- Copyright 2022 Camptocamp SA
      License AGPL-3.0 or later (http://www.gnu.org/licenses/agpl). -->
 <odoo noupdate="1">
   <record id="scenario_reception" model="shopfloor.scenario">
     <field name="name">Reception</field>
     <field name="key">reception</field>
     <field name="options_edit">{
-  &quot;auto_post_line&quot;: true
+      &quot;auto_post_line&quot;: true,
+      &quot;allow_return&quot;: true
 }</field>
   </record>
 </odoo>
```

## odoo/addons/shopfloor_reception/i18n/shopfloor_reception.pot

```diff
@@ -10,12 +10,37 @@
 "Language-Team: \n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: \n"
 "Plural-Forms: \n"
 
 #. module: shopfloor_reception
+#: model:ir.model.fields,field_description:shopfloor_reception.field_stock_picking__display_name
+msgid "Display Name"
+msgstr ""
+
+#. module: shopfloor_reception
+#: model:ir.model.fields,field_description:shopfloor_reception.field_stock_picking__id
+msgid "ID"
+msgstr ""
+
+#. module: shopfloor_reception
+#: model:ir.model.fields,field_description:shopfloor_reception.field_stock_picking__is_shopfloor_created
+msgid "Is Shopfloor Created"
+msgstr ""
+
+#. module: shopfloor_reception
+#: model:ir.model.fields,field_description:shopfloor_reception.field_stock_picking____last_update
+msgid "Last Modified on"
+msgstr ""
+
+#. module: shopfloor_reception
 #: model:shopfloor.menu,name:shopfloor_reception.shopfloor_menu_demo_reception
 #: model:shopfloor.scenario,name:shopfloor_reception.scenario_reception
 #: model:stock.picking.type,name:shopfloor_reception.picking_type_reception_demo
 msgid "Reception"
 msgstr ""
+
+#. module: shopfloor_reception
+#: model:ir.model,name:shopfloor_reception.model_stock_picking
+msgid "Transfer"
+msgstr ""
```

## odoo/addons/shopfloor_reception/services/reception.py

```diff
@@ -44,14 +44,22 @@
     """
 
     _inherit = "base.shopfloor.process"
     _name = "shopfloor.reception"
     _usage = "reception"
     _description = __doc__
 
+    def _check_picking_status(self, pickings):
+        # When returns are allowed,
+        # the created picking might be empty and cannot be assigned.
+        states = ["assigned"]
+        if self.work.menu.allow_return:
+            states.append("draft")
+        return super()._check_picking_status(pickings, states=states)
+
     def _move_line_by_product(self, product):
         return self.env["stock.move.line"].search(
             self._domain_move_line_by_product(product)
         )
 
     def _move_line_by_packaging(self, packaging):
         return self.env["stock.move.line"].search(
@@ -166,14 +174,20 @@
                 pickings=pickings,
                 message=self.msg_store.multiple_picks_found_select_manually(),
             )
         # If no available picking with the right state has been found,
         # return an error
         return self._response_for_select_document(message=msg_func())
 
+    def _scan_document__create_return(self, picking, return_type, barcode):
+        stock = self._actions_for("stock")
+        return_picking = stock.create_return_picking(picking, return_type, barcode)
+        return_picking.action_confirm()
+        return return_picking
+
     def _select_document_from_product(self, product):
         """Select the document by product
 
         next states:
             - set_lot: a single picking has been found for this packaging
             - select_document: A single or no pickings has been found for this packaging
         """
@@ -229,72 +243,76 @@
                 message=self.msg_store.multiple_picks_found_select_manually(),
             )
         return self._response_for_select_document(
             pickings=pickings,
             message=self.msg_store.lot_not_found_in_pickings(),
         )
 
-    def _select_line(self, picking, line, move, increase_qty_done_by=1):
-        product = line.product_id
+    def _scan_line__find_or_create_line(self, picking, move, qty_done=1):
+        line = fields.first(
+            move.move_line_ids.filtered(
+                lambda l: (
+                    not l.result_package_id
+                    and l.shopfloor_user_id.id in [False, self.env.uid]
+                )
+            )
+        )
         if line:
             # The line quantity to do needs to correspond to
             # the remaining quantity to do of its move.
             line.product_uom_qty = move.product_uom_qty - move.quantity_done
         else:
             qty_todo_remaining = move.product_uom_qty - move.quantity_done
             values = move._prepare_move_line_vals(quantity=qty_todo_remaining)
             line = self.env["stock.move.line"].create(values)
+        return self._scan_line__assign_user(picking, line, qty_done)
+
+    def _scan_line__assign_user(self, picking, line, qty_done):
+        product = line.product_id
         self._assign_user_to_picking(picking)
         self._assign_user_to_line(line)
-        line.qty_done += increase_qty_done_by
+        line.qty_done += qty_done
         if product.tracking not in ("lot", "serial") or (line.lot_id or line.lot_name):
             return self._response_for_set_quantity(picking, line)
         return self._response_for_set_lot(picking, line)
 
-    def _select_line_from_product(self, picking, move, product):
-        line = fields.first(
-            picking.move_line_ids.filtered(
-                lambda l: l.product_id == product
+    def _select_line__filter_lines_by_packaging__return(self, lines, packaging):
+        return_line = fields.first(
+            lines.filtered(
+                lambda l: not l.package_id.product_packaging_id
                 and not l.result_package_id
-                and l.shopfloor_user_id.id in [False, self.env.uid]
+                and l.shopfloor_user_id.id in (False, self.env.uid)
             )
         )
-        return self._select_line(picking, line, move)
+        if return_line:
+            return return_line
 
-    def _select_line_from_packaging(self, picking, move, packaging):
-        line = fields.first(
-            picking.move_line_ids.filtered(
-                lambda l: l.package_id.product_packaging_id == packaging
-                and not l.result_package_id
-                and l.shopfloor_user_id.id in [False, self.env.uid]
+    def _select_line__filter_lines_by_packaging(self, lines, packaging):
+        if self.work.menu.allow_return:
+            line = self._select_line__filter_lines_by_packaging__return(
+                lines, packaging
             )
-        )
-        return self._select_line(picking, line, move, packaging.qty)
-
-    def _select_line_from_lot(self, picking, move, lot):
-        line = fields.first(
-            picking.move_line_ids.filtered(
-                lambda l: (l.lot_id.name == lot or l.lot_name == lot)
+            if line:
+                return line
+        return fields.first(
+            lines.filtered(
+                lambda l: l.package_id.product_packaging_id == packaging
                 and not l.result_package_id
                 and l.shopfloor_user_id.id in [False, self.env.uid]
             )
         )
-        if not line:
-            return
-        return self._select_line(picking, line, move)
 
     def _order_stock_picking(self):
         # We sort by scheduled date first. However, there might be a case
         # where two pickings have the exact same scheduled date.
         # In that case, we sort by id.
         return "scheduled_date ASC, id ASC"
 
-    def _scan_document__by_picking(self, barcode):
-        search = self._actions_for("search")
-        picking_filter_result = search.picking_from_scan(barcode, use_origin=True)
+    def _scan_document__by_picking(self, pickings, barcode):
+        picking_filter_result = pickings
         reception_pickings = picking_filter_result.filtered(
             lambda p: p.picking_type_id.id in self.picking_types.ids
         )
         if picking_filter_result and not reception_pickings:
             return self._response_for_select_document(
                 message=self.msg_store.cannot_move_something_in_picking_type()
             )
@@ -320,200 +338,328 @@
             if len(picking_filter_result) > 1:
                 return self._response_for_select_document(
                     pickings=reception_pickings,
                     message=self.msg_store.source_document_multiple_pickings_scan_package(),
                 )
             return self._select_picking(reception_pickings)
 
-    def _scan_document__by_product(self, barcode):
-        search = self._actions_for("search")
-        product = search.product_from_scan(barcode)
+    def _scan_document__by_product(self, product, barcode):
         if product:
             return self._select_document_from_product(product)
 
-    def _scan_document__by_packaging(self, barcode):
-        search = self._actions_for("search")
-        packaging = search.packaging_from_scan(barcode)
+    def _scan_document__by_packaging(self, packaging, barcode):
         if packaging:
             return self._select_document_from_packaging(packaging)
 
-    def _scan_document__by_lot(self, barcode):
-        return self._select_document_from_lot(barcode)
+    def _scan_document__by_lot(self, lot, barcode):
+        return self._select_document_from_lot(lot)
+
+    def _scan_document__by_origin_move(self, moves, barcode):
+        if not self.work.menu.allow_return:
+            # A return picking has been scanned, but allow rma is disabled.
+            return self._scan_document__fallback()
+        pickings = moves.picking_id
+        outgoing_pickings = pickings.filtered(
+            lambda p: (p.picking_type_code == "outgoing")
+        )
+        # If we find valid pickings for a return, then we create an empty
+        # return picking
+        if outgoing_pickings:
+            # But first, check that return types are correctly set up,
+            # as we cannot create a return move with empty locations.
+            return_types = self.picking_types.filtered(
+                lambda t: t.default_location_src_id and t.default_location_dest_id
+            )
+            if not return_types:
+                message = self.msg_store.no_default_location_on_picking_type()
+                return self._response_for_select_document(message=message)
+            return_picking = self._scan_document__create_return(
+                fields.first(outgoing_pickings), fields.first(return_types), barcode
+            )
+            return self._response_for_select_move(return_picking)
 
-    def _scan_line__by_product(self, picking, barcode):
+    def _scan_document__fallback(self):
+        return self._response_for_select_document(
+            message=self.msg_store.barcode_not_found()
+        )
+
+    def _scan_line__create_return_move(self, return_picking, origin_moves):
+        # copied from odoo/src/addons/stock/wizard/stock_picking_return.py
+        stock = self._actions_for("stock")
+        return stock.create_return_move(return_picking, origin_moves)
+
+    def _scan_line__by_product__return(self, picking, product):
         search = self._actions_for("search")
-        product = search.product_from_scan(barcode)
-        if product:
-            move = fields.first(
-                picking.move_lines.filtered(
-                    lambda m: m.product_id == product
-                    and float_compare(
-                        m.quantity_done,
-                        m.product_uom_qty,
-                        precision_rounding=m.product_uom.rounding,
-                    )
-                    == -1
-                )
+        origin_move_domain = [
+            ("picking_id.picking_type_code", "=", "outgoing"),
+        ]
+        origin_moves = search.origin_move_from_scan(
+            picking.origin, extra_domain=origin_move_domain
+        )
+        origin_moves_for_product = origin_moves.filtered(
+            lambda m: m.product_id == product
+        )
+        # If we have an origin picking but no origin move, then user
+        # scanned a wrong product. Warn him about this.
+        if origin_moves and not origin_moves_for_product:
+            message = self.msg_store.product_not_found_in_current_picking()
+            return self._response_for_select_move(picking, message=message)
+        if origin_moves_for_product:
+            return_move = self._scan_line__create_return_move(
+                picking, origin_moves_for_product
+            )
+            if not return_move:
+                # It means that among all origin moves, none has been found with
+                # max qty to return being positive.
+                # Which means all lines have already been returned.
+                message = self.msg_store.move_already_returned()
+                return self._response_for_select_move(picking, message=message)
+            picking.action_confirm()
+            picking.action_assign()
+            return self._scan_line__find_or_create_line(picking, return_move)
+
+    def _scan_line__by_product(self, picking, product):
+        move = picking.move_lines.filtered(lambda m: m.product_id == product)
+        # Only create a return if don't already have a maching reception move
+        if not move and self.work.menu.allow_return:
+            response = self._scan_line__by_product__return(picking, product)
+            if response:
+                return response
+        # Otherwise, the picking isn't a return, and should be a regular reception
+        message = self._check_move_available(move, "product")
+        if message:
+            return self._response_for_select_move(
+                picking,
+                message=message,
             )
-            message = self._check_move_available(move, message_code="product")
-            if message:
-                return self._response_for_select_move(
-                    picking,
-                    message=message,
-                )
-            return self._select_line_from_product(picking, move, product)
+        return self._scan_line__find_or_create_line(picking, move)
 
-    def _scan_line__by_packaging(self, picking, barcode):
+    def _scan_line__by_packaging__return(self, picking, packaging):
         search = self._actions_for("search")
-        packaging = search.packaging_from_scan(barcode)
-        if packaging:
-            move = fields.first(
-                picking.move_lines.filtered(
-                    lambda m: packaging in m.product_id.packaging_ids
-                    and float_compare(
-                        m.quantity_done,
-                        m.product_uom_qty,
-                        precision_rounding=m.product_uom.rounding,
-                    )
-                    == -1
-                )
+        origin_move_domain = [
+            ("picking_id.picking_type_code", "=", "outgoing"),
+        ]
+        origin_moves = search.origin_move_from_scan(
+            picking.origin, extra_domain=origin_move_domain
+        )
+        origin_moves_for_packaging = origin_moves.filtered(
+            lambda m: packaging in m.product_id.packaging_ids
+        )
+        if origin_moves and not origin_moves_for_packaging:
+            message = self.msg_store.packaging_not_found_in_picking()
+            return self._response_for_select_move(picking, message=message)
+        # If we have an origin move, create the return move, and go to next screen
+        if origin_moves_for_packaging:
+            return_move = self._scan_line__create_return_move(
+                picking, origin_moves_for_packaging
+            )
+            return_move._action_confirm()
+            return self._scan_line__find_or_create_line(
+                picking, return_move, packaging.qty
+            )
+
+    def _scan_line__by_packaging(self, picking, packaging):
+        move = picking.move_lines.filtered(
+            lambda m: packaging in m.product_id.packaging_ids
+        )
+        # Only create a return if don't already have a maching reception move
+        if not move and self.work.menu.allow_return:
+            response = self._scan_line__by_packaging__return(picking, packaging)
+            if response:
+                return response
+        message = self._check_move_available(move, "packaging")
+        if message:
+            return self._response_for_select_move(
+                picking,
+                message=message,
             )
-            message = self._check_move_available(move, message_code="packaging")
-            if message:
-                return self._response_for_select_move(
-                    picking,
-                    message=message,
-                )
-            return self._select_line_from_packaging(picking, move, packaging)
+        return self._scan_line__find_or_create_line(picking, move)
 
-    def _scan_line__by_lot(self, picking, barcode):
-        line = picking.move_line_ids.filtered(
-            lambda l: barcode == l.lot_id.name or barcode == l.lot_name
+    def _scan_line__by_lot(self, picking, lot):
+        lines = picking.move_line_ids.filtered(
+            lambda l: (
+                lot == l.lot_id
+                or (lot.name == l.lot_name and lot.product_id == l.product_id)
+                and not l.result_package_id
+            )
         )
-        move = line.move_id
-        search = self._actions_for("search")
-        lot = search.lot_from_scan(barcode)
-        if not move:
-            line = picking.move_line_ids.filtered(
-                lambda l: not l.lot_id
-                and not l.lot_name
-                and l.product_id == lot.product_id
+        if not lines:
+            return self._scan_line__by_product(picking, lot.product_id)
+        # TODO probably suboptimal
+        # We might have an available line, but it might be the last one.
+        # Loop over the recordset and break as soon as we find one.
+        for line in lines:
+            message = self._check_move_available(line.move_id, message_code="lot")
+            if not message:
+                break
+        if message:
+            return self._response_for_select_move(
+                picking,
+                message=message,
             )
-            if line:
-                return self._select_line(picking, line, move)
-        else:
-            message = self._check_move_available(move, message_code="lot")
-            if message:
-                return self._response_for_select_move(
-                    picking,
-                    message=message,
-                )
-            if lot:
-                return self._select_line_from_lot(picking, move, barcode)
+        return self._scan_line__assign_user(picking, line, 1)
+
+    def _scan_line__fallback(self, picking, barcode):
+        # We might have lines with no lot, but with a lot_name.
+        lines = picking.move_line_ids.filtered(
+            lambda l: l.lot_name == barcode and not l.result_package_id
+        )
+        if not lines:
+            return self._response_for_select_move(
+                picking, message=self.msg_store.barcode_not_found()
+            )
+        for line in lines:
+            message = self._check_move_available(line.move_id, message_code="lot")
+            if not message:
+                return self._scan_line__assign_user(picking, line, 1)
+        return self._response_for_select_move(
+            picking,
+            message=message,
+        )
 
     def _check_move_available(self, move, message_code="product"):
         if not move:
             message_code = message_code.capitalize()
             return self.msg_store.x_not_found_or_already_in_dest_package(message_code)
         line_without_package = any(
             not ml.result_package_id for ml in move.move_line_ids
         )
         if move.product_uom_qty - move.quantity_done < 1 and not line_without_package:
             return self.msg_store.move_already_done()
 
-    def _set_quantity__by_product(self, picking, selected_line, barcode):
-        search = self._actions_for("search")
-        product = search.product_from_scan(barcode)
-        if product:
-            if product.id != selected_line.product_id.id:
+    def _set_quantity__by_product(self, picking, selected_line, product):
+        # This is a general rule here. whether the return has been created from
+        # shopfloor or not, you cannot return more than what was shipped.
+        # Therefore, we cannot use the `is_shopfloor_created` here.
+        previous_vals = {
+            "qty_done": selected_line.qty_done,
+        }
+        is_return_line = bool(selected_line.move_id.origin_returned_move_id)
+        max_qty_done = selected_line.move_id.product_uom_qty
+        if product.id != selected_line.product_id.id:
+            return self._response_for_set_quantity(
+                picking,
+                selected_line,
+                message=self.msg_store.wrong_record(product),
+            )
+        selected_line.qty_done += 1
+        response = self._response_for_set_quantity(picking, selected_line)
+        if self.work.menu.allow_return and is_return_line:
+            message_type = response.get("message", {}).get("message_type")
+            # If we have an error, return it, since this is also true for return lines
+            if message_type == "error":
+                return response
+            rounding = selected_line.product_uom_id.rounding
+            compare = float_compare(
+                selected_line.qty_done, max_qty_done, precision_rounding=rounding
+            )
+            # We cannot set a qty_done superior to what has initally been sent
+            if compare == 1:
+                # If so, reset selected_line to its previous state, and return an error
+                selected_line.write(previous_vals)
+                message = self.msg_store.return_line_invalid_qty()
                 return self._response_for_set_quantity(
-                    picking,
-                    selected_line,
-                    message=self.msg_store.wrong_record(product),
+                    picking, selected_line, message=message
                 )
-            selected_line.qty_done += 1
-            return self._response_for_set_quantity(picking, selected_line)
+        return response
 
-    def _set_quantity__by_packaging(self, picking, selected_line, barcode):
-        search = self._actions_for("search")
-        packaging = search.packaging_from_scan(barcode)
-        if packaging:
-            if packaging.product_id.id != selected_line.product_id.id:
+    def _set_quantity__by_packaging(self, picking, selected_line, packaging):
+        # This is a general rule here. whether the return has been created from
+        # shopfloor or not, you cannot return more than what was shipped.
+        # Therefore, we cannot use the `is_shopfloor_created` here.
+        previous_vals = {
+            "qty_done": selected_line.qty_done,
+        }
+        is_return_line = bool(selected_line.move_id.origin_returned_move_id)
+        max_qty_done = selected_line.move_id.product_uom_qty
+        if packaging.product_id.id != selected_line.product_id.id:
+            return self._response_for_set_quantity(
+                picking,
+                selected_line,
+                message=self.msg_store.wrong_record(packaging),
+            )
+        selected_line.qty_done += packaging.qty
+        response = self._response_for_set_quantity(picking, selected_line)
+        if self.work.menu.allow_return and is_return_line:
+            message_type = response.get("message", {}).get("message_type")
+            # If we have an error, return it, since this is also true for return lines
+            if message_type == "error":
+                return response
+            # We cannot set a qty_done superior to what has initally been sent
+            rounding = selected_line.product_uom_id.rounding
+            compare = float_compare(
+                selected_line.qty_done, max_qty_done, precision_rounding=rounding
+            )
+            # We cannot set a qty_done superior to what has initally been sent
+            if compare == 1:
+                # If so, reset selected_line to its previous state, and return an error
+                selected_line.write(previous_vals)
+                message = self.msg_store.return_line_invalid_qty()
                 return self._response_for_set_quantity(
-                    picking,
-                    selected_line,
-                    message=self.msg_store.wrong_record(packaging),
-                )
-            selected_line.qty_done += packaging.qty
-            return self._response_for_set_quantity(picking, selected_line)
-
-    def _set_quantity__by_package(self, picking, selected_line, barcode):
-        search = self._actions_for("search")
-        package = search.package_from_scan(barcode)
-        if package:
-            pack_location = package.location_id
-            if pack_location:
-                (
-                    move_dest_location_ok,
-                    pick_type_dest_location_ok,
-                ) = self._check_location_ok(pack_location, selected_line, picking)
-                if not (move_dest_location_ok or pick_type_dest_location_ok):
-                    # If the scanned package has a location that isn't a child
-                    # of the move dest, return an error
-                    message = self.msg_store.dest_location_not_allowed()
-                    return self._response_for_set_quantity(
-                        picking, selected_line, message=message
-                    )
-                quantity = selected_line.qty_done
-                __, qty_check = selected_line._split_qty_to_be_done(
-                    quantity,
-                    lot_id=False,
-                    shopfloor_user_id=False,
-                    expiration_date=False,
+                    picking, selected_line, message=message
                 )
-                if qty_check == "greater":
-                    return self._response_for_set_quantity(
-                        picking,
-                        selected_line,
-                        message=self.msg_store.unable_to_pick_more(
-                            selected_line.product_uom_qty
-                        ),
-                    )
-                # If the scanned package has a valid destination,
-                # set both package and destination on the package,
-                # and go back to the selection line screen
-                selected_line.result_package_id = package
-                selected_line.location_dest_id = pack_location
-                if self.work.menu.auto_post_line:
-                    # If option auto_post_line is active in the shopfloor menu,
-                    # create a split order with this line.
-                    self._auto_post_line(selected_line)
-                return self._response_for_select_move(picking)
-            # Scanned package has no location, move to the location selection
-            # screen
-            selected_line.result_package_id = package
-            return self._response_for_set_destination(picking, selected_line)
+        return response
 
-    def _set_quantity__by_location(self, picking, selected_line, barcode):
-        search = self._actions_for("search")
-        location = search.location_from_scan(barcode)
-        if location:
-            move_dest_location_ok, pick_type_dest_location_ok = self._check_location_ok(
-                location, selected_line, picking
-            )
+    def _set_quantity__by_package(self, picking, selected_line, package):
+        pack_location = package.location_id
+        if pack_location:
+            (
+                move_dest_location_ok,
+                pick_type_dest_location_ok,
+            ) = self._check_location_ok(pack_location, selected_line, picking)
             if not (move_dest_location_ok or pick_type_dest_location_ok):
-                # Scanned location isn't a child of the move's dest location
+                # If the scanned package has a location that isn't a child
+                # of the move dest, return an error
                 message = self.msg_store.dest_location_not_allowed()
                 return self._response_for_set_quantity(
                     picking, selected_line, message=message
                 )
-            # process without pack, set destination location, and go back to
-            # `select_move`
-            selected_line.location_dest_id = location
+            quantity = selected_line.qty_done
+            __, qty_check = selected_line._split_qty_to_be_done(
+                quantity,
+                lot_id=False,
+                shopfloor_user_id=False,
+                expiration_date=False,
+            )
+            if qty_check == "greater":
+                return self._response_for_set_quantity(
+                    picking,
+                    selected_line,
+                    message=self.msg_store.unable_to_pick_more(
+                        selected_line.product_uom_qty
+                    ),
+                )
+            # If the scanned package has a valid destination,
+            # set both package and destination on the package.
+            selected_line.result_package_id = package
+            selected_line.location_dest_id = pack_location
+
+            response = self._post_line(selected_line)
+            if response:
+                return response
             return self._response_for_select_move(picking)
+        # Scanned package has no location, move to the location selection
+        # screen
+        selected_line.result_package_id = package
+        return self._response_for_set_destination(picking, selected_line)
+
+    def _set_quantity__by_location(self, picking, selected_line, location):
+        move_dest_location_ok, pick_type_dest_location_ok = self._check_location_ok(
+            location, selected_line, picking
+        )
+        if not (move_dest_location_ok or pick_type_dest_location_ok):
+            # Scanned location isn't a child of the move's dest location
+            message = self.msg_store.dest_location_not_allowed()
+            return self._response_for_set_quantity(
+                picking, selected_line, message=message
+            )
+        # process without pack, set destination location, and go back to
+        # `select_move`
+        selected_line.location_dest_id = location
+        return self._response_for_select_move(picking)
 
     def _set_quantity__by_lot(self, picking, selected_line, barcode):
         if selected_line.lot_id.name == barcode or selected_line.lot_name == barcode:
             selected_line.qty_done += 1
             return self._response_for_set_quantity(picking, selected_line)
 
     def _check_location_ok(self, location, selected_line, picking):
@@ -651,43 +797,57 @@
         )
 
     # ENDPOINTS
 
     def start(self):
         return self._response_for_select_document()
 
+    def _scan_document__get_handlers_by_type(self):
+        return {
+            "picking": self._scan_document__by_picking,
+            "product": self._scan_document__by_product,
+            "packaging": self._scan_document__by_packaging,
+            "lot": self._scan_document__by_lot,
+            "origin_move": self._scan_document__by_origin_move,
+        }
+
+    def _scan_document__get_find_kw(self):
+        return {
+            "picking": {"use_origin": True},
+            "delivered_picking": {"use_origin": True},
+        }
+
     def scan_document(self, barcode):
         """Scan a picking, a product or a packaging.
 
+        If an outgoing done move's origin is scanned, a return picking will be created.
+
         Input:
             barcode: the barcode of a product, a packaging, a picking name or a lot
 
         transitions:
           - select_document: Error: barcode not found
           - select_document: Multiple picking matching the product / packaging barcode
           - select_move: Picking scanned, one has been found
           - manual_selection: Press 'manual select' button, all available pickings are displayed
           - set_lot: Packaging / Product has been scanned,
                         single correspondance. Tracked product
           - set_quantity: Packaging / Product has been scanned,
                         single correspondance. Not tracked product
         """
-        handlers = (
-            self._scan_document__by_picking,
-            self._scan_document__by_product,
-            self._scan_document__by_packaging,
-            self._scan_document__by_lot,
-        )
-        response = self._use_handlers(handlers, barcode)
-        if response:
-            return response
-        # If nothing has been found, return a barcode not found error message
-        return self._response_for_select_document(
-            message=self.msg_store.barcode_not_found()
-        )
+        handlers_by_type = self._scan_document__get_handlers_by_type()
+        search = self._actions_for("search")
+        find_kw = self._scan_document__get_find_kw()
+        search_result = search.find(
+            barcode, handlers_by_type.keys(), handler_kw=find_kw
+        )
+        handler = handlers_by_type.get(search_result.type)
+        if handler:
+            return handler(search_result.record, barcode)
+        return self._scan_document__fallback()
 
     def list_stock_pickings(self):
         """Select a picking manually
 
         transitions:
         - select_document: Press 'back' button
         - select_move: Picking selected
@@ -717,26 +877,26 @@
           - set_lot: Packaging / Product has been scanned. Tracked product
           - set_quantity: Packaging / Product has been scanned. Not tracked product
         """
         picking = self.env["stock.picking"].browse(picking_id)
         message = self._check_picking_status(picking)
         if message:
             return self._response_for_select_move(picking, message=message)
-        handlers = (
-            self._scan_line__by_product,
-            self._scan_line__by_packaging,
-            self._scan_line__by_lot,
-        )
-        response = self._use_handlers(handlers, picking, barcode)
-        if response:
-            return response
-        # Nothing has been found, return an error
-        return self._response_for_select_move(
-            picking, message=self.msg_store.barcode_not_found()
-        )
+        handlers_by_type = {
+            "product": self._scan_line__by_product,
+            "packaging": self._scan_line__by_packaging,
+            "lot": self._scan_line__by_lot,
+        }
+        search = self._actions_for("search")
+        search_result = search.find(barcode, handlers_by_type.keys())
+        # Fallback handler, returns a barcode not found error
+        handler = handlers_by_type.get(search_result.type)
+        if handler:
+            return handler(picking, search_result.record)
+        return self._scan_line__fallback(picking, barcode)
 
     def done_action(self, picking_id, confirmation=False):
         """Mark a picking as done
 
         input:
             confirmation: if false, ask for confirmation; if true, mark as done
 
@@ -752,14 +912,20 @@
             return self._response_for_select_move(picking, message=message)
         if all(line.qty_done == 0 for line in picking.move_line_ids):
             # If no line has been processed, refuse to set the picking as done
             return self._response_for_select_move(
                 picking, message=self.msg_store.transfer_no_qty_done()
             )
         if not confirmation:
+            # Do not create a backorder if this is a shopfloor return.
+            if picking.is_shopfloor_created and self.work.menu.allow_return:
+                picking.with_context(cancel_backorder=True)._action_done()
+                return self._response_for_select_document(
+                    message=self.msg_store.transfer_done_success(picking)
+                )
             to_backorder = picking._check_backorder()
             if to_backorder:
                 # Not all lines are fully done, ask the user to confirm the
                 # backorder creation
                 return self._response_for_confirm_done(
                     picking, message=self.msg_store.transfer_confirm_done()
                 )
@@ -842,14 +1008,58 @@
     def _check_expiry_date(self, line):
         use_expiration_date = (
             line.product_id.use_expiration_date or line.lot_id.use_expiration_date
         )
         if use_expiration_date and not line.expiration_date:
             return self.msg_store.expiration_date_missing()
 
+    def _set_quantity__get_handlers_by_type(self):
+        return {
+            "product": self._set_quantity__by_product,
+            "packaging": self._set_quantity__by_packaging,
+            "package": self._set_quantity__by_package,
+            "location": self._set_quantity__by_location,
+            "lot": self._set_quantity__by_lot,
+        }
+
+    def _set_quantity__by_barcode(
+        self, picking, selected_line, barcode, confirmation=False
+    ):
+        handlers_by_type = self._set_quantity__get_handlers_by_type()
+        search = self._actions_for("search")
+        search_result = search.find(barcode, handlers_by_type.keys())
+        handler = handlers_by_type.get(search_result.type)
+        if handler:
+            return handler(picking, selected_line, search_result.record)
+        # Nothing found, ask user if we should create a new pack for the scanned
+        # barcode
+        if not confirmation:
+            return self._response_for_set_quantity(
+                picking,
+                selected_line,
+                message=self.msg_store.create_new_pack_ask_confirmation(barcode),
+                asking_confirmation=True,
+            )
+        package = self.env["stock.quant.package"].create({"name": barcode})
+        selected_line.result_package_id = package
+        return self._response_for_set_destination(picking, selected_line)
+
+    def _set_quantity__assign_quantity(self, picking, selected_line, quantity):
+        # If this is a return line, we cannot assign more qty_done than what
+        # was originally sent.
+        is_return_line = bool(selected_line.move_id.origin_returned_move_id)
+        max_qty_done = selected_line.move_id.product_uom_qty
+        if is_return_line and self.work.menu.allow_return:
+            if quantity > max_qty_done:
+                message = self.msg_store.return_line_invalid_qty()
+                return self._response_for_set_quantity(
+                    picking, selected_line, message=message
+                )
+        selected_line.qty_done = quantity
+
     def set_quantity(
         self,
         picking_id,
         selected_line_id,
         quantity=None,
         barcode=None,
         confirmation=False,
@@ -880,63 +1090,26 @@
             message = self.msg_store.record_not_found()
             return self._response_for_set_quantity(
                 picking, selected_line, message=message
             )
         if quantity:
             # We set qty_done to be equal to the qty of the picker
             # at the moment of the scan.
-            selected_line.qty_done = quantity
-        if barcode:
-            # Then, we add the qty of whatever was scanned
-            # on top of the qty of the picker.
-            handlers = (
-                self._set_quantity__by_product,
-                self._set_quantity__by_packaging,
-                self._set_quantity__by_package,
-                self._set_quantity__by_location,
-                self._set_quantity__by_lot,
+            response = self._set_quantity__assign_quantity(
+                picking, selected_line, quantity
             )
-            response = self._use_handlers(handlers, picking, selected_line, barcode)
             if response:
                 return response
-            # Nothing found, ask user if we should create a new pack for the scanned
-            # barcode.
-            if not confirmation:
-                return self._response_for_set_quantity(
-                    picking,
-                    selected_line,
-                    message=self.msg_store.create_new_pack_ask_confirmation(barcode),
-                    asking_confirmation=True,
-                )
-            # Nothing found and we already ask for confirmation, create the new package.
-            package = self.env["stock.quant.package"].create({"name": barcode})
-            quantity = selected_line.qty_done
-            __, qty_check = selected_line._split_qty_to_be_done(
-                quantity,
-                lot_id=False,
-                shopfloor_user_id=False,
-                expiration_date=False,
+        if barcode:
+            # Then, we add the qty of whatever was scanned
+            # on top of the qty of the picker.
+            return self._set_quantity__by_barcode(
+                picking, selected_line, barcode, confirmation
             )
-            if qty_check == "greater":
-                return self._response_for_set_quantity(
-                    picking,
-                    selected_line,
-                    message=self.msg_store.unable_to_pick_more(
-                        selected_line.product_uom_qty
-                    ),
-                )
-            selected_line.result_package_id = package
-            if self.work.menu.auto_post_line:
-                # If option auto_post_line is active in the shopfloor menu,
-                # create a split order with this line.
-                self._auto_post_line(selected_line)
-            return self._response_for_set_destination(picking, selected_line)
-        return self._response_for_set_quantity(
-            picking, selected_line, message=self.msg_store.barcode_not_found()
-        )
+        return self._response_for_set_quantity(picking, selected_line)
 
     def process_with_existing_pack(self, picking_id, selected_line_id, quantity):
         picking = self.env["stock.picking"].browse(picking_id)
         selected_line = self.env["stock.move.line"].browse(selected_line_id)
         message = self._check_picking_status(picking)
         if message:
             return self._response_for_set_quantity(
@@ -997,14 +1170,35 @@
                 message=self.msg_store.unable_to_pick_more(
                     selected_line.product_uom_qty
                 ),
             )
         selected_line.qty_done = quantity
         return self._response_for_set_destination(picking, selected_line)
 
+    def _post_line(self, selected_line):
+        if (
+            selected_line.picking_id.is_shopfloor_created
+            and self.work.menu.allow_return
+        ):
+            # If the transfer is not planned, and we allow unplanned returns,
+            # process the returned qty and mark it as done.
+            return self._post_shopfloor_created_line(selected_line)
+
+        if self.work.menu.auto_post_line:
+            # If option auto_post_line is active in the shopfloor menu,
+            # create a split order with this line.
+            self._auto_post_line(selected_line)
+
+    def _post_shopfloor_created_line(self, selected_line):
+        selected_line.product_uom_qty = selected_line.qty_done
+        selected_line.picking_id.with_context(cancel_backorder=True)._action_done()
+        return self._response_for_select_document(
+            message=self.msg_store.transfer_done_success(selected_line.picking_id)
+        )
+
     def _auto_post_line(self, selected_line):
         new_move = selected_line.move_id.split_other_move_lines(
             selected_line, intersection=True
         )
         new_move.extract_and_action_done()
 
     def set_destination(
@@ -1060,19 +1254,17 @@
                     picking,
                     selected_line,
                     message=self.msg_store.place_in_location_ask_confirmation(
                         location.name
                     ),
                 )
             selected_line.location_dest_id = location
-
-        if self.work.menu.auto_post_line:
-            # If option auto_post_line is active in the shopfloor menu,
-            # create a split order with this line.
-            self._auto_post_line(selected_line)
+        response = self._post_line(selected_line)
+        if response:
+            return response
         return self._response_for_select_move(picking)
 
     def select_dest_package(
         self, picking_id, selected_line_id, barcode, confirmation=False
     ):
         """Select the destination package for the move line
 
@@ -1106,18 +1298,17 @@
             if package.quant_ids:
                 return self._response_for_select_dest_package(
                     picking,
                     selected_line,
                     message=self.msg_store.package_not_empty(package),
                 )
             selected_line.result_package_id = package
-            if self.work.menu.auto_post_line:
-                # If option auto_post_line is active in the shopfloor menu,
-                # create a split order with this line.
-                self._auto_post_line(selected_line)
+            response = self._post_line(selected_line)
+            if response:
+                return response
             return self._response_for_select_move(picking)
         message = self.msg_store.create_new_pack_ask_confirmation(barcode)
         self._assign_user_to_picking(picking)
         return self._response_for_confirm_new_package(
             picking, selected_line, new_package_name=barcode, message=message
         )
```

## odoo/addons/shopfloor_reception/tests/__init__.py

```diff
@@ -5,7 +5,11 @@
 from . import test_reception_done
 from . import test_set_lot
 from . import test_set_lot_confirm
 from . import test_set_quantity
 from . import test_set_quantity_action
 from . import test_set_destination
 from . import test_select_dest_package
+from . import test_return_scan_document
+from . import test_return_scan_line
+from . import test_return_set_quantity
+from . import test_return_reception_done
```

## odoo/addons/shopfloor_reception/tests/common.py

```diff
@@ -46,19 +46,14 @@
     def setUpClassVars(cls, *args, **kwargs):
         super().setUpClassVars(*args, **kwargs)
         cls.menu = cls.env.ref("shopfloor_reception.shopfloor_menu_demo_reception")
         cls.profile = cls.env.ref("shopfloor.profile_demo_1")
         cls.picking_type = cls.menu.picking_type_ids
         cls.wh = cls.picking_type.warehouse_id
 
-    @classmethod
-    def setUpClassBaseData(cls, *args, **kwargs):
-        super().setUpClassBaseData(*args, **kwargs)
-        cls.wh.sudo().reception_steps = "two_steps"
-
     def _data_for_move_lines(self, lines, **kw):
         return self.data.move_lines(lines, **kw)
 
     def _data_for_picking_with_line(self, picking):
         picking_data = self._data_for_picking(picking)
         move_lines_data = self._data_for_move_lines(picking.move_line_ids)
         picking_data.update({"move_lines": move_lines_data})
```

## odoo/addons/shopfloor_reception/tests/test_reception_done.py

```diff
@@ -4,15 +4,15 @@
 from datetime import timedelta
 
 from odoo import fields
 
 from .common import CommonCase
 
 
-class TestSelectDestPackage(CommonCase):
+class TestReceptionDone(CommonCase):
     def test_set_done_no_backorder(self):
         picking = self._create_picking()
         picking.move_line_ids.write({"qty_done": 10, "shopfloor_checkout_done": True})
         response = self.service.dispatch(
             "done_action", params={"picking_id": picking.id}
         )
         # User is asked to confirm the action
```

## Comparing `odoo14_addon_shopfloor_reception-14.0.1.4.0.dist-info/METADATA` & `odoo14_addon_shopfloor_reception-14.0.2.0.0.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: odoo14-addon-shopfloor-reception
-Version: 14.0.1.4.0
+Version: 14.0.2.0.0
 Summary: Reception scenario for shopfloor
 Home-page: https://github.com/OCA/wms
 Author: Camptocamp, Odoo Community Association (OCA)
 Author-email: support@odoo-community.org
 License: AGPL-3
 Platform: UNKNOWN
 Classifier: Programming Language :: Python
```

## Comparing `odoo14_addon_shopfloor_reception-14.0.1.4.0.dist-info/RECORD` & `odoo14_addon_shopfloor_reception-14.0.2.0.0.dist-info/RECORD`

 * *Files 14% similar despite different names*

```diff
@@ -1,33 +1,40 @@
 odoo/addons/shopfloor_reception/README.rst,sha256=Tnpc_JsUSx9BfFo1IeKugKcvXhlMwt2Xb3QNxI58nuY,3384
-odoo/addons/shopfloor_reception/__init__.py,sha256=qksdRxAxHhEXpY0NZlTEolhxFILjRI5o7J0O4UrAE04,23
-odoo/addons/shopfloor_reception/__manifest__.py,sha256=on-A9wdM6t9x2a_ZEaVR0yxi8_3evVWH81b_AFR6Ayw,587
-odoo/addons/shopfloor_reception/data/shopfloor_scenario_data.xml,sha256=DSrWXaqkXwEIcw6YrkYYsZihjwnA9Ah2O37syYn8gz8,412
+odoo/addons/shopfloor_reception/__init__.py,sha256=kYJNnKRGQ0n5bRWJIoEPgRN_IzlcYzepihpGRteXVuI,44
+odoo/addons/shopfloor_reception/__manifest__.py,sha256=THGJXOCmHX-2QgVTh4vfxA3tifc4NtT4AXGqemp4ZSw,587
+odoo/addons/shopfloor_reception/data/shopfloor_scenario_data.xml,sha256=1bnPstzVOLobxvI39DOWBYv85Yh16LLvgDnICN7E0n8,444
 odoo/addons/shopfloor_reception/demo/shopfloor_menu_demo.xml,sha256=gNiAE7qk8vWaV2wnol52hOo1fFOM_9mxUyl3vKESspw,627
 odoo/addons/shopfloor_reception/demo/stock_picking_type_demo.xml,sha256=bsT91Ie8Sq1tzRyDlxqRTa3HoNlqRdDQyPLwYHVkDuE,965
 odoo/addons/shopfloor_reception/docs/reception_sequence_graph.mermaid,sha256=RtF-q5XBm9-Bw27MQXt-12oS4bdmTW6FSgyYbr4YXV0,3866
 odoo/addons/shopfloor_reception/docs/reception_sequence_graph.png,sha256=H41YZ5izgSD5CBxoDv51ypNGeWrOlwA7sXNH2NH1guM,155103
-odoo/addons/shopfloor_reception/i18n/shopfloor_reception.pot,sha256=rqeyaznriN_9zTy86npNrr2f87SJsRDQDHa1bjEU37M,658
+odoo/addons/shopfloor_reception/i18n/shopfloor_reception.pot,sha256=Ug5evnjOpN8Eed2-I0pq-jIa-VzMv9Qz8pKxd24rP3o,1421
+odoo/addons/shopfloor_reception/models/__init__.py,sha256=4KFk_msDhkBW-mEo4xByYxOerTYuVKjeaNN8_WcH6y8,28
+odoo/addons/shopfloor_reception/models/stock_picking.py,sha256=Vmderz3uCz3HTyKB1nJRpFyb-KgeR0P1Hb3PDULI4s0,239
 odoo/addons/shopfloor_reception/readme/CONTRIBUTORS.rst,sha256=T0hVdBlkQoY1jSU4_VeTBpXUfsII9PSBrSh7jtmOe2Y,216
 odoo/addons/shopfloor_reception/readme/DESCRIPTION.rst,sha256=WgVul7wqGircZzFGHZlHdf7uQwGDNYADf9HXF96ngow,131
 odoo/addons/shopfloor_reception/readme/ROADMAP.rst,sha256=-oVCQbD8gOlGbREemrJISQ785Mhf3_KDv4b26EKl0lw,109
 odoo/addons/shopfloor_reception/services/__init__.py,sha256=KwBANbkfhp2yAZYBiuBKYL2G7ky7sCaE-0yO4b-0mgs,24
-odoo/addons/shopfloor_reception/services/reception.py,sha256=7-OBDdvrooD7Kx3k6igBSo3cAWc4TKRoELgj_h1QvKQ,58745
+odoo/addons/shopfloor_reception/services/reception.py,sha256=AC0bL9-BZY3hZY-CUA7j21EDzdCqnPeSFEgDfyrwS7U,67833
 odoo/addons/shopfloor_reception/static/description/icon.png,sha256=6xBPJauaFOF0KDHfHgQopSc28kKvxMaeoQFQWZtfZDo,9455
 odoo/addons/shopfloor_reception/static/description/index.html,sha256=a5J-vJ6aIA2frc-pJnrak7YlbPL4ksEXYOePLA1-tWg,12973
-odoo/addons/shopfloor_reception/tests/__init__.py,sha256=WHT---1-luQV6ExwBdDJjWJwBqUu1sk9AP-VFP5aOV8,368
-odoo/addons/shopfloor_reception/tests/common.py,sha256=kmYpDg2xERfIR-nujEtnxcCWiKXA9MI7gYNKpNn5qx8,4729
+odoo/addons/shopfloor_reception/tests/__init__.py,sha256=JSL0WRljl0_Y_4SG0ORN1KFlcdsXBSAQ3y_U34KHE8E,524
+odoo/addons/shopfloor_reception/tests/common.py,sha256=zMyAL7HneDrFK3qVv_3fOBn-AEPp-gJCyJvMTGZj5ZY,4557
+odoo/addons/shopfloor_reception/tests/reception_return_common.py,sha256=Jwq1fDJFUGt0jOfgMsO2gQl9iof6ToIpE2BVKdPfxFw,4777
 odoo/addons/shopfloor_reception/tests/test_manual_selection.py,sha256=jUWqAyWcGsoFTLeLLOk0mTadZk-mlR1RBbl4fasUoWI,1253
-odoo/addons/shopfloor_reception/tests/test_reception_done.py,sha256=9dqn3WUmaPwjwcvnT8eXj7Mi_96kQP1ZaY1m8fmSAgc,3450
+odoo/addons/shopfloor_reception/tests/test_reception_done.py,sha256=5Mkl-8KgXqyaLDYu5xZ6752-ZmZ_658VdKCFe9Pe-VE,3446
+odoo/addons/shopfloor_reception/tests/test_return_reception_done.py,sha256=WbgdZ6nMkL_xaOpjqtky_Y2iqaEXU-s8BVTbuIeE1RA,5282
+odoo/addons/shopfloor_reception/tests/test_return_scan_document.py,sha256=VyTe1_CNZCJZxD1AYS3pLeJCr_GPV-9gycRZqo46cQM,3587
+odoo/addons/shopfloor_reception/tests/test_return_scan_line.py,sha256=E0Bfg4qfACMHGwiNkMsHk4PXZ0HDLfEHidipGV3dBXc,3889
+odoo/addons/shopfloor_reception/tests/test_return_set_quantity.py,sha256=Np2SWaR7adks4YPJJ7YAOsQ-Nz2sI2C9iFOzSpfvJm0,4524
 odoo/addons/shopfloor_reception/tests/test_select_dest_package.py,sha256=SQd5tmp_swFjLfwJ5npKR8W1sFQW6es5KltErY1tMY0,4836
 odoo/addons/shopfloor_reception/tests/test_select_document.py,sha256=PZB_f7CgQsfEB2qN387CFqEVy2x1tIuIZ30Z4F1IcDs,6110
 odoo/addons/shopfloor_reception/tests/test_select_move.py,sha256=u1iR25Emn-CiCjqdLe2SrbLAfV5CJNBja6MDR0c3mfM,10798
 odoo/addons/shopfloor_reception/tests/test_set_destination.py,sha256=_YM3HRnT0zti6VwlN-Mhg8hPRYn3cGB7FdMpDQrrggQ,6279
 odoo/addons/shopfloor_reception/tests/test_set_lot.py,sha256=JtEMOcBNYAYmj1KIL9C2Zs4dBJWM7dbwadO3iRi5bOo,5574
 odoo/addons/shopfloor_reception/tests/test_set_lot_confirm.py,sha256=LfC8ct247by9V2Df3THnE_VT4dT0KMYrWGn28JM2lR8,2267
 odoo/addons/shopfloor_reception/tests/test_set_quantity.py,sha256=d-iAbgK32cd_WBjboVEMooK3yI80rfycOJ6LzSligBg,14254
 odoo/addons/shopfloor_reception/tests/test_set_quantity_action.py,sha256=Q1AjYwAJT-lVjYPOOi0P-9cyes0wfniSiH0R3lGgvQU,2914
 odoo/addons/shopfloor_reception/tests/test_start.py,sha256=Df9ezNG7BqJQ6PtNY4-LvH1SyFZdpyF4LjV1PhpsCqY,1699
-odoo14_addon_shopfloor_reception-14.0.1.4.0.dist-info/METADATA,sha256=6Ar-Liw3X06keZFoRSudPuWxlxp8Udob2k2JbgPj4Ek,4006
-odoo14_addon_shopfloor_reception-14.0.1.4.0.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-odoo14_addon_shopfloor_reception-14.0.1.4.0.dist-info/top_level.txt,sha256=qBj40grFkGOfDZ2WDSw3y1RnDlgG0u8rP8pvGNdbz4w,5
-odoo14_addon_shopfloor_reception-14.0.1.4.0.dist-info/RECORD,,
+odoo14_addon_shopfloor_reception-14.0.2.0.0.dist-info/METADATA,sha256=2Z8G-UVkBP0JwH_0ATB8kMJKumdIciwH3uRZO5kud4I,4006
+odoo14_addon_shopfloor_reception-14.0.2.0.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+odoo14_addon_shopfloor_reception-14.0.2.0.0.dist-info/top_level.txt,sha256=qBj40grFkGOfDZ2WDSw3y1RnDlgG0u8rP8pvGNdbz4w,5
+odoo14_addon_shopfloor_reception-14.0.2.0.0.dist-info/RECORD,,
```

